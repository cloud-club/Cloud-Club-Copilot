import {
  AuthError,
  AuthToken_exports,
  ClientAuthError,
  ClientAuthErrorCodes_exports,
  CryptoOps,
  DEFAULT_CRYPTO_IMPLEMENTATION,
  EventHandler,
  EventType,
  InteractionRequiredAuthError,
  InteractionType,
  PerformanceEvents,
  ServerError,
  TimeUtils
} from "./chunk-RVX2U4VA.js";
import "./chunk-5WWUZCGV.js";

// node_modules/@azure/msal-browser/dist/naa/BridgeError.mjs
function isBridgeError(error) {
  return error.status !== void 0;
}

// node_modules/@azure/msal-browser/dist/naa/BridgeStatusCode.mjs
var BridgeStatusCode;
(function(BridgeStatusCode2) {
  BridgeStatusCode2["USER_INTERACTION_REQUIRED"] = "USER_INTERACTION_REQUIRED";
  BridgeStatusCode2["USER_CANCEL"] = "USER_CANCEL";
  BridgeStatusCode2["NO_NETWORK"] = "NO_NETWORK";
  BridgeStatusCode2["TRANSIENT_ERROR"] = "TRANSIENT_ERROR";
  BridgeStatusCode2["PERSISTENT_ERROR"] = "PERSISTENT_ERROR";
  BridgeStatusCode2["DISABLED"] = "DISABLED";
  BridgeStatusCode2["ACCOUNT_UNAVAILABLE"] = "ACCOUNT_UNAVAILABLE";
  BridgeStatusCode2["NESTED_APP_AUTH_UNAVAILABLE"] = "NESTED_APP_AUTH_UNAVAILABLE";
})(BridgeStatusCode || (BridgeStatusCode = {}));

// node_modules/@azure/msal-browser/dist/naa/mapping/NestedAppAuthAdapter.mjs
var NestedAppAuthAdapter = class {
  constructor(clientId, clientCapabilities, crypto, logger) {
    this.clientId = clientId;
    this.clientCapabilities = clientCapabilities;
    this.crypto = crypto;
    this.logger = logger;
  }
  toNaaSilentTokenRequest(request) {
    var _a;
    let extraParams;
    if (request.extraQueryParameters === void 0) {
      extraParams = /* @__PURE__ */ new Map();
    } else {
      extraParams = new Map(Object.entries(request.extraQueryParameters));
    }
    const tokenRequest = {
      userObjectId: (_a = request.account) == null ? void 0 : _a.homeAccountId,
      clientId: this.clientId,
      authority: request.authority,
      scope: request.scopes.join(" "),
      correlationId: request.correlationId !== void 0 ? request.correlationId : this.crypto.createNewGuid(),
      prompt: request.prompt !== void 0 ? request.prompt : "",
      claims: request.claims !== void 0 ? request.claims : "",
      authenticationScheme: request.authenticationScheme !== void 0 ? request.authenticationScheme : "",
      clientCapabilities: this.clientCapabilities,
      extraParameters: extraParams
    };
    return tokenRequest;
  }
  toNaaTokenRequest(request) {
    var _a;
    let extraParams;
    if (request.extraQueryParameters === void 0) {
      extraParams = /* @__PURE__ */ new Map();
    } else {
      extraParams = new Map(Object.entries(request.extraQueryParameters));
    }
    const tokenRequest = {
      userObjectId: (_a = request.account) == null ? void 0 : _a.homeAccountId,
      clientId: this.clientId,
      authority: request.authority,
      scope: request.scopes.join(" "),
      correlationId: request.correlationId !== void 0 ? request.correlationId : "",
      prompt: request.prompt !== void 0 ? request.prompt : "",
      nonce: request.nonce !== void 0 ? request.nonce : "",
      claims: request.claims !== void 0 ? request.claims : "",
      state: request.state !== void 0 ? request.state : "",
      authenticationScheme: request.authenticationScheme !== void 0 ? request.authenticationScheme : "",
      clientCapabilities: void 0,
      extraParameters: extraParams
    };
    return tokenRequest;
  }
  fromNaaTokenResponse(request, response) {
    const expiresOn = new Date(TimeUtils.nowSeconds() + (response.expires_in || 0) * 1e3);
    const account = this.fromNaaAccountInfo(response.account);
    const authenticationResult = {
      authority: response.account.environment,
      uniqueId: response.account.homeAccountId,
      tenantId: response.account.tenantId,
      scopes: response.scope.split(" "),
      account: this.fromNaaAccountInfo(response.account),
      idToken: response.id_token !== void 0 ? response.id_token : "",
      idTokenClaims: account.idTokenClaims !== void 0 ? account.idTokenClaims : {},
      accessToken: response.access_token,
      fromCache: true,
      expiresOn,
      tokenType: request.authenticationScheme !== void 0 ? request.authenticationScheme : "Bearer",
      correlationId: request.correlationId,
      requestId: "",
      extExpiresOn: expiresOn,
      state: response.state
    };
    return authenticationResult;
  }
  /*
   *  export type AccountInfo = {
   *     homeAccountId: string;
   *     environment: string;
   *     tenantId: string;
   *     username: string;
   *     localAccountId: string;
   *     name?: string;
   *     idToken?: string;
   *     idTokenClaims?: TokenClaims & {
   *         [key: string]:
   *             | string
   *             | number
   *             | string[]
   *             | object
   *             | undefined
   *             | unknown;
   *     };
   *     nativeAccountId?: string;
   *     authorityType?: string;
   * };
   */
  fromNaaAccountInfo(fromAccount) {
    let tokenClaims;
    if (fromAccount.idToken !== void 0) {
      tokenClaims = AuthToken_exports.extractTokenClaims(fromAccount.idToken, this.crypto.base64Decode);
    } else {
      tokenClaims = void 0;
    }
    const account = {
      homeAccountId: fromAccount.homeAccountId,
      environment: fromAccount.environment,
      tenantId: fromAccount.tenantId,
      username: fromAccount.username,
      localAccountId: fromAccount.localAccountId,
      name: fromAccount.name,
      idToken: fromAccount.idToken,
      idTokenClaims: tokenClaims
    };
    return account;
  }
  /**
   *
   * @param error BridgeError
   * @returns AuthError, ClientAuthError, ClientConfigurationError, ServerError, InteractionRequiredError
   */
  fromBridgeError(error) {
    if (isBridgeError(error)) {
      switch (error.status) {
        case BridgeStatusCode.USER_CANCEL:
          return new ClientAuthError(ClientAuthErrorCodes_exports.userCanceled);
        case BridgeStatusCode.NO_NETWORK:
          return new ClientAuthError(ClientAuthErrorCodes_exports.noNetworkConnectivity);
        case BridgeStatusCode.ACCOUNT_UNAVAILABLE:
          return new ClientAuthError(ClientAuthErrorCodes_exports.noAccountFound);
        case BridgeStatusCode.DISABLED:
          return new ClientAuthError(ClientAuthErrorCodes_exports.nestedAppAuthBridgeDisabled);
        case BridgeStatusCode.NESTED_APP_AUTH_UNAVAILABLE:
          return new ClientAuthError(error.code, error.description);
        case BridgeStatusCode.TRANSIENT_ERROR:
        case BridgeStatusCode.PERSISTENT_ERROR:
          return new ServerError(error.code, error.description);
        case BridgeStatusCode.USER_INTERACTION_REQUIRED:
          return new InteractionRequiredAuthError(error.code, error.description);
        default:
          return new AuthError(error.code, error.description);
      }
    } else {
      return new AuthError("unknown_error", "An unknown error occurred");
    }
  }
};

// node_modules/@azure/msal-browser/dist/error/NestedAppAuthError.mjs
var NestedAppAuthErrorMessage = {
  unsupportedMethod: {
    code: "unsupported_method",
    desc: "The PKCE code challenge and verifier could not be generated."
  }
};
var NestedAppAuthError = class _NestedAppAuthError extends AuthError {
  constructor(errorCode, errorMessage) {
    super(errorCode, errorMessage);
    Object.setPrototypeOf(this, _NestedAppAuthError.prototype);
    this.name = "NestedAppAuthError";
  }
  static createUnsupportedError() {
    return new _NestedAppAuthError(NestedAppAuthErrorMessage.unsupportedMethod.code, NestedAppAuthErrorMessage.unsupportedMethod.desc);
  }
};

// node_modules/@azure/msal-browser/dist/controllers/NestedAppAuthController.mjs
var NestedAppAuthController = class _NestedAppAuthController {
  constructor(operatingContext) {
    this.operatingContext = operatingContext;
    const proxy = this.operatingContext.getBridgeProxy();
    if (proxy !== void 0) {
      this.bridgeProxy = proxy;
    } else {
      throw new Error("unexpected: bridgeProxy is undefined");
    }
    this.config = operatingContext.getConfig();
    this.logger = this.operatingContext.getLogger();
    this.performanceClient = this.config.telemetry.client;
    this.browserCrypto = operatingContext.isBrowserEnvironment() ? new CryptoOps(this.logger, this.performanceClient) : DEFAULT_CRYPTO_IMPLEMENTATION;
    this.eventHandler = new EventHandler(this.logger, this.browserCrypto);
    this.nestedAppAuthAdapter = new NestedAppAuthAdapter(this.config.auth.clientId, this.config.auth.clientCapabilities, this.browserCrypto, this.logger);
  }
  getBrowserStorage() {
    throw NestedAppAuthError.createUnsupportedError();
  }
  getEventHandler() {
    return this.eventHandler;
  }
  static async createController(operatingContext) {
    const controller = new _NestedAppAuthController(operatingContext);
    return Promise.resolve(controller);
  }
  initialize() {
    return Promise.resolve();
  }
  async acquireTokenInteractive(request) {
    this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Popup, request);
    const atPopupMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenPopup, request.correlationId);
    atPopupMeasurement == null ? void 0 : atPopupMeasurement.add({ nestedAppAuthRequest: true });
    try {
      const naaRequest = this.nestedAppAuthAdapter.toNaaTokenRequest(request);
      const response = await this.bridgeProxy.getTokenInteractive(naaRequest);
      const result = this.nestedAppAuthAdapter.fromNaaTokenResponse(naaRequest, response);
      this.operatingContext.setActiveAccount(result.account);
      this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Popup, result);
      atPopupMeasurement.add({
        accessTokenSize: result.accessToken.length,
        idTokenSize: result.idToken.length
      });
      atPopupMeasurement.end({
        success: true,
        requestId: result.requestId
      });
      return result;
    } catch (e) {
      const error = this.nestedAppAuthAdapter.fromBridgeError(e);
      this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Popup, null, e);
      atPopupMeasurement.end({
        errorCode: error.errorCode,
        subErrorCode: error.subError,
        success: false
      });
      throw error;
    }
  }
  async acquireTokenSilentInternal(request) {
    this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Silent, request);
    const ssoSilentMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.SsoSilent, request.correlationId);
    ssoSilentMeasurement == null ? void 0 : ssoSilentMeasurement.increment({
      visibilityChangeCount: 0
    });
    ssoSilentMeasurement == null ? void 0 : ssoSilentMeasurement.add({
      nestedAppAuthRequest: true
    });
    try {
      const naaRequest = this.nestedAppAuthAdapter.toNaaSilentTokenRequest(request);
      const response = await this.bridgeProxy.getTokenSilent(naaRequest);
      const result = this.nestedAppAuthAdapter.fromNaaTokenResponse(naaRequest, response);
      this.operatingContext.setActiveAccount(result.account);
      this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Silent, result);
      ssoSilentMeasurement == null ? void 0 : ssoSilentMeasurement.add({
        accessTokenSize: result.accessToken.length,
        idTokenSize: result.idToken.length
      });
      ssoSilentMeasurement == null ? void 0 : ssoSilentMeasurement.end({
        success: true,
        requestId: result.requestId
      });
      return result;
    } catch (e) {
      const error = this.nestedAppAuthAdapter.fromBridgeError(e);
      this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Silent, null, e);
      ssoSilentMeasurement == null ? void 0 : ssoSilentMeasurement.end({
        errorCode: error.errorCode,
        subErrorCode: error.subError,
        success: false
      });
      throw error;
    }
  }
  async acquireTokenPopup(request) {
    return this.acquireTokenInteractive(request);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  acquireTokenRedirect(request) {
    throw NestedAppAuthError.createUnsupportedError();
  }
  async acquireTokenSilent(silentRequest) {
    return this.acquireTokenSilentInternal(silentRequest);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  acquireTokenByCode(request) {
    throw NestedAppAuthError.createUnsupportedError();
  }
  acquireTokenNative(request, apiId, accountId) {
    throw NestedAppAuthError.createUnsupportedError();
  }
  acquireTokenByRefreshToken(commonRequest, silentRequest) {
    throw NestedAppAuthError.createUnsupportedError();
  }
  /**
   * Adds event callbacks to array
   * @param callback
   */
  addEventCallback(callback) {
    return this.eventHandler.addEventCallback(callback);
  }
  /**
   * Removes callback with provided id from callback array
   * @param callbackId
   */
  removeEventCallback(callbackId) {
    this.eventHandler.removeEventCallback(callbackId);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  addPerformanceCallback(callback) {
    throw NestedAppAuthError.createUnsupportedError();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  removePerformanceCallback(callbackId) {
    throw NestedAppAuthError.createUnsupportedError();
  }
  enableAccountStorageEvents() {
    throw NestedAppAuthError.createUnsupportedError();
  }
  disableAccountStorageEvents() {
    throw NestedAppAuthError.createUnsupportedError();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getAccount(accountFilter) {
    throw NestedAppAuthError.createUnsupportedError();
  }
  getAccountByHomeId(homeAccountId) {
    const currentAccount = this.operatingContext.getActiveAccount();
    if (currentAccount !== void 0) {
      if (currentAccount.homeAccountId === homeAccountId) {
        return this.nestedAppAuthAdapter.fromNaaAccountInfo(currentAccount);
      } else {
        return null;
      }
    } else {
      return null;
    }
  }
  getAccountByLocalId(localId) {
    const currentAccount = this.operatingContext.getActiveAccount();
    if (currentAccount !== void 0) {
      if (currentAccount.localAccountId === localId) {
        return this.nestedAppAuthAdapter.fromNaaAccountInfo(currentAccount);
      } else {
        return null;
      }
    } else {
      return null;
    }
  }
  getAccountByUsername(userName) {
    const currentAccount = this.operatingContext.getActiveAccount();
    if (currentAccount !== void 0) {
      if (currentAccount.username === userName) {
        return this.nestedAppAuthAdapter.fromNaaAccountInfo(currentAccount);
      } else {
        return null;
      }
    } else {
      return null;
    }
  }
  getAllAccounts() {
    const currentAccount = this.operatingContext.getActiveAccount();
    if (currentAccount !== void 0) {
      return [
        this.nestedAppAuthAdapter.fromNaaAccountInfo(currentAccount)
      ];
    } else {
      return [];
    }
  }
  handleRedirectPromise(hash) {
    throw NestedAppAuthError.createUnsupportedError();
  }
  loginPopup(request) {
    if (request !== void 0) {
      return this.acquireTokenInteractive(request);
    } else {
      throw NestedAppAuthError.createUnsupportedError();
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  loginRedirect(request) {
    throw NestedAppAuthError.createUnsupportedError();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  logout(logoutRequest) {
    throw NestedAppAuthError.createUnsupportedError();
  }
  logoutRedirect(logoutRequest) {
    throw NestedAppAuthError.createUnsupportedError();
  }
  logoutPopup(logoutRequest) {
    throw NestedAppAuthError.createUnsupportedError();
  }
  ssoSilent(request) {
    return this.acquireTokenSilentInternal(request);
  }
  getTokenCache() {
    throw NestedAppAuthError.createUnsupportedError();
  }
  /**
   * Returns the logger instance
   */
  getLogger() {
    return this.logger;
  }
  /**
   * Replaces the default logger set in configurations with new Logger with new configurations
   * @param logger Logger instance
   */
  setLogger(logger) {
    this.logger = logger;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  setActiveAccount(account) {
    this.logger.warning("nestedAppAuth does not support setActiveAccount");
    return;
  }
  getActiveAccount() {
    const currentAccount = this.operatingContext.getActiveAccount();
    if (currentAccount !== void 0) {
      return this.nestedAppAuthAdapter.fromNaaAccountInfo(currentAccount);
    } else {
      return null;
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  initializeWrapperLibrary(sku, version) {
    return;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  setNavigationClient(navigationClient) {
    this.logger.warning("setNavigationClient is not supported in nested app auth");
  }
  getConfiguration() {
    return this.config;
  }
  isBrowserEnv() {
    return this.operatingContext.isBrowserEnvironment();
  }
  getBrowserCrypto() {
    return this.browserCrypto;
  }
  getPerformanceClient() {
    throw NestedAppAuthError.createUnsupportedError();
  }
  getRedirectResponse() {
    throw NestedAppAuthError.createUnsupportedError();
  }
  preflightBrowserEnvironmentCheck(interactionType, setInteractionInProgress) {
    throw NestedAppAuthError.createUnsupportedError();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async clearCache(logoutRequest) {
    throw NestedAppAuthError.createUnsupportedError();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async hydrateCache(result, request) {
    throw NestedAppAuthError.createUnsupportedError();
  }
};
export {
  NestedAppAuthController
};
/*! Bundled license information:

@azure/msal-browser/dist/naa/BridgeError.mjs:
  (*! @azure/msal-browser v3.4.0 2023-10-30 *)

@azure/msal-browser/dist/naa/BridgeStatusCode.mjs:
  (*! @azure/msal-browser v3.4.0 2023-10-30 *)

@azure/msal-browser/dist/naa/mapping/NestedAppAuthAdapter.mjs:
  (*! @azure/msal-browser v3.4.0 2023-10-30 *)

@azure/msal-browser/dist/error/NestedAppAuthError.mjs:
  (*! @azure/msal-browser v3.4.0 2023-10-30 *)

@azure/msal-browser/dist/controllers/NestedAppAuthController.mjs:
  (*! @azure/msal-browser v3.4.0 2023-10-30 *)
*/
//# sourceMappingURL=NestedAppAuthController-LSMQ3PLN.js.map
