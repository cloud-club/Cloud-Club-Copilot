import {
  require_jsx_runtime
} from "./chunk-UFCMWVQY.js";
import {
  require_react_dom
} from "./chunk-GPLYVEWD.js";
import {
  ArrowDownRegular,
  ArrowUpRegular,
  Checkmark12Filled,
  Checkmark16Filled,
  CheckmarkCircle12Filled,
  CircleFilled,
  ErrorCircle12Filled,
  MoreHorizontalRegular,
  PersonRegular,
  PresenceAvailable10Filled,
  PresenceAvailable10Regular,
  PresenceAvailable12Filled,
  PresenceAvailable12Regular,
  PresenceAvailable16Filled,
  PresenceAvailable16Regular,
  PresenceAvailable20Filled,
  PresenceAvailable20Regular,
  PresenceAway10Filled,
  PresenceAway10Regular,
  PresenceAway12Filled,
  PresenceAway12Regular,
  PresenceAway16Filled,
  PresenceAway16Regular,
  PresenceAway20Filled,
  PresenceAway20Regular,
  PresenceBlocked10Regular,
  PresenceBlocked12Regular,
  PresenceBlocked16Regular,
  PresenceBlocked20Regular,
  PresenceBusy10Filled,
  PresenceBusy12Filled,
  PresenceBusy16Filled,
  PresenceBusy20Filled,
  PresenceDnd10Filled,
  PresenceDnd10Regular,
  PresenceDnd12Filled,
  PresenceDnd12Regular,
  PresenceDnd16Filled,
  PresenceDnd16Regular,
  PresenceDnd20Filled,
  PresenceDnd20Regular,
  PresenceOffline10Regular,
  PresenceOffline12Regular,
  PresenceOffline16Regular,
  PresenceOffline20Regular,
  PresenceOof10Regular,
  PresenceOof12Regular,
  PresenceOof16Regular,
  PresenceOof20Regular,
  PresenceUnknown10Regular,
  PresenceUnknown12Regular,
  PresenceUnknown16Regular,
  PresenceUnknown20Regular,
  Square12Filled,
  Square16Filled,
  Warning12Filled,
  __resetStyles,
  __styles2 as __styles,
  mergeClasses,
  shorthands
} from "./chunk-W5HNMBRP.js";
import {
  require_react
} from "./chunk-RDZYK52F.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-5WWUZCGV.js";

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var REACT_ELEMENT_TYPE = 60103;
        var REACT_PORTAL_TYPE = 60106;
        var REACT_FRAGMENT_TYPE = 60107;
        var REACT_STRICT_MODE_TYPE2 = 60108;
        var REACT_PROFILER_TYPE = 60114;
        var REACT_PROVIDER_TYPE = 60109;
        var REACT_CONTEXT_TYPE = 60110;
        var REACT_FORWARD_REF_TYPE = 60112;
        var REACT_SUSPENSE_TYPE = 60113;
        var REACT_SUSPENSE_LIST_TYPE = 60120;
        var REACT_MEMO_TYPE = 60115;
        var REACT_LAZY_TYPE = 60116;
        var REACT_BLOCK_TYPE = 60121;
        var REACT_SERVER_BLOCK_TYPE = 60122;
        var REACT_FUNDAMENTAL_TYPE = 60117;
        var REACT_SCOPE_TYPE = 60119;
        var REACT_OPAQUE_ID_TYPE = 60128;
        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
        var REACT_OFFSCREEN_TYPE = 60130;
        var REACT_LEGACY_HIDDEN_TYPE = 60131;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          REACT_ELEMENT_TYPE = symbolFor("react.element");
          REACT_PORTAL_TYPE = symbolFor("react.portal");
          REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
          REACT_STRICT_MODE_TYPE2 = symbolFor("react.strict_mode");
          REACT_PROFILER_TYPE = symbolFor("react.profiler");
          REACT_PROVIDER_TYPE = symbolFor("react.provider");
          REACT_CONTEXT_TYPE = symbolFor("react.context");
          REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
          REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
          REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
          REACT_MEMO_TYPE = symbolFor("react.memo");
          REACT_LAZY_TYPE = symbolFor("react.lazy");
          REACT_BLOCK_TYPE = symbolFor("react.block");
          REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
          REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
          REACT_SCOPE_TYPE = symbolFor("react.scope");
          REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
          REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
          REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
        }
        var enableScopeAPI = false;
        function isValidElementType2(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE2 || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
              return true;
            }
          }
          return false;
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE2:
                  case REACT_SUSPENSE_TYPE:
                  case REACT_SUSPENSE_LIST_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment7 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal2 = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE2;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isConcurrentMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
              hasWarnedAboutDeprecatedIsConcurrentMode = true;
              console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement2(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE2;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment7;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal2;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement2;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType2;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/scheduler/cjs/scheduler.development.js
var require_scheduler_development = __commonJS({
  "node_modules/scheduler/cjs/scheduler.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var enableSchedulerDebugging = false;
        var enableProfiling = false;
        var requestHostCallback;
        var requestHostTimeout;
        var cancelHostTimeout;
        var requestPaint;
        var hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
        if (hasPerformanceNow) {
          var localPerformance = performance;
          exports.unstable_now = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date;
          var initialTime = localDate.now();
          exports.unstable_now = function() {
            return localDate.now() - initialTime;
          };
        }
        if (
          // If Scheduler runs in a non-DOM environment, it falls back to a naive
          // implementation using setTimeout.
          typeof window === "undefined" || // Check if MessageChannel is supported, too.
          typeof MessageChannel !== "function"
        ) {
          var _callback = null;
          var _timeoutID = null;
          var _flushCallback = function() {
            if (_callback !== null) {
              try {
                var currentTime = exports.unstable_now();
                var hasRemainingTime = true;
                _callback(hasRemainingTime, currentTime);
                _callback = null;
              } catch (e2) {
                setTimeout(_flushCallback, 0);
                throw e2;
              }
            }
          };
          requestHostCallback = function(cb) {
            if (_callback !== null) {
              setTimeout(requestHostCallback, 0, cb);
            } else {
              _callback = cb;
              setTimeout(_flushCallback, 0);
            }
          };
          requestHostTimeout = function(cb, ms) {
            _timeoutID = setTimeout(cb, ms);
          };
          cancelHostTimeout = function() {
            clearTimeout(_timeoutID);
          };
          exports.unstable_shouldYield = function() {
            return false;
          };
          requestPaint = exports.unstable_forceFrameRate = function() {
          };
        } else {
          var _setTimeout = window.setTimeout;
          var _clearTimeout = window.clearTimeout;
          if (typeof console !== "undefined") {
            var requestAnimationFrame2 = window.requestAnimationFrame;
            var cancelAnimationFrame2 = window.cancelAnimationFrame;
            if (typeof requestAnimationFrame2 !== "function") {
              console["error"]("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
            }
            if (typeof cancelAnimationFrame2 !== "function") {
              console["error"]("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
            }
          }
          var isMessageLoopRunning = false;
          var scheduledHostCallback = null;
          var taskTimeoutID = -1;
          var yieldInterval = 5;
          var deadline = 0;
          {
            exports.unstable_shouldYield = function() {
              return exports.unstable_now() >= deadline;
            };
            requestPaint = function() {
            };
          }
          exports.unstable_forceFrameRate = function(fps) {
            if (fps < 0 || fps > 125) {
              console["error"]("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
              return;
            }
            if (fps > 0) {
              yieldInterval = Math.floor(1e3 / fps);
            } else {
              yieldInterval = 5;
            }
          };
          var performWorkUntilDeadline = function() {
            if (scheduledHostCallback !== null) {
              var currentTime = exports.unstable_now();
              deadline = currentTime + yieldInterval;
              var hasTimeRemaining = true;
              try {
                var hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
                if (!hasMoreWork) {
                  isMessageLoopRunning = false;
                  scheduledHostCallback = null;
                } else {
                  port.postMessage(null);
                }
              } catch (error) {
                port.postMessage(null);
                throw error;
              }
            } else {
              isMessageLoopRunning = false;
            }
          };
          var channel = new MessageChannel();
          var port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          requestHostCallback = function(callback) {
            scheduledHostCallback = callback;
            if (!isMessageLoopRunning) {
              isMessageLoopRunning = true;
              port.postMessage(null);
            }
          };
          requestHostTimeout = function(callback, ms) {
            taskTimeoutID = _setTimeout(function() {
              callback(exports.unstable_now());
            }, ms);
          };
          cancelHostTimeout = function() {
            _clearTimeout(taskTimeoutID);
            taskTimeoutID = -1;
          };
        }
        function push(heap, node) {
          var index = heap.length;
          heap.push(node);
          siftUp(heap, node, index);
        }
        function peek(heap) {
          var first = heap[0];
          return first === void 0 ? null : first;
        }
        function pop(heap) {
          var first = heap[0];
          if (first !== void 0) {
            var last = heap.pop();
            if (last !== first) {
              heap[0] = last;
              siftDown(heap, last, 0);
            }
            return first;
          } else {
            return null;
          }
        }
        function siftUp(heap, node, i3) {
          var index = i3;
          while (true) {
            var parentIndex = index - 1 >>> 1;
            var parent2 = heap[parentIndex];
            if (parent2 !== void 0 && compare(parent2, node) > 0) {
              heap[parentIndex] = node;
              heap[index] = parent2;
              index = parentIndex;
            } else {
              return;
            }
          }
        }
        function siftDown(heap, node, i3) {
          var index = i3;
          var length = heap.length;
          while (index < length) {
            var leftIndex = (index + 1) * 2 - 1;
            var left2 = heap[leftIndex];
            var rightIndex = leftIndex + 1;
            var right2 = heap[rightIndex];
            if (left2 !== void 0 && compare(left2, node) < 0) {
              if (right2 !== void 0 && compare(right2, left2) < 0) {
                heap[index] = right2;
                heap[rightIndex] = node;
                index = rightIndex;
              } else {
                heap[index] = left2;
                heap[leftIndex] = node;
                index = leftIndex;
              }
            } else if (right2 !== void 0 && compare(right2, node) < 0) {
              heap[index] = right2;
              heap[rightIndex] = node;
              index = rightIndex;
            } else {
              return;
            }
          }
        }
        function compare(a3, b2) {
          var diff = a3.sortIndex - b2.sortIndex;
          return diff !== 0 ? diff : a3.id - b2.id;
        }
        var ImmediatePriority = 1;
        var UserBlockingPriority = 2;
        var NormalPriority2 = 3;
        var LowPriority = 4;
        var IdlePriority = 5;
        function markTaskErrored(task, ms) {
        }
        var maxSigned31BitInt = 1073741823;
        var IMMEDIATE_PRIORITY_TIMEOUT = -1;
        var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
        var NORMAL_PRIORITY_TIMEOUT = 5e3;
        var LOW_PRIORITY_TIMEOUT = 1e4;
        var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
        var taskQueue = [];
        var timerQueue = [];
        var taskIdCounter = 1;
        var currentTask = null;
        var currentPriorityLevel = NormalPriority2;
        var isPerformingWork = false;
        var isHostCallbackScheduled = false;
        var isHostTimeoutScheduled = false;
        function advanceTimers(currentTime) {
          var timer = peek(timerQueue);
          while (timer !== null) {
            if (timer.callback === null) {
              pop(timerQueue);
            } else if (timer.startTime <= currentTime) {
              pop(timerQueue);
              timer.sortIndex = timer.expirationTime;
              push(taskQueue, timer);
            } else {
              return;
            }
            timer = peek(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled) {
            if (peek(taskQueue) !== null) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            } else {
              var firstTimer = peek(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              }
            }
          }
        }
        function flushWork(hasTimeRemaining, initialTime2) {
          isHostCallbackScheduled = false;
          if (isHostTimeoutScheduled) {
            isHostTimeoutScheduled = false;
            cancelHostTimeout();
          }
          isPerformingWork = true;
          var previousPriorityLevel = currentPriorityLevel;
          try {
            if (enableProfiling) {
              try {
                return workLoop(hasTimeRemaining, initialTime2);
              } catch (error) {
                if (currentTask !== null) {
                  var currentTime = exports.unstable_now();
                  markTaskErrored(currentTask, currentTime);
                  currentTask.isQueued = false;
                }
                throw error;
              }
            } else {
              return workLoop(hasTimeRemaining, initialTime2);
            }
          } finally {
            currentTask = null;
            currentPriorityLevel = previousPriorityLevel;
            isPerformingWork = false;
          }
        }
        function workLoop(hasTimeRemaining, initialTime2) {
          var currentTime = initialTime2;
          advanceTimers(currentTime);
          currentTask = peek(taskQueue);
          while (currentTask !== null && !enableSchedulerDebugging) {
            if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || exports.unstable_shouldYield())) {
              break;
            }
            var callback = currentTask.callback;
            if (typeof callback === "function") {
              currentTask.callback = null;
              currentPriorityLevel = currentTask.priorityLevel;
              var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
              var continuationCallback = callback(didUserCallbackTimeout);
              currentTime = exports.unstable_now();
              if (typeof continuationCallback === "function") {
                currentTask.callback = continuationCallback;
              } else {
                if (currentTask === peek(taskQueue)) {
                  pop(taskQueue);
                }
              }
              advanceTimers(currentTime);
            } else {
              pop(taskQueue);
            }
            currentTask = peek(taskQueue);
          }
          if (currentTask !== null) {
            return true;
          } else {
            var firstTimer = peek(timerQueue);
            if (firstTimer !== null) {
              requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
            return false;
          }
        }
        function unstable_runWithPriority(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority2:
            case LowPriority:
            case IdlePriority:
              break;
            default:
              priorityLevel = NormalPriority2;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_next(eventHandler) {
          var priorityLevel;
          switch (currentPriorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority2:
              priorityLevel = NormalPriority2;
              break;
            default:
              priorityLevel = currentPriorityLevel;
              break;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_wrapCallback(callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        }
        function unstable_scheduleCallback(priorityLevel, callback, options) {
          var currentTime = exports.unstable_now();
          var startTime;
          if (typeof options === "object" && options !== null) {
            var delay = options.delay;
            if (typeof delay === "number" && delay > 0) {
              startTime = currentTime + delay;
            } else {
              startTime = currentTime;
            }
          } else {
            startTime = currentTime;
          }
          var timeout;
          switch (priorityLevel) {
            case ImmediatePriority:
              timeout = IMMEDIATE_PRIORITY_TIMEOUT;
              break;
            case UserBlockingPriority:
              timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
              break;
            case IdlePriority:
              timeout = IDLE_PRIORITY_TIMEOUT;
              break;
            case LowPriority:
              timeout = LOW_PRIORITY_TIMEOUT;
              break;
            case NormalPriority2:
            default:
              timeout = NORMAL_PRIORITY_TIMEOUT;
              break;
          }
          var expirationTime = startTime + timeout;
          var newTask = {
            id: taskIdCounter++,
            callback,
            priorityLevel,
            startTime,
            expirationTime,
            sortIndex: -1
          };
          if (startTime > currentTime) {
            newTask.sortIndex = startTime;
            push(timerQueue, newTask);
            if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
              if (isHostTimeoutScheduled) {
                cancelHostTimeout();
              } else {
                isHostTimeoutScheduled = true;
              }
              requestHostTimeout(handleTimeout, startTime - currentTime);
            }
          } else {
            newTask.sortIndex = expirationTime;
            push(taskQueue, newTask);
            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          return newTask;
        }
        function unstable_pauseExecution() {
        }
        function unstable_continueExecution() {
          if (!isHostCallbackScheduled && !isPerformingWork) {
            isHostCallbackScheduled = true;
            requestHostCallback(flushWork);
          }
        }
        function unstable_getFirstCallbackNode() {
          return peek(taskQueue);
        }
        function unstable_cancelCallback(task) {
          task.callback = null;
        }
        function unstable_getCurrentPriorityLevel() {
          return currentPriorityLevel;
        }
        var unstable_requestPaint = requestPaint;
        var unstable_Profiling = null;
        exports.unstable_IdlePriority = IdlePriority;
        exports.unstable_ImmediatePriority = ImmediatePriority;
        exports.unstable_LowPriority = LowPriority;
        exports.unstable_NormalPriority = NormalPriority2;
        exports.unstable_Profiling = unstable_Profiling;
        exports.unstable_UserBlockingPriority = UserBlockingPriority;
        exports.unstable_cancelCallback = unstable_cancelCallback;
        exports.unstable_continueExecution = unstable_continueExecution;
        exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
        exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
        exports.unstable_next = unstable_next;
        exports.unstable_pauseExecution = unstable_pauseExecution;
        exports.unstable_requestPaint = unstable_requestPaint;
        exports.unstable_runWithPriority = unstable_runWithPriority;
        exports.unstable_scheduleCallback = unstable_scheduleCallback;
        exports.unstable_wrapCallback = unstable_wrapCallback;
      })();
    }
  }
});

// node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "node_modules/scheduler/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_scheduler_development();
    }
  }
});

// node_modules/@fluentui/react-table/lib/hooks/types.js
var React = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/hooks/useTableFeatures.js
var React57 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/hooks/useTableSelection.js
var React28 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/compose/slot.js
var slot_exports = {};
__export(slot_exports, {
  always: () => always,
  optional: () => optional,
  resolveShorthand: () => resolveShorthand
});
var React2 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/compose/constants.js
var SLOT_RENDER_FUNCTION_SYMBOL = Symbol("fui.slotRenderFunction");
var SLOT_ELEMENT_TYPE_SYMBOL = Symbol("fui.slotElementType");

// node_modules/@fluentui/react-utilities/lib/compose/slot.js
function always(value, options) {
  const { defaultProps, elementType } = options;
  const props = resolveShorthand(value);
  const propsWithMetadata = {
    ...defaultProps,
    ...props,
    [SLOT_ELEMENT_TYPE_SYMBOL]: elementType
  };
  if (props && typeof props.children === "function") {
    propsWithMetadata[SLOT_RENDER_FUNCTION_SYMBOL] = props.children;
    propsWithMetadata.children = defaultProps === null || defaultProps === void 0 ? void 0 : defaultProps.children;
  }
  return propsWithMetadata;
}
function optional(value, options) {
  if (value === null || value === void 0 && !options.renderByDefault) {
    return void 0;
  }
  return always(value, options);
}
function resolveShorthand(value) {
  if (typeof value === "string" || typeof value === "number" || Array.isArray(value) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
  React2.isValidElement(value)) {
    return {
      children: value
    };
  }
  if (value && typeof value !== "object" && true) {
    console.error(`@fluentui/react-utilities [slot.${resolveShorthand.name}]:
A slot got an invalid value "${value}" (${typeof value}).
A valid value for a slot is a slot shorthand or slot properties object.
Slot shorthands can be strings, numbers, arrays or JSX elements`);
  }
  return value;
}

// node_modules/@fluentui/react-utilities/lib/compose/getSlots.js
var React3 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/utils/omit.js
function omit(obj, exclusions) {
  const result = {};
  for (const key in obj) {
    if (exclusions.indexOf(key) === -1 && obj.hasOwnProperty(key)) {
      result[key] = obj[key];
    }
  }
  return result;
}

// node_modules/@fluentui/react-utilities/lib/compose/isSlot.js
function isSlot(element) {
  return Boolean(element === null || element === void 0 ? void 0 : element.hasOwnProperty(SLOT_ELEMENT_TYPE_SYMBOL));
}

// node_modules/@fluentui/react-utilities/lib/compose/getSlots.js
function getSlots(state) {
  const slots = {};
  const slotProps = {};
  const slotNames = Object.keys(state.components);
  for (const slotName of slotNames) {
    const [slot, props] = getSlot(state, slotName);
    slots[slotName] = slot;
    slotProps[slotName] = props;
  }
  return {
    slots,
    slotProps
  };
}
function getSlot(state, slotName) {
  var _state_components, _state_components1;
  const props = state[slotName];
  if (props === void 0) {
    return [
      null,
      void 0
    ];
  }
  const { as: asProp, children, ...rest } = props;
  const renderFunction = isSlot(props) ? props[SLOT_RENDER_FUNCTION_SYMBOL] : void 0;
  const slot = ((_state_components = state.components) === null || _state_components === void 0 ? void 0 : _state_components[slotName]) === void 0 || typeof state.components[slotName] === "string" ? asProp || ((_state_components1 = state.components) === null || _state_components1 === void 0 ? void 0 : _state_components1[slotName]) || "div" : state.components[slotName];
  if (renderFunction || typeof children === "function") {
    const render = renderFunction || children;
    return [
      React3.Fragment,
      {
        children: render(slot, rest)
      }
    ];
  }
  const shouldOmitAsProp = typeof slot === "string" && asProp;
  const slotProps = shouldOmitAsProp ? omit(props, [
    "as"
  ]) : props;
  return [
    slot,
    slotProps
  ];
}

// node_modules/@fluentui/react-utilities/lib/compose/resolveShorthand.js
var resolveShorthand2 = (value, options) => optional(value, {
  ...options,
  renderByDefault: options === null || options === void 0 ? void 0 : options.required,
  // elementType as undefined is the way to identify between a slot and a resolveShorthand call
  // in the case elementType is undefined assertSlots will fail, ensuring it'll only work with slot method.
  elementType: void 0
});

// node_modules/@fluentui/react-utilities/lib/compose/types.js
var React4 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/compose/isResolvedShorthand.js
var import_react = __toESM(require_react());
function isResolvedShorthand(shorthand) {
  return shorthand !== null && typeof shorthand === "object" && !Array.isArray(shorthand) && !(0, import_react.isValidElement)(shorthand);
}

// node_modules/@fluentui/react-utilities/lib/compose/getSlotsNext.js
var React5 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/compose/assertSlots.js
var React6 = __toESM(require_react());
function assertSlots(state) {
  if (true) {
    const typedState = state;
    for (const slotName of Object.keys(typedState.components)) {
      const slotElement = typedState[slotName];
      if (slotElement === void 0) {
        continue;
      }
      if (!isSlot(slotElement)) {
        typedState[slotName] = slot_exports.always(slotElement, {
          elementType: typedState.components[slotName]
        });
        console.warn(`@fluentui/react-utilities [${assertSlots.name}]:
"state.${slotName}" is not a slot!
Be sure to create slots properly by using "slot.always" or "slot.optional".`);
      } else {
        const { [SLOT_ELEMENT_TYPE_SYMBOL]: elementType } = slotElement;
        if (elementType !== typedState.components[slotName]) {
          slotElement[SLOT_ELEMENT_TYPE_SYMBOL] = typedState.components[slotName];
          console.warn(`@fluentui/react-utilities [${assertSlots.name}]:
"state.${slotName}" element type differs from "state.components.${slotName}",
${elementType} !== ${typedState.components[slotName]}.
Be sure to create slots properly by using "slot.always" or "slot.optional" with the correct elementType.`);
        }
      }
    }
  }
}

// node_modules/@fluentui/react-utilities/lib/compose/getIntrinsicElementProps.js
var React8 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/utils/getNativeElementProps.js
var React7 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/utils/properties.js
var toObjectMap = (...items) => {
  const result = {};
  for (const item of items) {
    const keys = Array.isArray(item) ? item : Object.keys(item);
    for (const key of keys) {
      result[key] = 1;
    }
  }
  return result;
};
var baseElementEvents = toObjectMap([
  "onAuxClick",
  "onAnimationEnd",
  "onAnimationStart",
  "onCopy",
  "onCut",
  "onPaste",
  "onCompositionEnd",
  "onCompositionStart",
  "onCompositionUpdate",
  "onFocus",
  "onFocusCapture",
  "onBlur",
  "onBlurCapture",
  "onChange",
  "onInput",
  "onSubmit",
  "onLoad",
  "onError",
  "onKeyDown",
  "onKeyDownCapture",
  "onKeyPress",
  "onKeyUp",
  "onAbort",
  "onCanPlay",
  "onCanPlayThrough",
  "onDurationChange",
  "onEmptied",
  "onEncrypted",
  "onEnded",
  "onLoadedData",
  "onLoadedMetadata",
  "onLoadStart",
  "onPause",
  "onPlay",
  "onPlaying",
  "onProgress",
  "onRateChange",
  "onSeeked",
  "onSeeking",
  "onStalled",
  "onSuspend",
  "onTimeUpdate",
  "onVolumeChange",
  "onWaiting",
  "onClick",
  "onClickCapture",
  "onContextMenu",
  "onDoubleClick",
  "onDrag",
  "onDragEnd",
  "onDragEnter",
  "onDragExit",
  "onDragLeave",
  "onDragOver",
  "onDragStart",
  "onDrop",
  "onMouseDown",
  "onMouseDownCapture",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onMouseOut",
  "onMouseOver",
  "onMouseUp",
  "onMouseUpCapture",
  "onSelect",
  "onTouchCancel",
  "onTouchEnd",
  "onTouchMove",
  "onTouchStart",
  "onScroll",
  "onWheel",
  "onPointerCancel",
  "onPointerDown",
  "onPointerEnter",
  "onPointerLeave",
  "onPointerMove",
  "onPointerOut",
  "onPointerOver",
  "onPointerUp",
  "onGotPointerCapture",
  "onLostPointerCapture"
]);
var baseElementProperties = toObjectMap([
  "accessKey",
  "children",
  "className",
  "contentEditable",
  "dir",
  "draggable",
  "hidden",
  "htmlFor",
  "id",
  "lang",
  "ref",
  "role",
  "style",
  "tabIndex",
  "title",
  "translate",
  "spellCheck",
  "name"
]);
var microdataProperties = toObjectMap([
  "itemID",
  "itemProp",
  "itemRef",
  "itemScope",
  "itemType"
]);
var htmlElementProperties = toObjectMap(baseElementProperties, baseElementEvents, microdataProperties);
var labelProperties = toObjectMap(htmlElementProperties, [
  "form"
]);
var audioProperties = toObjectMap(htmlElementProperties, [
  "height",
  "loop",
  "muted",
  "preload",
  "src",
  "width"
]);
var videoProperties = toObjectMap(audioProperties, [
  "poster"
]);
var olProperties = toObjectMap(htmlElementProperties, [
  "start"
]);
var liProperties = toObjectMap(htmlElementProperties, [
  "value"
]);
var anchorProperties = toObjectMap(htmlElementProperties, [
  "download",
  "href",
  "hrefLang",
  "media",
  "rel",
  "target",
  "type"
]);
var timeProperties = toObjectMap(htmlElementProperties, [
  "dateTime"
]);
var buttonProperties = toObjectMap(htmlElementProperties, [
  "autoFocus",
  "disabled",
  "form",
  "formAction",
  "formEncType",
  "formMethod",
  "formNoValidate",
  "formTarget",
  "type",
  "value"
]);
var inputProperties = toObjectMap(buttonProperties, [
  "accept",
  "alt",
  "autoCapitalize",
  "autoComplete",
  "checked",
  "dirname",
  "form",
  "height",
  "inputMode",
  "list",
  "max",
  "maxLength",
  "min",
  "multiple",
  "pattern",
  "placeholder",
  "readOnly",
  "required",
  "src",
  "step",
  "size",
  "type",
  "value",
  "width"
]);
var textAreaProperties = toObjectMap(buttonProperties, [
  "autoCapitalize",
  "cols",
  "dirname",
  "form",
  "maxLength",
  "placeholder",
  "readOnly",
  "required",
  "rows",
  "wrap"
]);
var selectProperties = toObjectMap(buttonProperties, [
  "form",
  "multiple",
  "required"
]);
var optionProperties = toObjectMap(htmlElementProperties, [
  "selected",
  "value"
]);
var tableProperties = toObjectMap(htmlElementProperties, [
  "cellPadding",
  "cellSpacing"
]);
var trProperties = htmlElementProperties;
var thProperties = toObjectMap(htmlElementProperties, [
  "colSpan",
  "rowSpan",
  "scope"
]);
var tdProperties = toObjectMap(htmlElementProperties, [
  "colSpan",
  "headers",
  "rowSpan",
  "scope"
]);
var colGroupProperties = toObjectMap(htmlElementProperties, [
  "span"
]);
var colProperties = toObjectMap(htmlElementProperties, [
  "span"
]);
var fieldsetProperties = toObjectMap(htmlElementProperties, [
  "disabled",
  "form"
]);
var formProperties = toObjectMap(htmlElementProperties, [
  "acceptCharset",
  "action",
  "encType",
  "encType",
  "method",
  "noValidate",
  "target"
]);
var iframeProperties = toObjectMap(htmlElementProperties, [
  "allow",
  "allowFullScreen",
  "allowPaymentRequest",
  "allowTransparency",
  "csp",
  "height",
  "importance",
  "referrerPolicy",
  "sandbox",
  "src",
  "srcDoc",
  "width"
]);
var imgProperties = toObjectMap(htmlElementProperties, [
  "alt",
  "crossOrigin",
  "height",
  "src",
  "srcSet",
  "useMap",
  "width"
]);
var dialogProperties = toObjectMap(htmlElementProperties, [
  "open",
  "onCancel",
  "onClose"
]);
function getNativeProps(props, allowedPropNames, excludedPropNames) {
  const isArray = Array.isArray(allowedPropNames);
  const result = {};
  const keys = Object.keys(props);
  for (const key of keys) {
    const isNativeProp = !isArray && allowedPropNames[key] || isArray && allowedPropNames.indexOf(key) >= 0 || key.indexOf("data-") === 0 || key.indexOf("aria-") === 0;
    if (isNativeProp && (!excludedPropNames || (excludedPropNames === null || excludedPropNames === void 0 ? void 0 : excludedPropNames.indexOf(key)) === -1)) {
      result[key] = props[key];
    }
  }
  return result;
}

// node_modules/@fluentui/react-utilities/lib/utils/getNativeElementProps.js
var nativeElementMap = {
  label: labelProperties,
  audio: audioProperties,
  video: videoProperties,
  ol: olProperties,
  li: liProperties,
  a: anchorProperties,
  button: buttonProperties,
  input: inputProperties,
  textarea: textAreaProperties,
  select: selectProperties,
  option: optionProperties,
  table: tableProperties,
  tr: trProperties,
  th: thProperties,
  td: tdProperties,
  colGroup: colGroupProperties,
  col: colProperties,
  fieldset: fieldsetProperties,
  form: formProperties,
  iframe: iframeProperties,
  img: imgProperties,
  time: timeProperties,
  dialog: dialogProperties
};
function getNativeElementProps(tagName, props, excludedPropNames) {
  const allowedPropNames = tagName && nativeElementMap[tagName] || htmlElementProperties;
  allowedPropNames.as = 1;
  return getNativeProps(props, allowedPropNames, excludedPropNames);
}
var getPartitionedNativeProps = ({ primarySlotTagName, props, excludedPropNames }) => {
  return {
    root: {
      style: props.style,
      className: props.className
    },
    // eslint-disable-next-line deprecation/deprecation
    primary: getNativeElementProps(primarySlotTagName, props, [
      ...excludedPropNames || [],
      "style",
      "className"
    ])
  };
};

// node_modules/@fluentui/react-utilities/lib/compose/getIntrinsicElementProps.js
var getIntrinsicElementProps = (tagName, props, excludedPropNames) => {
  var _props_as;
  return getNativeElementProps((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : tagName, props, excludedPropNames);
};

// node_modules/@fluentui/react-utilities/lib/ssr/canUseDOM.js
function canUseDOM() {
  return typeof window !== "undefined" && !!(window.document && // eslint-disable-next-line deprecation/deprecation
  window.document.createElement);
}

// node_modules/@fluentui/react-utilities/lib/hooks/useBrowserTimer.js
var React9 = __toESM(require_react());
function useBrowserTimer(setTimer, cancelTimer) {
  const id = React9.useRef(void 0);
  const set = React9.useCallback((fn, delay) => {
    if (id.current !== void 0) {
      cancelTimer(id.current);
    }
    id.current = setTimer(fn, delay);
    return id.current;
  }, [
    cancelTimer,
    setTimer
  ]);
  const cancel = React9.useCallback(() => {
    if (id.current !== void 0) {
      cancelTimer(id.current);
      id.current = void 0;
    }
  }, [
    cancelTimer
  ]);
  React9.useEffect(() => cancel, [
    cancel
  ]);
  return [
    set,
    cancel
  ];
}

// node_modules/@fluentui/react-utilities/lib/hooks/useControllableState.js
var React10 = __toESM(require_react());
function isFactoryDispatch(newState) {
  return typeof newState === "function";
}
var useControllableState = (options) => {
  const [internalState, setInternalState] = React10.useState(() => {
    if (options.defaultState === void 0) {
      return options.initialState;
    }
    return isInitializer(options.defaultState) ? options.defaultState() : options.defaultState;
  });
  const stateValueRef = React10.useRef(options.state);
  React10.useEffect(() => {
    stateValueRef.current = options.state;
  }, [
    options.state
  ]);
  const setControlledState = React10.useCallback((newState) => {
    if (isFactoryDispatch(newState)) {
      newState(stateValueRef.current);
    }
  }, []);
  return useIsControlled(options.state) ? [
    options.state,
    setControlledState
  ] : [
    internalState,
    setInternalState
  ];
};
function isInitializer(value) {
  return typeof value === "function";
}
var useIsControlled = (controlledValue) => {
  const [isControlled] = React10.useState(() => controlledValue !== void 0);
  if (true) {
    React10.useEffect(() => {
      if (isControlled !== (controlledValue !== void 0)) {
        const error = new Error();
        const controlWarning = isControlled ? "a controlled value to be uncontrolled" : "an uncontrolled value to be controlled";
        const undefinedWarning = isControlled ? "defined to an undefined" : "undefined to a defined";
        console.error(`@fluentui/react-utilities [${useControllableState.name}]:
A component is changing ${controlWarning}. This is likely caused by the value changing from ${undefinedWarning} value, which should not happen.
Decide between using a controlled or uncontrolled input element for the lifetime of the component.
More info: https://reactjs.org/link/controlled-components
${error.stack}`);
      }
    }, [
      isControlled,
      controlledValue
    ]);
  }
  return isControlled;
};

// node_modules/@fluentui/react-utilities/lib/hooks/useEventCallback.js
var React13 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/hooks/useIsomorphicLayoutEffect.js
var React12 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/ssr/SSRContext.js
var React11 = __toESM(require_react());
var defaultSSRContextValue = {
  current: 0
};
var SSRContext = React11.createContext(void 0);
function useSSRContext() {
  var _React_useContext;
  return (_React_useContext = React11.useContext(SSRContext)) !== null && _React_useContext !== void 0 ? _React_useContext : defaultSSRContextValue;
}
var SSRProvider = (props) => {
  const [value] = React11.useState(() => ({
    current: 0
  }));
  return React11.createElement(SSRContext.Provider, {
    value
  }, props.children);
};
function useIsSSR() {
  const isInSSRContext = useSSRContext() !== defaultSSRContextValue;
  const [isSSR, setIsSSR] = React11.useState(isInSSRContext);
  if (true) {
    if (!isInSSRContext && !canUseDOM()) {
      console.error(`@fluentui/react-components [${useIsSSR.name}]:
When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.


Check documentation at https://aka.ms/fluentui-ssr.`);
    }
  }
  if (canUseDOM() && isInSSRContext) {
    React11.useLayoutEffect(() => {
      setIsSSR(false);
    }, []);
  }
  return isSSR;
}

// node_modules/@fluentui/react-utilities/lib/hooks/useIsomorphicLayoutEffect.js
var useIsomorphicLayoutEffect = canUseDOM() ? React12.useLayoutEffect : React12.useEffect;

// node_modules/@fluentui/react-utilities/lib/hooks/useEventCallback.js
var useEventCallback = (fn) => {
  const callbackRef = React13.useRef(() => {
    throw new Error("Cannot call an event handler while rendering");
  });
  useIsomorphicLayoutEffect(() => {
    callbackRef.current = fn;
  }, [
    fn
  ]);
  return React13.useCallback((...args) => {
    const callback = callbackRef.current;
    return callback(...args);
  }, [
    callbackRef
  ]);
};

// node_modules/@fluentui/react-utilities/lib/hooks/useFirstMount.js
var React14 = __toESM(require_react());
function useFirstMount() {
  const isFirst = React14.useRef(true);
  if (isFirst.current) {
    isFirst.current = false;
    return true;
  }
  return isFirst.current;
}

// node_modules/@fluentui/react-utilities/lib/hooks/useForceUpdate.js
var import_react2 = __toESM(require_react());
function useForceUpdate() {
  return (0, import_react2.useReducer)((x2) => x2 + 1, 0)[1];
}

// node_modules/@fluentui/react-utilities/lib/hooks/useId.js
var React15 = __toESM(require_react());
var IdPrefixContext = React15.createContext(void 0);
var IdPrefixProvider = IdPrefixContext.Provider;
function useIdPrefix() {
  return React15.useContext(IdPrefixContext) || "";
}
function resetIdsForTests() {
  defaultSSRContextValue.current = 0;
}
function useId2(prefix = "fui-", providedId) {
  const contextValue = useSSRContext();
  const idPrefix = useIdPrefix();
  const _useId = React15["useId"];
  if (_useId) {
    const generatedId = _useId();
    const escapedId = React15.useMemo(() => generatedId.replace(/:/g, ""), [
      generatedId
    ]);
    return providedId || `${idPrefix}${prefix}${escapedId}`;
  }
  return React15.useMemo(() => {
    if (providedId) {
      return providedId;
    }
    return `${idPrefix}${prefix}${++contextValue.current}`;
  }, [
    idPrefix,
    prefix,
    providedId,
    contextValue
  ]);
}

// node_modules/@fluentui/react-utilities/lib/hooks/useMergedRefs.js
var React16 = __toESM(require_react());
function useMergedRefs(...refs) {
  const mergedCallback = React16.useCallback(
    (value) => {
      mergedCallback.current = value;
      for (const ref of refs) {
        if (typeof ref === "function") {
          ref(value);
        } else if (ref) {
          ref.current = value;
        }
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps -- already exhaustive
    [
      ...refs
    ]
  );
  return mergedCallback;
}

// node_modules/@fluentui/react-utilities/lib/hooks/useOnClickOutside.js
var React17 = __toESM(require_react());
var DEFAULT_CONTAINS = (parent2, child) => !!(parent2 === null || parent2 === void 0 ? void 0 : parent2.contains(child));
var useOnClickOutside = (options) => {
  const { refs, callback, element, disabled, disabledFocusOnIframe, contains = DEFAULT_CONTAINS } = options;
  const timeoutId = React17.useRef(void 0);
  useIFrameFocus({
    element,
    disabled: disabledFocusOnIframe || disabled,
    callback,
    refs,
    contains
  });
  const isMouseDownInsideRef = React17.useRef(false);
  const listener = useEventCallback((ev) => {
    if (isMouseDownInsideRef.current) {
      isMouseDownInsideRef.current = false;
      return;
    }
    const target = ev.composedPath()[0];
    const isOutside = refs.every((ref) => !contains(ref.current || null, target));
    if (isOutside && !disabled) {
      callback(ev);
    }
  });
  const handleMouseDown = useEventCallback((ev) => {
    isMouseDownInsideRef.current = refs.some((ref) => contains(ref.current || null, ev.target));
  });
  React17.useEffect(() => {
    if (disabled) {
      return;
    }
    let currentEvent = getWindowEvent(window);
    const conditionalHandler = (event) => {
      if (event === currentEvent) {
        currentEvent = void 0;
        return;
      }
      listener(event);
    };
    element === null || element === void 0 ? void 0 : element.addEventListener("click", conditionalHandler, true);
    element === null || element === void 0 ? void 0 : element.addEventListener("touchstart", conditionalHandler, true);
    element === null || element === void 0 ? void 0 : element.addEventListener("contextmenu", conditionalHandler, true);
    element === null || element === void 0 ? void 0 : element.addEventListener("mousedown", handleMouseDown, true);
    timeoutId.current = window.setTimeout(() => {
      currentEvent = void 0;
    }, 1);
    return () => {
      element === null || element === void 0 ? void 0 : element.removeEventListener("click", conditionalHandler, true);
      element === null || element === void 0 ? void 0 : element.removeEventListener("touchstart", conditionalHandler, true);
      element === null || element === void 0 ? void 0 : element.removeEventListener("contextmenu", conditionalHandler, true);
      element === null || element === void 0 ? void 0 : element.removeEventListener("mousedown", handleMouseDown, true);
      clearTimeout(timeoutId.current);
      currentEvent = void 0;
    };
  }, [
    listener,
    element,
    disabled,
    handleMouseDown
  ]);
};
var getWindowEvent = (target) => {
  if (target) {
    var _target_ownerDocument_defaultView, _target_ownerDocument;
    if (typeof target.window === "object" && target.window === target) {
      return target.event;
    }
    var _target_ownerDocument_defaultView_event;
    return (_target_ownerDocument_defaultView_event = (_target_ownerDocument = target.ownerDocument) === null || _target_ownerDocument === void 0 ? void 0 : (_target_ownerDocument_defaultView = _target_ownerDocument.defaultView) === null || _target_ownerDocument_defaultView === void 0 ? void 0 : _target_ownerDocument_defaultView.event) !== null && _target_ownerDocument_defaultView_event !== void 0 ? _target_ownerDocument_defaultView_event : void 0;
  }
  return void 0;
};
var FUI_FRAME_EVENT = "fuiframefocus";
var useIFrameFocus = (options) => {
  const { disabled, element: targetDocument, callback, contains = DEFAULT_CONTAINS, pollDuration = 1e3, refs } = options;
  const timeoutRef = React17.useRef();
  const listener = useEventCallback((e2) => {
    const isOutside = refs.every((ref) => !contains(ref.current || null, e2.target));
    if (isOutside && !disabled) {
      callback(e2);
    }
  });
  React17.useEffect(() => {
    if (disabled) {
      return;
    }
    targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener(FUI_FRAME_EVENT, listener, true);
    return () => {
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener(FUI_FRAME_EVENT, listener, true);
    };
  }, [
    targetDocument,
    disabled,
    listener
  ]);
  React17.useEffect(() => {
    var _targetDocument_defaultView;
    if (disabled) {
      return;
    }
    timeoutRef.current = targetDocument === null || targetDocument === void 0 ? void 0 : (_targetDocument_defaultView = targetDocument.defaultView) === null || _targetDocument_defaultView === void 0 ? void 0 : _targetDocument_defaultView.setInterval(() => {
      const activeElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement;
      if ((activeElement === null || activeElement === void 0 ? void 0 : activeElement.tagName) === "IFRAME" || (activeElement === null || activeElement === void 0 ? void 0 : activeElement.tagName) === "WEBVIEW") {
        const event = new CustomEvent(FUI_FRAME_EVENT, {
          bubbles: true
        });
        activeElement.dispatchEvent(event);
      }
    }, pollDuration);
    return () => {
      var _targetDocument_defaultView2;
      targetDocument === null || targetDocument === void 0 ? void 0 : (_targetDocument_defaultView2 = targetDocument.defaultView) === null || _targetDocument_defaultView2 === void 0 ? void 0 : _targetDocument_defaultView2.clearTimeout(timeoutRef.current);
    };
  }, [
    targetDocument,
    disabled,
    pollDuration
  ]);
};

// node_modules/@fluentui/react-utilities/lib/hooks/useOnScrollOutside.js
var React18 = __toESM(require_react());
var useOnScrollOutside = (options) => {
  const { refs, callback, element, disabled, contains: containsProp } = options;
  const listener = useEventCallback((ev) => {
    const contains = containsProp || ((parent2, child) => !!(parent2 === null || parent2 === void 0 ? void 0 : parent2.contains(child)));
    const target = ev.composedPath()[0];
    const isOutside = refs.every((ref) => !contains(ref.current || null, target));
    if (isOutside && !disabled) {
      callback(ev);
    }
  });
  React18.useEffect(() => {
    if (disabled) {
      return;
    }
    element === null || element === void 0 ? void 0 : element.addEventListener("wheel", listener);
    element === null || element === void 0 ? void 0 : element.addEventListener("touchmove", listener);
    return () => {
      element === null || element === void 0 ? void 0 : element.removeEventListener("wheel", listener);
      element === null || element === void 0 ? void 0 : element.removeEventListener("touchmove", listener);
    };
  }, [
    listener,
    element,
    disabled
  ]);
};

// node_modules/@fluentui/react-utilities/lib/hooks/usePrevious.js
var React19 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/hooks/useScrollbarWidth.js
var React20 = __toESM(require_react());
var cache = /* @__PURE__ */ new WeakMap();
function useScrollbarWidth(options) {
  const { targetDocument, force } = options;
  return React20.useMemo(() => {
    if (!targetDocument) {
      return 0;
    }
    if (!force && cache.has(targetDocument)) {
      return cache.get(targetDocument);
    }
    const outer = targetDocument.createElement("div");
    outer.style.visibility = "hidden";
    outer.style.overflow = "scroll";
    const inner = targetDocument.createElement("div");
    outer.appendChild(inner);
    targetDocument.body.appendChild(outer);
    const scrollbarWidth = outer.offsetWidth - inner.offsetWidth;
    outer.remove();
    cache.set(targetDocument, scrollbarWidth);
    return scrollbarWidth;
  }, [
    targetDocument,
    force
  ]);
}

// node_modules/@fluentui/react-utilities/lib/hooks/useTimeout.js
function useTimeout() {
  return useBrowserTimer(setTimeout, clearTimeout);
}

// node_modules/@fluentui/react-utilities/lib/utils/clamp.js
var clamp = (value, min2, max2) => Math.max(min2, Math.min(max2, value || 0));

// node_modules/@fluentui/react-utilities/lib/utils/getRTLSafeKey.js
var getRTLSafeKey = (key, dir) => {
  if (dir === "rtl") {
    switch (key) {
      case "ArrowLeft": {
        return "ArrowRight";
      }
      case "ArrowRight": {
        return "ArrowLeft";
      }
    }
  }
  return key;
};

// node_modules/@fluentui/react-utilities/lib/utils/mergeCallbacks.js
function mergeCallbacks(callback1, callback2) {
  return (...args) => {
    callback1 === null || callback1 === void 0 ? void 0 : callback1(...args);
    callback2 === null || callback2 === void 0 ? void 0 : callback2(...args);
  };
}

// node_modules/@fluentui/react-utilities/lib/utils/isHTMLElement.js
function isHTMLElement(element, options) {
  var _typedElement_ownerDocument;
  const typedElement = element;
  var _options_constructorName;
  return Boolean((typedElement === null || typedElement === void 0 ? void 0 : (_typedElement_ownerDocument = typedElement.ownerDocument) === null || _typedElement_ownerDocument === void 0 ? void 0 : _typedElement_ownerDocument.defaultView) && typedElement instanceof typedElement.ownerDocument.defaultView[(_options_constructorName = options === null || options === void 0 ? void 0 : options.constructorName) !== null && _options_constructorName !== void 0 ? _options_constructorName : "HTMLElement"]);
}

// node_modules/@fluentui/react-utilities/lib/utils/isInteractiveHTMLElement.js
function isInteractiveHTMLElement(element) {
  if (!isHTMLElement(element)) {
    return false;
  }
  const { tagName } = element;
  switch (tagName) {
    case "BUTTON":
    case "A":
    case "INPUT":
    case "TEXTAREA":
      return true;
  }
  return element.isContentEditable;
}

// node_modules/@fluentui/react-utilities/lib/utils/priorityQueue.js
function createPriorityQueue(compare) {
  const arr = [];
  let size2 = 0;
  const swap = (a3, b2) => {
    const tmp = arr[a3];
    arr[a3] = arr[b2];
    arr[b2] = tmp;
  };
  const heapify = (i3) => {
    let smallest = i3;
    const l3 = left(i3);
    const r2 = right(i3);
    if (l3 < size2 && compare(arr[l3], arr[smallest]) < 0) {
      smallest = l3;
    }
    if (r2 < size2 && compare(arr[r2], arr[smallest]) < 0) {
      smallest = r2;
    }
    if (smallest !== i3) {
      swap(smallest, i3);
      heapify(smallest);
    }
  };
  const dequeue = () => {
    if (size2 === 0) {
      throw new Error("Priority queue empty");
    }
    const res = arr[0];
    arr[0] = arr[--size2];
    heapify(0);
    return res;
  };
  const peek = () => {
    if (size2 === 0) {
      return null;
    }
    return arr[0];
  };
  const enqueue = (item) => {
    arr[size2++] = item;
    let i3 = size2 - 1;
    let p3 = parent(i3);
    while (i3 > 0 && compare(arr[p3], arr[i3]) > 0) {
      swap(p3, i3);
      i3 = p3;
      p3 = parent(i3);
    }
  };
  const contains = (item) => {
    const index = arr.indexOf(item);
    return index >= 0 && index < size2;
  };
  const remove = (item) => {
    const i3 = arr.indexOf(item);
    if (i3 === -1 || i3 >= size2) {
      return;
    }
    arr[i3] = arr[--size2];
    heapify(i3);
  };
  const clear = () => {
    size2 = 0;
  };
  const all = () => {
    return arr.slice(0, size2);
  };
  return {
    all,
    clear,
    contains,
    dequeue,
    enqueue,
    peek,
    remove,
    size: () => size2
  };
}
var left = (i3) => {
  return 2 * i3 + 1;
};
var right = (i3) => {
  return 2 * i3 + 2;
};
var parent = (i3) => {
  return Math.floor((i3 - 1) / 2);
};

// node_modules/@fluentui/react-utilities/lib/trigger/applyTriggerPropsToChildren.js
var React22 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/trigger/isFluentTrigger.js
var React21 = __toESM(require_react());
function isFluentTrigger(element) {
  return Boolean(element.type.isFluentTriggerComponent);
}

// node_modules/@fluentui/react-utilities/lib/trigger/applyTriggerPropsToChildren.js
function applyTriggerPropsToChildren(children, triggerChildProps) {
  if (typeof children === "function") {
    return children(triggerChildProps);
  } else if (children) {
    return cloneTriggerTree(children, triggerChildProps);
  }
  return children || null;
}
function cloneTriggerTree(child, triggerProps) {
  if (!React22.isValidElement(child) || child.type === React22.Fragment) {
    throw new Error("A trigger element must be a single element for this component. Please ensure that you're not using React Fragments.");
  }
  if (isFluentTrigger(child)) {
    const grandchild = cloneTriggerTree(child.props.children, triggerProps);
    return React22.cloneElement(child, void 0, grandchild);
  } else {
    return React22.cloneElement(child, triggerProps);
  }
}

// node_modules/@fluentui/react-utilities/lib/trigger/getTriggerChild.js
var React23 = __toESM(require_react());
function getTriggerChild(children) {
  if (!React23.isValidElement(children)) {
    return null;
  }
  return isFluentTrigger(children) ? getTriggerChild(
    // FIXME: This casting should be unnecessary as isFluentTrigger is a guard type method,
    // but for some reason it's failing on build
    children.props.children
  ) : children;
}

// node_modules/@fluentui/react-utilities/lib/trigger/types.js
var React24 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/events/mouseTouchHelpers.js
var React25 = __toESM(require_react());
function isTouchEvent(event) {
  return event.type.startsWith("touch");
}
function isMouseEvent(event) {
  return event.type.startsWith("mouse") || [
    "click",
    "contextmenu",
    "dblclick"
  ].indexOf(event.type) > -1;
}
function getEventClientCoords(event) {
  if (isMouseEvent(event)) {
    return {
      clientX: event.clientX,
      clientY: event.clientY
    };
  } else if (isTouchEvent(event)) {
    return {
      clientX: event.touches[0].clientX,
      clientY: event.touches[0].clientY
    };
  } else {
    if (true) {
      throw new Error("@fluentui/react-utilities]: Unable to get clientX. Unknown event type.");
    }
    return {
      clientX: 0,
      clientY: 0
    };
  }
}

// node_modules/@fluentui/react-utilities/lib/selection/types.js
var React26 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/selection/useSelection.js
var React27 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/utils/createSetFromIterable.js
function createSetFromIterable(iterable) {
  return iterable instanceof Set ? iterable : new Set(iterable);
}

// node_modules/@fluentui/react-utilities/lib/selection/useSelection.js
function useSelectionState(params) {
  const [selected, setSelected] = useControllableState({
    initialState: /* @__PURE__ */ new Set(),
    defaultState: React27.useMemo(() => params.defaultSelectedItems && createSetFromIterable(params.defaultSelectedItems), [
      params.defaultSelectedItems
    ]),
    state: React27.useMemo(() => params.selectedItems && createSetFromIterable(params.selectedItems), [
      params.selectedItems
    ])
  });
  const changeSelection = (event, nextSelectedItems) => {
    var _params_onSelectionChange;
    (_params_onSelectionChange = params.onSelectionChange) === null || _params_onSelectionChange === void 0 ? void 0 : _params_onSelectionChange.call(params, event, {
      selectedItems: nextSelectedItems
    });
    setSelected(nextSelectedItems);
  };
  return [
    selected,
    changeSelection
  ];
}
function useSingleSelection(params) {
  const [selected, changeSelection] = useSelectionState(params);
  const methods = {
    deselectItem: (event) => changeSelection(event, /* @__PURE__ */ new Set()),
    selectItem: (event, itemId) => changeSelection(event, /* @__PURE__ */ new Set([
      itemId
    ])),
    toggleAllItems: () => {
      if (true) {
        throw new Error("[react-utilities]: `toggleAllItems` should not be used in single selection mode");
      }
    },
    toggleItem: (event, itemId) => changeSelection(event, /* @__PURE__ */ new Set([
      itemId
    ])),
    clearItems: (event) => changeSelection(event, /* @__PURE__ */ new Set()),
    isSelected: (itemId) => {
      var _selected_has;
      return (_selected_has = selected.has(itemId)) !== null && _selected_has !== void 0 ? _selected_has : false;
    }
  };
  return [
    selected,
    methods
  ];
}
function useMultipleSelection(params) {
  const [selected, changeSelection] = useSelectionState(params);
  const methods = {
    toggleItem: (event, itemId) => {
      const nextSelectedItems = new Set(selected);
      if (selected.has(itemId)) {
        nextSelectedItems.delete(itemId);
      } else {
        nextSelectedItems.add(itemId);
      }
      changeSelection(event, nextSelectedItems);
    },
    selectItem: (event, itemId) => {
      const nextSelectedItems = new Set(selected);
      nextSelectedItems.add(itemId);
      changeSelection(event, nextSelectedItems);
    },
    deselectItem: (event, itemId) => {
      const nextSelectedItems = new Set(selected);
      nextSelectedItems.delete(itemId);
      changeSelection(event, nextSelectedItems);
    },
    clearItems: (event) => {
      changeSelection(event, /* @__PURE__ */ new Set());
    },
    isSelected: (itemId) => selected.has(itemId),
    toggleAllItems: (event, itemIds) => {
      const allItemsSelected = itemIds.every((itemId) => selected.has(itemId));
      const nextSelectedItems = new Set(selected);
      if (allItemsSelected) {
        nextSelectedItems.clear();
      } else {
        itemIds.forEach((itemId) => nextSelectedItems.add(itemId));
      }
      changeSelection(event, nextSelectedItems);
    }
  };
  return [
    selected,
    methods
  ];
}
function useSelection(params) {
  if (params.selectionMode === "multiselect") {
    return useMultipleSelection(params);
  }
  return useSingleSelection(params);
}

// node_modules/@fluentui/react-utilities/lib/virtualParent/isVirtualElement.js
function isVirtualElement(element) {
  return element && !!element._virtual;
}

// node_modules/@fluentui/react-utilities/lib/virtualParent/getParent.js
function getVirtualParent(child) {
  return isVirtualElement(child) ? child._virtual.parent || null : null;
}
function getParent(child, options = {}) {
  if (!child) {
    return null;
  }
  if (!options.skipVirtual) {
    const virtualParent = getVirtualParent(child);
    if (virtualParent) {
      return virtualParent;
    }
  }
  return (child === null || child === void 0 ? void 0 : child.parentNode) || null;
}

// node_modules/@fluentui/react-utilities/lib/virtualParent/elementContains.js
function elementContains(parent2, child) {
  if (!parent2 || !child) {
    return false;
  }
  if (parent2 === child) {
    return true;
  } else {
    const set = /* @__PURE__ */ new WeakSet();
    while (child) {
      const nextParent = getParent(child, {
        skipVirtual: set.has(child)
      });
      set.add(child);
      if (nextParent === parent2) {
        return true;
      }
      child = nextParent;
    }
  }
  return false;
}

// node_modules/@fluentui/react-utilities/lib/virtualParent/setVirtualParent.js
function setVirtualParent(child, parent2) {
  if (!child) {
    return;
  }
  const virtualChild = child;
  if (!virtualChild._virtual) {
    virtualChild._virtual = {};
  }
  virtualChild._virtual.parent = parent2;
}

// node_modules/@fluentui/react-table/lib/hooks/useTableSelection.js
var noop = () => void 0;
var defaultTableSelectionState = {
  allRowsSelected: false,
  clearRows: noop,
  deselectRow: noop,
  isRowSelected: () => false,
  selectRow: noop,
  selectedRows: /* @__PURE__ */ new Set(),
  someRowsSelected: false,
  toggleAllRows: noop,
  toggleRow: noop,
  selectionMode: "multiselect"
};
function useTableSelection(options) {
  return (tableState) => useTableSelectionState(tableState, options);
}
function useTableSelectionState(tableState, options) {
  const { items, getRowId } = tableState;
  const { selectionMode, defaultSelectedItems, selectedItems, onSelectionChange } = options;
  const [selected, selectionMethods] = useSelection({
    selectionMode,
    defaultSelectedItems,
    selectedItems,
    onSelectionChange
  });
  const selectableRowIds = React28.useMemo(() => {
    const rowIds = /* @__PURE__ */ new Set();
    for (let i3 = 0; i3 < items.length; i3++) {
      var _getRowId;
      rowIds.add((_getRowId = getRowId === null || getRowId === void 0 ? void 0 : getRowId(items[i3])) !== null && _getRowId !== void 0 ? _getRowId : i3);
    }
    return rowIds;
  }, [
    items,
    getRowId
  ]);
  const allRowsSelected = React28.useMemo(() => {
    if (selectionMode === "single") {
      const selectedRow = Array.from(selected)[0];
      return selectableRowIds.has(selectedRow);
    }
    if (selected.size < selectableRowIds.size) {
      return false;
    }
    let res = true;
    selectableRowIds.forEach((selectableRowId) => {
      if (!selected.has(selectableRowId)) {
        res = false;
      }
    });
    return res;
  }, [
    selectableRowIds,
    selected,
    selectionMode
  ]);
  const someRowsSelected = React28.useMemo(() => {
    if (selected.size <= 0) {
      return false;
    }
    let res = false;
    selectableRowIds.forEach((selectableRowId) => {
      if (selected.has(selectableRowId)) {
        res = true;
      }
    });
    return res;
  }, [
    selectableRowIds,
    selected
  ]);
  const toggleAllRows = useEventCallback((e2) => {
    selectionMethods.toggleAllItems(e2, items.map((item, i3) => {
      var _getRowId;
      return (_getRowId = getRowId === null || getRowId === void 0 ? void 0 : getRowId(item)) !== null && _getRowId !== void 0 ? _getRowId : i3;
    }));
  });
  const toggleRow = useEventCallback((e2, rowId) => selectionMethods.toggleItem(e2, rowId));
  const deselectRow = useEventCallback((e2, rowId) => selectionMethods.deselectItem(e2, rowId));
  const selectRow = useEventCallback((e2, rowId) => selectionMethods.selectItem(e2, rowId));
  const isRowSelected = (rowId) => selectionMethods.isSelected(rowId);
  const clearRows = useEventCallback((e2) => selectionMethods.clearItems(e2));
  return {
    ...tableState,
    selection: {
      selectionMode,
      someRowsSelected,
      allRowsSelected,
      selectedRows: selected,
      toggleRow,
      toggleAllRows,
      clearRows,
      deselectRow,
      selectRow,
      isRowSelected
    }
  };
}

// node_modules/@fluentui/react-table/lib/hooks/useTableSort.js
var React29 = __toESM(require_react());
var noop2 = () => void 0;
var defaultTableSortState = {
  getSortDirection: () => "ascending",
  setColumnSort: noop2,
  sort: (rows) => [
    ...rows
  ],
  sortColumn: void 0,
  sortDirection: "ascending",
  toggleColumnSort: noop2
};
function useTableSort(options) {
  return (tableState) => useTableSortState(tableState, options);
}
function useTableSortState(tableState, options) {
  const { columns } = tableState;
  const { sortState, defaultSortState, onSortChange } = options;
  const [sorted, setSorted] = useControllableState({
    initialState: {
      sortDirection: "ascending",
      sortColumn: void 0
    },
    defaultState: defaultSortState,
    state: sortState
  });
  const { sortColumn, sortDirection } = sorted;
  const toggleColumnSort = (e2, columnId) => {
    setSorted((s3) => {
      const newState = {
        ...s3,
        sortColumn: columnId
      };
      if (s3.sortColumn === columnId) {
        newState.sortDirection = s3.sortDirection === "ascending" ? "descending" : "ascending";
      } else {
        newState.sortDirection = "ascending";
      }
      onSortChange === null || onSortChange === void 0 ? void 0 : onSortChange(e2, newState);
      return newState;
    });
  };
  const setColumnSort = (e2, nextSortColumn, nextSortDirection) => {
    const newState = {
      sortColumn: nextSortColumn,
      sortDirection: nextSortDirection
    };
    onSortChange === null || onSortChange === void 0 ? void 0 : onSortChange(e2, newState);
    setSorted(newState);
  };
  const sort = (rows) => {
    return rows.slice().sort((a3, b2) => {
      const sortColumnDef = columns.find((column) => column.columnId === sortColumn);
      if (!(sortColumnDef === null || sortColumnDef === void 0 ? void 0 : sortColumnDef.compare)) {
        return 0;
      }
      const mod = sortDirection === "ascending" ? 1 : -1;
      return sortColumnDef.compare(a3.item, b2.item) * mod;
    });
  };
  const getSortDirection = (columnId) => {
    return sortColumn === columnId ? sortDirection : void 0;
  };
  return {
    ...tableState,
    sort: {
      sort,
      sortColumn,
      sortDirection,
      setColumnSort,
      toggleColumnSort,
      getSortDirection
    }
  };
}

// node_modules/@fluentui/react-table/lib/hooks/useTableColumnSizing.js
var React56 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableResizeHandle/TableResizeHandle.js
var React45 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableResizeHandle/useTableResizeHandle.js
var React30 = __toESM(require_react());
var useTableResizeHandle_unstable = (props, ref) => {
  const onClick = useEventCallback((event) => {
    var _props_onClick;
    (_props_onClick = props.onClick) === null || _props_onClick === void 0 ? void 0 : _props_onClick.call(props, event);
    event.stopPropagation();
  });
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props,
      onClick
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-jsx-runtime/lib/jsx/createJSX.js
var React33 = __toESM(require_react());

// node_modules/@fluentui/react-jsx-runtime/lib/utils/createCompatSlotComponent.js
var React31 = __toESM(require_react());
function createCompatSlotComponent(type, props) {
  return {
    ...props,
    [SLOT_ELEMENT_TYPE_SYMBOL]: type
  };
}

// node_modules/@fluentui/react-jsx-runtime/lib/utils/warnIfElementTypeIsInvalid.js
var React32 = __toESM(require_react());
var import_react_is = __toESM(require_react_is());
function warnIfElementTypeIsInvalid(type) {
  if (typeof type === "object" && !(0, import_react_is.isValidElementType)(type)) {
    console.error(`@fluentui/react-jsx-runtime:
Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: ${type}.

If this happened in a slot of Fluent UI component, you might be facing package resolution issues.
Please make sure you don't have multiple versions of "@fluentui/react-utilities" installed in your dependencies or sub-dependencies.
You can check this by searching up for matching entries in a lockfile produced by your package manager (yarn.lock, pnpm-lock.yaml or package-lock.json).`);
  }
}

// node_modules/@fluentui/react-jsx-runtime/lib/jsx/createJSX.js
function createJSX(runtime, slotRuntime) {
  return function jsx2(type, overrideProps, key, source, self) {
    if (isSlot(overrideProps)) {
      return slotRuntime(createCompatSlotComponent(type, overrideProps), null, key, source, self);
    }
    if (isSlot(type)) {
      return slotRuntime(type, overrideProps, key, source, self);
    }
    warnIfElementTypeIsInvalid(type);
    return runtime(type, overrideProps, key, source, self);
  };
}

// node_modules/@fluentui/react-jsx-runtime/lib/jsx/jsxSlot.js
var React34 = __toESM(require_react());

// node_modules/@fluentui/react-jsx-runtime/lib/utils/getMetadataFromSlotComponent.js
function getMetadataFromSlotComponent(type) {
  const { as, [SLOT_ELEMENT_TYPE_SYMBOL]: baseElementType, [SLOT_RENDER_FUNCTION_SYMBOL]: renderFunction, ...propsWithoutMetadata } = type;
  const props = propsWithoutMetadata;
  const elementType = typeof baseElementType === "string" ? as !== null && as !== void 0 ? as : baseElementType : baseElementType;
  if (typeof elementType !== "string" && as) {
    props.as = as;
  }
  return {
    elementType,
    props,
    renderFunction
  };
}

// node_modules/@fluentui/react-jsx-runtime/lib/utils/Runtime.js
var ReactRuntime = __toESM(require_jsx_runtime());
var Runtime = ReactRuntime;

// node_modules/@fluentui/react-jsx-runtime/lib/jsx/jsxSlot.js
var jsxSlot = (type, overrideProps, key) => {
  const { elementType, renderFunction, props: slotProps } = getMetadataFromSlotComponent(type);
  const props = {
    ...slotProps,
    ...overrideProps
  };
  if (renderFunction) {
    return Runtime.jsx(React34.Fragment, {
      children: renderFunction(elementType, props)
    }, key);
  }
  return Runtime.jsx(elementType, props, key);
};

// node_modules/@fluentui/react-jsx-runtime/lib/jsx/jsxsSlot.js
var React35 = __toESM(require_react());
var jsxsSlot = (type, overrideProps, key) => {
  const { elementType, renderFunction, props: slotProps } = getMetadataFromSlotComponent(type);
  const props = {
    ...slotProps,
    ...overrideProps
  };
  if (renderFunction) {
    return Runtime.jsx(React35.Fragment, {
      children: renderFunction(elementType, {
        ...props,
        children: Runtime.jsxs(React35.Fragment, {
          children: props.children
        }, void 0)
      })
    }, key);
  }
  return Runtime.jsxs(elementType, props, key);
};

// node_modules/@fluentui/react-jsx-runtime/lib/jsx-runtime.js
var import_react3 = __toESM(require_react());
var jsx = createJSX(Runtime.jsx, jsxSlot);
var jsxs = createJSX(Runtime.jsxs, jsxsSlot);

// node_modules/@fluentui/react-table/lib/components/TableResizeHandle/renderTableResizeHandle.js
var renderTableResizeHandle_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/tokens/lib/global/colors.js
var grey = {
  "2": "#050505",
  "4": "#0a0a0a",
  "6": "#0f0f0f",
  "8": "#141414",
  "10": "#1a1a1a",
  "12": "#1f1f1f",
  "14": "#242424",
  "16": "#292929",
  "18": "#2e2e2e",
  "20": "#333333",
  "22": "#383838",
  "24": "#3d3d3d",
  "26": "#424242",
  "28": "#474747",
  "30": "#4d4d4d",
  "32": "#525252",
  "34": "#575757",
  "36": "#5c5c5c",
  "38": "#616161",
  "40": "#666666",
  "42": "#6b6b6b",
  "44": "#707070",
  "46": "#757575",
  "48": "#7a7a7a",
  "50": "#808080",
  "52": "#858585",
  "54": "#8a8a8a",
  "56": "#8f8f8f",
  "58": "#949494",
  "60": "#999999",
  "62": "#9e9e9e",
  "64": "#a3a3a3",
  "66": "#a8a8a8",
  "68": "#adadad",
  "70": "#b3b3b3",
  "72": "#b8b8b8",
  "74": "#bdbdbd",
  "76": "#c2c2c2",
  "78": "#c7c7c7",
  "80": "#cccccc",
  "82": "#d1d1d1",
  "84": "#d6d6d6",
  "86": "#dbdbdb",
  "88": "#e0e0e0",
  "90": "#e6e6e6",
  "92": "#ebebeb",
  "94": "#f0f0f0",
  "96": "#f5f5f5",
  "98": "#fafafa"
};
var whiteAlpha = {
  "5": "rgba(255, 255, 255, 0.05)",
  "10": "rgba(255, 255, 255, 0.1)",
  "20": "rgba(255, 255, 255, 0.2)",
  "30": "rgba(255, 255, 255, 0.3)",
  "40": "rgba(255, 255, 255, 0.4)",
  "50": "rgba(255, 255, 255, 0.5)",
  "60": "rgba(255, 255, 255, 0.6)",
  "70": "rgba(255, 255, 255, 0.7)",
  "80": "rgba(255, 255, 255, 0.8)",
  "90": "rgba(255, 255, 255, 0.9)"
};
var blackAlpha = {
  "5": "rgba(0, 0, 0, 0.05)",
  "10": "rgba(0, 0, 0, 0.1)",
  "20": "rgba(0, 0, 0, 0.2)",
  "30": "rgba(0, 0, 0, 0.3)",
  "40": "rgba(0, 0, 0, 0.4)",
  "50": "rgba(0, 0, 0, 0.5)",
  "60": "rgba(0, 0, 0, 0.6)",
  "70": "rgba(0, 0, 0, 0.7)",
  "80": "rgba(0, 0, 0, 0.8)",
  "90": "rgba(0, 0, 0, 0.9)"
};
var grey10Alpha = {
  "5": "rgba(26, 26, 26, 0.05)",
  "10": "rgba(26, 26, 26, 0.1)",
  "20": "rgba(26, 26, 26, 0.2)",
  "30": "rgba(26, 26, 26, 0.3)",
  "40": "rgba(26, 26, 26, 0.4)",
  "50": "rgba(26, 26, 26, 0.5)",
  "60": "rgba(26, 26, 26, 0.6)",
  "70": "rgba(26, 26, 26, 0.7)",
  "80": "rgba(26, 26, 26, 0.8)",
  "90": "rgba(26, 26, 26, 0.9)"
};
var grey12Alpha = {
  "5": "rgba(31, 31, 31, 0.05)",
  "10": "rgba(31, 31, 31, 0.1)",
  "20": "rgba(31, 31, 31, 0.2)",
  "30": "rgba(31, 31, 31, 0.3)",
  "40": "rgba(31, 31, 31, 0.4)",
  "50": "rgba(31, 31, 31, 0.5)",
  "60": "rgba(31, 31, 31, 0.6)",
  "70": "rgba(31, 31, 31, 0.7)",
  "80": "rgba(31, 31, 31, 0.8)",
  "90": "rgba(31, 31, 31, 0.9)"
};
var grey14Alpha = {
  "5": "rgba(36, 36, 36, 0.05)",
  "10": "rgba(36, 36, 36, 0.1)",
  "20": "rgba(36, 36, 36, 0.2)",
  "30": "rgba(36, 36, 36, 0.3)",
  "40": "rgba(36, 36, 36, 0.4)",
  "50": "rgba(36, 36, 36, 0.5)",
  "60": "rgba(36, 36, 36, 0.6)",
  "70": "rgba(36, 36, 36, 0.7)",
  "80": "rgba(36, 36, 36, 0.8)",
  "90": "rgba(36, 36, 36, 0.9)"
};
var white = "#ffffff";
var black = "#000000";
var hcHyperlink = "#ffff00";
var hcHighlight = "#1aebff";
var hcDisabled = "#3ff23f";
var hcCanvas = "#000000";
var hcCanvasText = "#ffffff";
var hcHighlightText = "#000000";
var hcButtonText = "#000000";
var hcButtonFace = "#ffffff";
var darkRed = {
  shade50: "#130204",
  shade40: "#230308",
  shade30: "#420610",
  shade20: "#590815",
  shade10: "#690a19",
  primary: "#750b1c",
  tint10: "#861b2c",
  tint20: "#962f3f",
  tint30: "#ac4f5e",
  tint40: "#d69ca5",
  tint50: "#e9c7cd",
  tint60: "#f9f0f2"
};
var cranberry = {
  shade50: "#200205",
  shade40: "#3b0509",
  shade30: "#6e0811",
  shade20: "#960b18",
  shade10: "#b10e1c",
  primary: "#c50f1f",
  tint10: "#cc2635",
  tint20: "#d33f4c",
  tint30: "#dc626d",
  tint40: "#eeacb2",
  tint50: "#f6d1d5",
  tint60: "#fdf3f4"
};
var red = {
  shade50: "#210809",
  shade40: "#3f1011",
  shade30: "#751d1f",
  shade20: "#9f282b",
  shade10: "#bc2f32",
  primary: "#d13438",
  tint10: "#d7494c",
  tint20: "#dc5e62",
  tint30: "#e37d80",
  tint40: "#f1bbbc",
  tint50: "#f8dadb",
  tint60: "#fdf6f6"
};
var darkOrange = {
  shade50: "#230900",
  shade40: "#411200",
  shade30: "#7a2101",
  shade20: "#a62d01",
  shade10: "#c43501",
  primary: "#da3b01",
  tint10: "#de501c",
  tint20: "#e36537",
  tint30: "#e9835e",
  tint40: "#f4bfab",
  tint50: "#f9dcd1",
  tint60: "#fdf6f3"
};
var pumpkin = {
  shade50: "#200d03",
  shade40: "#3d1805",
  shade30: "#712d09",
  shade20: "#9a3d0c",
  shade10: "#b6480e",
  primary: "#ca5010",
  tint10: "#d06228",
  tint20: "#d77440",
  tint30: "#df8e64",
  tint40: "#efc4ad",
  tint50: "#f7dfd2",
  tint60: "#fdf7f4"
};
var orange = {
  shade50: "#271002",
  shade40: "#4a1e04",
  shade30: "#8a3707",
  shade20: "#bc4b09",
  shade10: "#de590b",
  primary: "#f7630c",
  tint10: "#f87528",
  tint20: "#f98845",
  tint30: "#faa06b",
  tint40: "#fdcfb4",
  tint50: "#fee5d7",
  tint60: "#fff9f5"
};
var peach = {
  shade50: "#291600",
  shade40: "#4d2a00",
  shade30: "#8f4e00",
  shade20: "#c26a00",
  shade10: "#e67e00",
  primary: "#ff8c00",
  tint10: "#ff9a1f",
  tint20: "#ffa83d",
  tint30: "#ffba66",
  tint40: "#ffddb3",
  tint50: "#ffedd6",
  tint60: "#fffaf5"
};
var marigold = {
  shade50: "#251a00",
  shade40: "#463100",
  shade30: "#835b00",
  shade20: "#b27c00",
  shade10: "#d39300",
  primary: "#eaa300",
  tint10: "#edad1c",
  tint20: "#efb839",
  tint30: "#f2c661",
  tint40: "#f9e2ae",
  tint50: "#fcefd3",
  tint60: "#fefbf4"
};
var yellow = {
  primary: "#fde300",
  shade10: "#e4cc00",
  shade20: "#c0ad00",
  shade30: "#817400",
  shade40: "#4c4400",
  shade50: "#282400",
  tint10: "#fde61e",
  tint20: "#fdea3d",
  tint30: "#feee66",
  tint40: "#fef7b2",
  tint50: "#fffad6",
  tint60: "#fffef5"
};
var gold = {
  shade50: "#1f1900",
  shade40: "#3a2f00",
  shade30: "#6c5700",
  shade20: "#937700",
  shade10: "#ae8c00",
  primary: "#c19c00",
  tint10: "#c8a718",
  tint20: "#d0b232",
  tint30: "#dac157",
  tint40: "#ecdfa5",
  tint50: "#f5eece",
  tint60: "#fdfbf2"
};
var brass = {
  shade50: "#181202",
  shade40: "#2e2103",
  shade30: "#553e06",
  shade20: "#745408",
  shade10: "#89640a",
  primary: "#986f0b",
  tint10: "#a47d1e",
  tint20: "#b18c34",
  tint30: "#c1a256",
  tint40: "#e0cea2",
  tint50: "#efe4cb",
  tint60: "#fbf8f2"
};
var brown = {
  shade50: "#170e07",
  shade40: "#2b1a0e",
  shade30: "#50301a",
  shade20: "#6c4123",
  shade10: "#804d29",
  primary: "#8e562e",
  tint10: "#9c663f",
  tint20: "#a97652",
  tint30: "#bb8f6f",
  tint40: "#ddc3b0",
  tint50: "#edded3",
  tint60: "#faf7f4"
};
var forest = {
  shade50: "#0c1501",
  shade40: "#162702",
  shade30: "#294903",
  shade20: "#376304",
  shade10: "#427505",
  primary: "#498205",
  tint10: "#599116",
  tint20: "#6ba02b",
  tint30: "#85b44c",
  tint40: "#bdd99b",
  tint50: "#dbebc7",
  tint60: "#f6faf0"
};
var seafoam = {
  shade50: "#002111",
  shade40: "#003d20",
  shade30: "#00723b",
  shade20: "#009b51",
  shade10: "#00b85f",
  primary: "#00cc6a",
  tint10: "#19d279",
  tint20: "#34d889",
  tint30: "#5ae0a0",
  tint40: "#a8f0cd",
  tint50: "#cff7e4",
  tint60: "#f3fdf8"
};
var lightGreen = {
  shade50: "#031a02",
  shade40: "#063004",
  shade30: "#0b5a08",
  shade20: "#0e7a0b",
  shade10: "#11910d",
  primary: "#13a10e",
  tint10: "#27ac22",
  tint20: "#3db838",
  tint30: "#5ec75a",
  tint40: "#a7e3a5",
  tint50: "#cef0cd",
  tint60: "#f2fbf2"
};
var green = {
  shade50: "#031403",
  shade40: "#052505",
  shade30: "#094509",
  shade20: "#0c5e0c",
  shade10: "#0e700e",
  primary: "#107c10",
  tint10: "#218c21",
  tint20: "#359b35",
  tint30: "#54b054",
  tint40: "#9fd89f",
  tint50: "#c9eac9",
  tint60: "#f1faf1"
};
var darkGreen = {
  shade50: "#021102",
  shade40: "#032003",
  shade30: "#063b06",
  shade20: "#085108",
  shade10: "#0a5f0a",
  primary: "#0b6a0b",
  tint10: "#1a7c1a",
  tint20: "#2d8e2d",
  tint30: "#4da64d",
  tint40: "#9ad29a",
  tint50: "#c6e7c6",
  tint60: "#f0f9f0"
};
var lightTeal = {
  shade50: "#001d1f",
  shade40: "#00373a",
  shade30: "#00666d",
  shade20: "#008b94",
  shade10: "#00a5af",
  primary: "#00b7c3",
  tint10: "#18bfca",
  tint20: "#32c8d1",
  tint30: "#58d3db",
  tint40: "#a6e9ed",
  tint50: "#cef3f5",
  tint60: "#f2fcfd"
};
var teal = {
  shade50: "#001516",
  shade40: "#012728",
  shade30: "#02494c",
  shade20: "#026467",
  shade10: "#037679",
  primary: "#038387",
  tint10: "#159195",
  tint20: "#2aa0a4",
  tint30: "#4cb4b7",
  tint40: "#9bd9db",
  tint50: "#c7ebec",
  tint60: "#f0fafa"
};
var steel = {
  shade50: "#000f12",
  shade40: "#001b22",
  shade30: "#00333f",
  shade20: "#004555",
  shade10: "#005265",
  primary: "#005b70",
  tint10: "#0f6c81",
  tint20: "#237d92",
  tint30: "#4496a9",
  tint40: "#94c8d4",
  tint50: "#c3e1e8",
  tint60: "#eff7f9"
};
var blue = {
  shade50: "#001322",
  shade40: "#002440",
  shade30: "#004377",
  shade20: "#005ba1",
  shade10: "#006cbf",
  primary: "#0078d4",
  tint10: "#1a86d9",
  tint20: "#3595de",
  tint30: "#5caae5",
  tint40: "#a9d3f2",
  tint50: "#d0e7f8",
  tint60: "#f3f9fd"
};
var royalBlue = {
  shade50: "#000c16",
  shade40: "#00172a",
  shade30: "#002c4e",
  shade20: "#003b6a",
  shade10: "#00467e",
  primary: "#004e8c",
  tint10: "#125e9a",
  tint20: "#286fa8",
  tint30: "#4a89ba",
  tint40: "#9abfdc",
  tint50: "#c7dced",
  tint60: "#f0f6fa"
};
var cornflower = {
  shade50: "#0d1126",
  shade40: "#182047",
  shade30: "#2c3c85",
  shade20: "#3c51b4",
  shade10: "#4760d5",
  primary: "#4f6bed",
  tint10: "#637cef",
  tint20: "#778df1",
  tint30: "#93a4f4",
  tint40: "#c8d1fa",
  tint50: "#e1e6fc",
  tint60: "#f7f9fe"
};
var navy = {
  shade50: "#00061d",
  shade40: "#000c36",
  shade30: "#001665",
  shade20: "#001e89",
  shade10: "#0023a2",
  primary: "#0027b4",
  tint10: "#173bbd",
  tint20: "#3050c6",
  tint30: "#546fd2",
  tint40: "#a3b2e8",
  tint50: "#ccd5f3",
  tint60: "#f2f4fc"
};
var lavender = {
  shade50: "#120f25",
  shade40: "#221d46",
  shade30: "#3f3682",
  shade20: "#5649b0",
  shade10: "#6656d1",
  primary: "#7160e8",
  tint10: "#8172eb",
  tint20: "#9184ee",
  tint30: "#a79cf1",
  tint40: "#d2ccf8",
  tint50: "#e7e4fb",
  tint60: "#f9f8fe"
};
var purple = {
  shade50: "#0f0717",
  shade40: "#1c0e2b",
  shade30: "#341a51",
  shade20: "#46236e",
  shade10: "#532982",
  primary: "#5c2e91",
  tint10: "#6b3f9e",
  tint20: "#7c52ab",
  tint30: "#9470bd",
  tint40: "#c6b1de",
  tint50: "#e0d3ed",
  tint60: "#f7f4fb"
};
var grape = {
  shade50: "#160418",
  shade40: "#29072e",
  shade30: "#4c0d55",
  shade20: "#671174",
  shade10: "#7a1589",
  primary: "#881798",
  tint10: "#952aa4",
  tint20: "#a33fb1",
  tint30: "#b55fc1",
  tint40: "#d9a7e0",
  tint50: "#eaceef",
  tint60: "#faf2fb"
};
var berry = {
  shade50: "#1f091d",
  shade40: "#3a1136",
  shade30: "#6d2064",
  shade20: "#932b88",
  shade10: "#af33a1",
  primary: "#c239b3",
  tint10: "#c94cbc",
  tint20: "#d161c4",
  tint30: "#da7ed0",
  tint40: "#edbbe7",
  tint50: "#f5daf2",
  tint60: "#fdf5fc"
};
var lilac = {
  shade50: "#1c0b1f",
  shade40: "#35153a",
  shade30: "#63276d",
  shade20: "#863593",
  shade10: "#9f3faf",
  primary: "#b146c2",
  tint10: "#ba58c9",
  tint20: "#c36bd1",
  tint30: "#cf87da",
  tint40: "#e6bfed",
  tint50: "#f2dcf5",
  tint60: "#fcf6fd"
};
var pink = {
  shade50: "#24091b",
  shade40: "#441232",
  shade30: "#80215d",
  shade20: "#ad2d7e",
  shade10: "#cd3595",
  primary: "#e43ba6",
  tint10: "#e750b0",
  tint20: "#ea66ba",
  tint30: "#ef85c8",
  tint40: "#f7c0e3",
  tint50: "#fbddf0",
  tint60: "#fef6fb"
};
var magenta = {
  shade50: "#1f0013",
  shade40: "#390024",
  shade30: "#6b0043",
  shade20: "#91005a",
  shade10: "#ac006b",
  primary: "#bf0077",
  tint10: "#c71885",
  tint20: "#ce3293",
  tint30: "#d957a8",
  tint40: "#eca5d1",
  tint50: "#f5cee6",
  tint60: "#fcf2f9"
};
var plum = {
  shade50: "#13000c",
  shade40: "#240017",
  shade30: "#43002b",
  shade20: "#5a003b",
  shade10: "#6b0045",
  primary: "#77004d",
  tint10: "#87105d",
  tint20: "#98246f",
  tint30: "#ad4589",
  tint40: "#d696c0",
  tint50: "#e9c4dc",
  tint60: "#faf0f6"
};
var beige = {
  shade50: "#141313",
  shade40: "#252323",
  shade30: "#444241",
  shade20: "#5d5958",
  shade10: "#6e6968",
  primary: "#7a7574",
  tint10: "#8a8584",
  tint20: "#9a9594",
  tint30: "#afabaa",
  tint40: "#d7d4d4",
  tint50: "#eae8e8",
  tint60: "#faf9f9"
};
var mink = {
  shade50: "#0f0e0e",
  shade40: "#1c1b1a",
  shade30: "#343231",
  shade20: "#474443",
  shade10: "#54514f",
  primary: "#5d5a58",
  tint10: "#706d6b",
  tint20: "#84817e",
  tint30: "#9e9b99",
  tint40: "#cecccb",
  tint50: "#e5e4e3",
  tint60: "#f8f8f8"
};
var platinum = {
  shade50: "#111314",
  shade40: "#1f2426",
  shade30: "#3b4447",
  shade20: "#505c60",
  shade10: "#5f6d71",
  primary: "#69797e",
  tint10: "#79898d",
  tint20: "#89989d",
  tint30: "#a0adb2",
  tint40: "#cdd6d8",
  tint50: "#e4e9ea",
  tint60: "#f8f9fa"
};
var anchor = {
  shade50: "#090a0b",
  shade40: "#111315",
  shade30: "#202427",
  shade20: "#2b3135",
  shade10: "#333a3f",
  primary: "#394146",
  tint10: "#4d565c",
  tint20: "#626c72",
  tint30: "#808a90",
  tint40: "#bcc3c7",
  tint50: "#dbdfe1",
  tint60: "#f6f7f8"
};

// node_modules/@fluentui/tokens/lib/global/colorPalette.js
var statusSharedColors = {
  red,
  green,
  darkOrange,
  yellow,
  berry,
  lightGreen,
  marigold
};
var personaSharedColors = {
  darkRed,
  cranberry,
  pumpkin,
  peach,
  gold,
  brass,
  brown,
  forest,
  seafoam,
  darkGreen,
  lightTeal,
  teal,
  steel,
  blue,
  royalBlue,
  cornflower,
  navy,
  lavender,
  purple,
  grape,
  lilac,
  pink,
  magenta,
  plum,
  beige,
  mink,
  platinum,
  anchor
};
var mappedStatusColors = {
  cranberry,
  green,
  orange
};

// node_modules/@fluentui/tokens/lib/sharedColorNames.js
var statusSharedColorNames = [
  "red",
  "green",
  "darkOrange",
  "yellow",
  "berry",
  "lightGreen",
  "marigold"
];
var personaSharedColorNames = [
  "darkRed",
  "cranberry",
  "pumpkin",
  "peach",
  "gold",
  "brass",
  "brown",
  "forest",
  "seafoam",
  "darkGreen",
  "lightTeal",
  "teal",
  "steel",
  "blue",
  "royalBlue",
  "cornflower",
  "navy",
  "lavender",
  "purple",
  "grape",
  "lilac",
  "pink",
  "magenta",
  "plum",
  "beige",
  "mink",
  "platinum",
  "anchor"
];

// node_modules/@fluentui/tokens/lib/statusColorMapping.js
var statusColorMapping = {
  success: "green",
  warning: "orange",
  danger: "cranberry"
};

// node_modules/@fluentui/tokens/lib/alias/lightColorPalette.js
var statusColorPaletteTokens = statusSharedColorNames.reduce((acc, sharedColor) => {
  const color = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
  const sharedColorTokens = {
    [`colorPalette${color}Background1`]: statusSharedColors[sharedColor].tint60,
    [`colorPalette${color}Background2`]: statusSharedColors[sharedColor].tint40,
    [`colorPalette${color}Background3`]: statusSharedColors[sharedColor].primary,
    [`colorPalette${color}Foreground1`]: statusSharedColors[sharedColor].shade10,
    [`colorPalette${color}Foreground2`]: statusSharedColors[sharedColor].shade30,
    [`colorPalette${color}Foreground3`]: statusSharedColors[sharedColor].primary,
    [`colorPalette${color}BorderActive`]: statusSharedColors[sharedColor].primary,
    [`colorPalette${color}Border1`]: statusSharedColors[sharedColor].tint40,
    [`colorPalette${color}Border2`]: statusSharedColors[sharedColor].primary
  };
  return Object.assign(acc, sharedColorTokens);
}, {});
statusColorPaletteTokens.colorPaletteYellowForeground1 = statusSharedColors.yellow.shade30;
statusColorPaletteTokens.colorPaletteRedForegroundInverted = statusSharedColors.red.tint20;
statusColorPaletteTokens.colorPaletteGreenForegroundInverted = statusSharedColors.green.tint20;
statusColorPaletteTokens.colorPaletteYellowForegroundInverted = statusSharedColors.yellow.tint40;
var personaColorPaletteTokens = personaSharedColorNames.reduce((acc, sharedColor) => {
  const color = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
  const sharedColorTokens = {
    [`colorPalette${color}Background2`]: personaSharedColors[sharedColor].tint40,
    [`colorPalette${color}Foreground2`]: personaSharedColors[sharedColor].shade30,
    [`colorPalette${color}BorderActive`]: personaSharedColors[sharedColor].primary
  };
  return Object.assign(acc, sharedColorTokens);
}, {});
var colorPaletteTokens = {
  ...statusColorPaletteTokens,
  ...personaColorPaletteTokens
};
var colorStatusTokens = Object.entries(statusColorMapping).reduce((acc, [statusColor, sharedColor]) => {
  const color = statusColor.slice(0, 1).toUpperCase() + statusColor.slice(1);
  const statusColorTokens = {
    [`colorStatus${color}Background1`]: mappedStatusColors[sharedColor].tint60,
    [`colorStatus${color}Background2`]: mappedStatusColors[sharedColor].tint40,
    [`colorStatus${color}Background3`]: mappedStatusColors[sharedColor].primary,
    [`colorStatus${color}Foreground1`]: mappedStatusColors[sharedColor].shade10,
    [`colorStatus${color}Foreground2`]: mappedStatusColors[sharedColor].shade30,
    [`colorStatus${color}Foreground3`]: mappedStatusColors[sharedColor].primary,
    [`colorStatus${color}ForegroundInverted`]: mappedStatusColors[sharedColor].tint30,
    [`colorStatus${color}BorderActive`]: mappedStatusColors[sharedColor].primary,
    [`colorStatus${color}Border1`]: mappedStatusColors[sharedColor].tint40,
    [`colorStatus${color}Border2`]: mappedStatusColors[sharedColor].primary
  };
  return Object.assign(acc, statusColorTokens);
}, {});
colorStatusTokens.colorStatusWarningForeground1 = mappedStatusColors[statusColorMapping.warning].shade20;
colorStatusTokens.colorStatusWarningForeground3 = mappedStatusColors[statusColorMapping.warning].shade20;
colorStatusTokens.colorStatusWarningBorder2 = mappedStatusColors[statusColorMapping.warning].shade20;

// node_modules/@fluentui/tokens/lib/alias/lightColor.js
var generateColorTokens = (brand) => ({
  colorNeutralForeground1: grey[14],
  colorNeutralForeground1Hover: grey[14],
  colorNeutralForeground1Pressed: grey[14],
  colorNeutralForeground1Selected: grey[14],
  colorNeutralForeground2: grey[26],
  colorNeutralForeground2Hover: grey[14],
  colorNeutralForeground2Pressed: grey[14],
  colorNeutralForeground2Selected: grey[14],
  colorNeutralForeground2BrandHover: brand[80],
  colorNeutralForeground2BrandPressed: brand[70],
  colorNeutralForeground2BrandSelected: brand[80],
  colorNeutralForeground3: grey[38],
  colorNeutralForeground3Hover: grey[26],
  colorNeutralForeground3Pressed: grey[26],
  colorNeutralForeground3Selected: grey[26],
  colorNeutralForeground3BrandHover: brand[80],
  colorNeutralForeground3BrandPressed: brand[70],
  colorNeutralForeground3BrandSelected: brand[80],
  colorNeutralForeground4: grey[44],
  colorNeutralForegroundDisabled: grey[74],
  colorNeutralForegroundInvertedDisabled: whiteAlpha[40],
  colorBrandForegroundLink: brand[70],
  colorBrandForegroundLinkHover: brand[60],
  colorBrandForegroundLinkPressed: brand[40],
  colorBrandForegroundLinkSelected: brand[70],
  colorNeutralForeground2Link: grey[26],
  colorNeutralForeground2LinkHover: grey[14],
  colorNeutralForeground2LinkPressed: grey[14],
  colorNeutralForeground2LinkSelected: grey[14],
  colorCompoundBrandForeground1: brand[80],
  colorCompoundBrandForeground1Hover: brand[70],
  colorCompoundBrandForeground1Pressed: brand[60],
  colorBrandForeground1: brand[80],
  colorBrandForeground2: brand[70],
  colorBrandForeground2Hover: brand[60],
  colorBrandForeground2Pressed: brand[30],
  colorNeutralForeground1Static: grey[14],
  colorNeutralForegroundStaticInverted: white,
  colorNeutralForegroundInverted: white,
  colorNeutralForegroundInvertedHover: white,
  colorNeutralForegroundInvertedPressed: white,
  colorNeutralForegroundInvertedSelected: white,
  colorNeutralForegroundInverted2: white,
  colorNeutralForegroundOnBrand: white,
  colorNeutralForegroundInvertedLink: white,
  colorNeutralForegroundInvertedLinkHover: white,
  colorNeutralForegroundInvertedLinkPressed: white,
  colorNeutralForegroundInvertedLinkSelected: white,
  colorBrandForegroundInverted: brand[100],
  colorBrandForegroundInvertedHover: brand[110],
  colorBrandForegroundInvertedPressed: brand[100],
  colorBrandForegroundOnLight: brand[80],
  colorBrandForegroundOnLightHover: brand[70],
  colorBrandForegroundOnLightPressed: brand[50],
  colorBrandForegroundOnLightSelected: brand[60],
  colorNeutralBackground1: white,
  colorNeutralBackground1Hover: grey[96],
  colorNeutralBackground1Pressed: grey[88],
  colorNeutralBackground1Selected: grey[92],
  colorNeutralBackground2: grey[98],
  colorNeutralBackground2Hover: grey[94],
  colorNeutralBackground2Pressed: grey[86],
  colorNeutralBackground2Selected: grey[90],
  colorNeutralBackground3: grey[96],
  colorNeutralBackground3Hover: grey[92],
  colorNeutralBackground3Pressed: grey[84],
  colorNeutralBackground3Selected: grey[88],
  colorNeutralBackground4: grey[94],
  colorNeutralBackground4Hover: grey[98],
  colorNeutralBackground4Pressed: grey[96],
  colorNeutralBackground4Selected: white,
  colorNeutralBackground5: grey[92],
  colorNeutralBackground5Hover: grey[96],
  colorNeutralBackground5Pressed: grey[94],
  colorNeutralBackground5Selected: grey[98],
  colorNeutralBackground6: grey[90],
  colorNeutralBackgroundInverted: grey[16],
  colorNeutralBackgroundStatic: grey[20],
  colorNeutralBackgroundAlpha: whiteAlpha[50],
  colorNeutralBackgroundAlpha2: whiteAlpha[80],
  colorSubtleBackground: "transparent",
  colorSubtleBackgroundHover: grey[96],
  colorSubtleBackgroundPressed: grey[88],
  colorSubtleBackgroundSelected: grey[92],
  colorSubtleBackgroundLightAlphaHover: whiteAlpha[70],
  colorSubtleBackgroundLightAlphaPressed: whiteAlpha[50],
  colorSubtleBackgroundLightAlphaSelected: "transparent",
  colorSubtleBackgroundInverted: "transparent",
  colorSubtleBackgroundInvertedHover: blackAlpha[10],
  colorSubtleBackgroundInvertedPressed: blackAlpha[30],
  colorSubtleBackgroundInvertedSelected: blackAlpha[20],
  colorTransparentBackground: "transparent",
  colorTransparentBackgroundHover: "transparent",
  colorTransparentBackgroundPressed: "transparent",
  colorTransparentBackgroundSelected: "transparent",
  colorNeutralBackgroundDisabled: grey[94],
  colorNeutralBackgroundInvertedDisabled: whiteAlpha[10],
  colorNeutralStencil1: grey[90],
  colorNeutralStencil2: grey[98],
  colorNeutralStencil1Alpha: blackAlpha[10],
  colorNeutralStencil2Alpha: blackAlpha[5],
  colorBackgroundOverlay: blackAlpha[40],
  colorScrollbarOverlay: blackAlpha[50],
  colorBrandBackground: brand[80],
  colorBrandBackgroundHover: brand[70],
  colorBrandBackgroundPressed: brand[40],
  colorBrandBackgroundSelected: brand[60],
  colorCompoundBrandBackground: brand[80],
  colorCompoundBrandBackgroundHover: brand[70],
  colorCompoundBrandBackgroundPressed: brand[60],
  colorBrandBackgroundStatic: brand[80],
  colorBrandBackground2: brand[160],
  colorBrandBackground2Hover: brand[150],
  colorBrandBackground2Pressed: brand[130],
  colorBrandBackgroundInverted: white,
  colorBrandBackgroundInvertedHover: brand[160],
  colorBrandBackgroundInvertedPressed: brand[140],
  colorBrandBackgroundInvertedSelected: brand[150],
  colorNeutralStrokeAccessible: grey[38],
  colorNeutralStrokeAccessibleHover: grey[34],
  colorNeutralStrokeAccessiblePressed: grey[30],
  colorNeutralStrokeAccessibleSelected: brand[80],
  colorNeutralStroke1: grey[82],
  colorNeutralStroke1Hover: grey[78],
  colorNeutralStroke1Pressed: grey[70],
  colorNeutralStroke1Selected: grey[74],
  colorNeutralStroke2: grey[88],
  colorNeutralStroke3: grey[94],
  colorNeutralStrokeSubtle: grey[88],
  colorNeutralStrokeOnBrand: white,
  colorNeutralStrokeOnBrand2: white,
  colorNeutralStrokeOnBrand2Hover: white,
  colorNeutralStrokeOnBrand2Pressed: white,
  colorNeutralStrokeOnBrand2Selected: white,
  colorBrandStroke1: brand[80],
  colorBrandStroke2: brand[140],
  colorBrandStroke2Hover: brand[120],
  colorBrandStroke2Pressed: brand[80],
  colorBrandStroke2Contrast: brand[140],
  colorCompoundBrandStroke: brand[80],
  colorCompoundBrandStrokeHover: brand[70],
  colorCompoundBrandStrokePressed: brand[60],
  colorNeutralStrokeDisabled: grey[88],
  colorNeutralStrokeInvertedDisabled: whiteAlpha[40],
  colorTransparentStroke: "transparent",
  colorTransparentStrokeInteractive: "transparent",
  colorTransparentStrokeDisabled: "transparent",
  colorNeutralStrokeAlpha: blackAlpha[5],
  colorNeutralStrokeAlpha2: whiteAlpha[20],
  colorStrokeFocus1: white,
  colorStrokeFocus2: black,
  colorNeutralShadowAmbient: "rgba(0,0,0,0.12)",
  colorNeutralShadowKey: "rgba(0,0,0,0.14)",
  colorNeutralShadowAmbientLighter: "rgba(0,0,0,0.06)",
  colorNeutralShadowKeyLighter: "rgba(0,0,0,0.07)",
  colorNeutralShadowAmbientDarker: "rgba(0,0,0,0.20)",
  colorNeutralShadowKeyDarker: "rgba(0,0,0,0.24)",
  colorBrandShadowAmbient: "rgba(0,0,0,0.30)",
  colorBrandShadowKey: "rgba(0,0,0,0.25)"
});

// node_modules/@fluentui/tokens/lib/global/borderRadius.js
var borderRadius = {
  borderRadiusNone: "0",
  borderRadiusSmall: "2px",
  borderRadiusMedium: "4px",
  borderRadiusLarge: "6px",
  borderRadiusXLarge: "8px",
  borderRadiusCircular: "10000px"
};

// node_modules/@fluentui/tokens/lib/global/curves.js
var curves = {
  curveAccelerateMax: "cubic-bezier(0.9,0.1,1,0.2)",
  curveAccelerateMid: "cubic-bezier(1,0,1,1)",
  curveAccelerateMin: "cubic-bezier(0.8,0,0.78,1)",
  curveDecelerateMax: "cubic-bezier(0.1,0.9,0.2,1)",
  curveDecelerateMid: "cubic-bezier(0,0,0,1)",
  curveDecelerateMin: "cubic-bezier(0.33,0,0.1,1)",
  curveEasyEaseMax: "cubic-bezier(0.8,0,0.2,1)",
  curveEasyEase: "cubic-bezier(0.33,0,0.67,1)",
  curveLinear: "cubic-bezier(0,0,1,1)"
};

// node_modules/@fluentui/tokens/lib/global/durations.js
var durations = {
  durationUltraFast: "50ms",
  durationFaster: "100ms",
  durationFast: "150ms",
  durationNormal: "200ms",
  durationGentle: "250ms",
  durationSlow: "300ms",
  durationSlower: "400ms",
  durationUltraSlow: "500ms"
};

// node_modules/@fluentui/tokens/lib/global/fonts.js
var fontSizes = {
  fontSizeBase100: "10px",
  fontSizeBase200: "12px",
  fontSizeBase300: "14px",
  fontSizeBase400: "16px",
  fontSizeBase500: "20px",
  fontSizeBase600: "24px",
  fontSizeHero700: "28px",
  fontSizeHero800: "32px",
  fontSizeHero900: "40px",
  fontSizeHero1000: "68px"
};
var lineHeights = {
  lineHeightBase100: "14px",
  lineHeightBase200: "16px",
  lineHeightBase300: "20px",
  lineHeightBase400: "22px",
  lineHeightBase500: "28px",
  lineHeightBase600: "32px",
  lineHeightHero700: "36px",
  lineHeightHero800: "40px",
  lineHeightHero900: "52px",
  lineHeightHero1000: "92px"
};
var fontWeights = {
  fontWeightRegular: 400,
  fontWeightMedium: 500,
  fontWeightSemibold: 600,
  fontWeightBold: 700
};
var fontFamilies = {
  fontFamilyBase: (
    // eslint-disable-next-line @fluentui/max-len
    "'Segoe UI', 'Segoe UI Web (West European)', -apple-system, BlinkMacSystemFont, Roboto, 'Helvetica Neue', sans-serif"
  ),
  fontFamilyMonospace: "Consolas, 'Courier New', Courier, monospace",
  fontFamilyNumeric: (
    // eslint-disable-next-line @fluentui/max-len
    "Bahnschrift, 'Segoe UI', 'Segoe UI Web (West European)', -apple-system, BlinkMacSystemFont, Roboto, 'Helvetica Neue', sans-serif"
  )
};

// node_modules/@fluentui/tokens/lib/global/spacings.js
var spacings = {
  none: "0",
  xxs: "2px",
  xs: "4px",
  sNudge: "6px",
  s: "8px",
  mNudge: "10px",
  m: "12px",
  l: "16px",
  xl: "20px",
  xxl: "24px",
  xxxl: "32px"
};
var horizontalSpacings = {
  spacingHorizontalNone: spacings.none,
  spacingHorizontalXXS: spacings.xxs,
  spacingHorizontalXS: spacings.xs,
  spacingHorizontalSNudge: spacings.sNudge,
  spacingHorizontalS: spacings.s,
  spacingHorizontalMNudge: spacings.mNudge,
  spacingHorizontalM: spacings.m,
  spacingHorizontalL: spacings.l,
  spacingHorizontalXL: spacings.xl,
  spacingHorizontalXXL: spacings.xxl,
  spacingHorizontalXXXL: spacings.xxxl
};
var verticalSpacings = {
  spacingVerticalNone: spacings.none,
  spacingVerticalXXS: spacings.xxs,
  spacingVerticalXS: spacings.xs,
  spacingVerticalSNudge: spacings.sNudge,
  spacingVerticalS: spacings.s,
  spacingVerticalMNudge: spacings.mNudge,
  spacingVerticalM: spacings.m,
  spacingVerticalL: spacings.l,
  spacingVerticalXL: spacings.xl,
  spacingVerticalXXL: spacings.xxl,
  spacingVerticalXXXL: spacings.xxxl
};

// node_modules/@fluentui/tokens/lib/global/strokeWidths.js
var strokeWidths = {
  strokeWidthThin: "1px",
  strokeWidthThick: "2px",
  strokeWidthThicker: "3px",
  strokeWidthThickest: "4px"
};

// node_modules/@fluentui/tokens/lib/tokens.js
var tokens = {
  // Color tokens
  colorNeutralForeground1: "var(--colorNeutralForeground1)",
  colorNeutralForeground1Hover: "var(--colorNeutralForeground1Hover)",
  colorNeutralForeground1Pressed: "var(--colorNeutralForeground1Pressed)",
  colorNeutralForeground1Selected: "var(--colorNeutralForeground1Selected)",
  colorNeutralForeground2: "var(--colorNeutralForeground2)",
  colorNeutralForeground2Hover: "var(--colorNeutralForeground2Hover)",
  colorNeutralForeground2Pressed: "var(--colorNeutralForeground2Pressed)",
  colorNeutralForeground2Selected: "var(--colorNeutralForeground2Selected)",
  colorNeutralForeground2BrandHover: "var(--colorNeutralForeground2BrandHover)",
  colorNeutralForeground2BrandPressed: "var(--colorNeutralForeground2BrandPressed)",
  colorNeutralForeground2BrandSelected: "var(--colorNeutralForeground2BrandSelected)",
  colorNeutralForeground3: "var(--colorNeutralForeground3)",
  colorNeutralForeground3Hover: "var(--colorNeutralForeground3Hover)",
  colorNeutralForeground3Pressed: "var(--colorNeutralForeground3Pressed)",
  colorNeutralForeground3Selected: "var(--colorNeutralForeground3Selected)",
  colorNeutralForeground3BrandHover: "var(--colorNeutralForeground3BrandHover)",
  colorNeutralForeground3BrandPressed: "var(--colorNeutralForeground3BrandPressed)",
  colorNeutralForeground3BrandSelected: "var(--colorNeutralForeground3BrandSelected)",
  colorNeutralForeground4: "var(--colorNeutralForeground4)",
  colorNeutralForegroundDisabled: "var(--colorNeutralForegroundDisabled)",
  colorBrandForegroundLink: "var(--colorBrandForegroundLink)",
  colorBrandForegroundLinkHover: "var(--colorBrandForegroundLinkHover)",
  colorBrandForegroundLinkPressed: "var(--colorBrandForegroundLinkPressed)",
  colorBrandForegroundLinkSelected: "var(--colorBrandForegroundLinkSelected)",
  colorNeutralForeground2Link: "var(--colorNeutralForeground2Link)",
  colorNeutralForeground2LinkHover: "var(--colorNeutralForeground2LinkHover)",
  colorNeutralForeground2LinkPressed: "var(--colorNeutralForeground2LinkPressed)",
  colorNeutralForeground2LinkSelected: "var(--colorNeutralForeground2LinkSelected)",
  colorCompoundBrandForeground1: "var(--colorCompoundBrandForeground1)",
  colorCompoundBrandForeground1Hover: "var(--colorCompoundBrandForeground1Hover)",
  colorCompoundBrandForeground1Pressed: "var(--colorCompoundBrandForeground1Pressed)",
  colorNeutralForegroundOnBrand: "var(--colorNeutralForegroundOnBrand)",
  colorNeutralForegroundInverted: "var(--colorNeutralForegroundInverted)",
  colorNeutralForegroundInvertedHover: "var(--colorNeutralForegroundInvertedHover)",
  colorNeutralForegroundInvertedPressed: "var(--colorNeutralForegroundInvertedPressed)",
  colorNeutralForegroundInvertedSelected: "var(--colorNeutralForegroundInvertedSelected)",
  colorNeutralForegroundInverted2: "var(--colorNeutralForegroundInverted2)",
  colorNeutralForegroundStaticInverted: "var(--colorNeutralForegroundStaticInverted)",
  colorNeutralForegroundInvertedLink: "var(--colorNeutralForegroundInvertedLink)",
  colorNeutralForegroundInvertedLinkHover: "var(--colorNeutralForegroundInvertedLinkHover)",
  colorNeutralForegroundInvertedLinkPressed: "var(--colorNeutralForegroundInvertedLinkPressed)",
  colorNeutralForegroundInvertedLinkSelected: "var(--colorNeutralForegroundInvertedLinkSelected)",
  colorNeutralForegroundInvertedDisabled: "var(--colorNeutralForegroundInvertedDisabled)",
  colorBrandForeground1: "var(--colorBrandForeground1)",
  colorBrandForeground2: "var(--colorBrandForeground2)",
  colorBrandForeground2Hover: "var(--colorBrandForeground2Hover)",
  colorBrandForeground2Pressed: "var(--colorBrandForeground2Pressed)",
  colorNeutralForeground1Static: "var(--colorNeutralForeground1Static)",
  colorBrandForegroundInverted: "var(--colorBrandForegroundInverted)",
  colorBrandForegroundInvertedHover: "var(--colorBrandForegroundInvertedHover)",
  colorBrandForegroundInvertedPressed: "var(--colorBrandForegroundInvertedPressed)",
  colorBrandForegroundOnLight: "var(--colorBrandForegroundOnLight)",
  colorBrandForegroundOnLightHover: "var(--colorBrandForegroundOnLightHover)",
  colorBrandForegroundOnLightPressed: "var(--colorBrandForegroundOnLightPressed)",
  colorBrandForegroundOnLightSelected: "var(--colorBrandForegroundOnLightSelected)",
  colorNeutralBackground1: "var(--colorNeutralBackground1)",
  colorNeutralBackground1Hover: "var(--colorNeutralBackground1Hover)",
  colorNeutralBackground1Pressed: "var(--colorNeutralBackground1Pressed)",
  colorNeutralBackground1Selected: "var(--colorNeutralBackground1Selected)",
  colorNeutralBackground2: "var(--colorNeutralBackground2)",
  colorNeutralBackground2Hover: "var(--colorNeutralBackground2Hover)",
  colorNeutralBackground2Pressed: "var(--colorNeutralBackground2Pressed)",
  colorNeutralBackground2Selected: "var(--colorNeutralBackground2Selected)",
  colorNeutralBackground3: "var(--colorNeutralBackground3)",
  colorNeutralBackground3Hover: "var(--colorNeutralBackground3Hover)",
  colorNeutralBackground3Pressed: "var(--colorNeutralBackground3Pressed)",
  colorNeutralBackground3Selected: "var(--colorNeutralBackground3Selected)",
  colorNeutralBackground4: "var(--colorNeutralBackground4)",
  colorNeutralBackground4Hover: "var(--colorNeutralBackground4Hover)",
  colorNeutralBackground4Pressed: "var(--colorNeutralBackground4Pressed)",
  colorNeutralBackground4Selected: "var(--colorNeutralBackground4Selected)",
  colorNeutralBackground5: "var(--colorNeutralBackground5)",
  colorNeutralBackground5Hover: "var(--colorNeutralBackground5Hover)",
  colorNeutralBackground5Pressed: "var(--colorNeutralBackground5Pressed)",
  colorNeutralBackground5Selected: "var(--colorNeutralBackground5Selected)",
  colorNeutralBackground6: "var(--colorNeutralBackground6)",
  colorNeutralBackgroundInverted: "var(--colorNeutralBackgroundInverted)",
  colorNeutralBackgroundStatic: "var(--colorNeutralBackgroundStatic)",
  colorNeutralBackgroundAlpha: "var(--colorNeutralBackgroundAlpha)",
  colorNeutralBackgroundAlpha2: "var(--colorNeutralBackgroundAlpha2)",
  colorSubtleBackground: "var(--colorSubtleBackground)",
  colorSubtleBackgroundHover: "var(--colorSubtleBackgroundHover)",
  colorSubtleBackgroundPressed: "var(--colorSubtleBackgroundPressed)",
  colorSubtleBackgroundSelected: "var(--colorSubtleBackgroundSelected)",
  colorSubtleBackgroundLightAlphaHover: "var(--colorSubtleBackgroundLightAlphaHover)",
  colorSubtleBackgroundLightAlphaPressed: "var(--colorSubtleBackgroundLightAlphaPressed)",
  colorSubtleBackgroundLightAlphaSelected: "var(--colorSubtleBackgroundLightAlphaSelected)",
  colorSubtleBackgroundInverted: "var(--colorSubtleBackgroundInverted)",
  colorSubtleBackgroundInvertedHover: "var(--colorSubtleBackgroundInvertedHover)",
  colorSubtleBackgroundInvertedPressed: "var(--colorSubtleBackgroundInvertedPressed)",
  colorSubtleBackgroundInvertedSelected: "var(--colorSubtleBackgroundInvertedSelected)",
  colorTransparentBackground: "var(--colorTransparentBackground)",
  colorTransparentBackgroundHover: "var(--colorTransparentBackgroundHover)",
  colorTransparentBackgroundPressed: "var(--colorTransparentBackgroundPressed)",
  colorTransparentBackgroundSelected: "var(--colorTransparentBackgroundSelected)",
  colorNeutralBackgroundDisabled: "var(--colorNeutralBackgroundDisabled)",
  colorNeutralBackgroundInvertedDisabled: "var(--colorNeutralBackgroundInvertedDisabled)",
  colorNeutralStencil1: "var(--colorNeutralStencil1)",
  colorNeutralStencil2: "var(--colorNeutralStencil2)",
  colorNeutralStencil1Alpha: "var(--colorNeutralStencil1Alpha)",
  colorNeutralStencil2Alpha: "var(--colorNeutralStencil2Alpha)",
  colorBackgroundOverlay: "var(--colorBackgroundOverlay)",
  colorScrollbarOverlay: "var(--colorScrollbarOverlay)",
  colorBrandBackground: "var(--colorBrandBackground)",
  colorBrandBackgroundHover: "var(--colorBrandBackgroundHover)",
  colorBrandBackgroundPressed: "var(--colorBrandBackgroundPressed)",
  colorBrandBackgroundSelected: "var(--colorBrandBackgroundSelected)",
  colorCompoundBrandBackground: "var(--colorCompoundBrandBackground)",
  colorCompoundBrandBackgroundHover: "var(--colorCompoundBrandBackgroundHover)",
  colorCompoundBrandBackgroundPressed: "var(--colorCompoundBrandBackgroundPressed)",
  colorBrandBackgroundStatic: "var(--colorBrandBackgroundStatic)",
  colorBrandBackground2: "var(--colorBrandBackground2)",
  colorBrandBackground2Hover: "var(--colorBrandBackground2Hover)",
  colorBrandBackground2Pressed: "var(--colorBrandBackground2Pressed)",
  colorBrandBackgroundInverted: "var(--colorBrandBackgroundInverted)",
  colorBrandBackgroundInvertedHover: "var(--colorBrandBackgroundInvertedHover)",
  colorBrandBackgroundInvertedPressed: "var(--colorBrandBackgroundInvertedPressed)",
  colorBrandBackgroundInvertedSelected: "var(--colorBrandBackgroundInvertedSelected)",
  colorNeutralStrokeAccessible: "var(--colorNeutralStrokeAccessible)",
  colorNeutralStrokeAccessibleHover: "var(--colorNeutralStrokeAccessibleHover)",
  colorNeutralStrokeAccessiblePressed: "var(--colorNeutralStrokeAccessiblePressed)",
  colorNeutralStrokeAccessibleSelected: "var(--colorNeutralStrokeAccessibleSelected)",
  colorNeutralStroke1: "var(--colorNeutralStroke1)",
  colorNeutralStroke1Hover: "var(--colorNeutralStroke1Hover)",
  colorNeutralStroke1Pressed: "var(--colorNeutralStroke1Pressed)",
  colorNeutralStroke1Selected: "var(--colorNeutralStroke1Selected)",
  colorNeutralStroke2: "var(--colorNeutralStroke2)",
  colorNeutralStroke3: "var(--colorNeutralStroke3)",
  colorNeutralStrokeSubtle: "var(--colorNeutralStrokeSubtle)",
  colorNeutralStrokeOnBrand: "var(--colorNeutralStrokeOnBrand)",
  colorNeutralStrokeOnBrand2: "var(--colorNeutralStrokeOnBrand2)",
  colorNeutralStrokeOnBrand2Hover: "var(--colorNeutralStrokeOnBrand2Hover)",
  colorNeutralStrokeOnBrand2Pressed: "var(--colorNeutralStrokeOnBrand2Pressed)",
  colorNeutralStrokeOnBrand2Selected: "var(--colorNeutralStrokeOnBrand2Selected)",
  colorBrandStroke1: "var(--colorBrandStroke1)",
  colorBrandStroke2: "var(--colorBrandStroke2)",
  colorBrandStroke2Hover: "var(--colorBrandStroke2Hover)",
  colorBrandStroke2Pressed: "var(--colorBrandStroke2Pressed)",
  colorBrandStroke2Contrast: "var(--colorBrandStroke2Contrast)",
  colorCompoundBrandStroke: "var(--colorCompoundBrandStroke)",
  colorCompoundBrandStrokeHover: "var(--colorCompoundBrandStrokeHover)",
  colorCompoundBrandStrokePressed: "var(--colorCompoundBrandStrokePressed)",
  colorNeutralStrokeDisabled: "var(--colorNeutralStrokeDisabled)",
  colorNeutralStrokeInvertedDisabled: "var(--colorNeutralStrokeInvertedDisabled)",
  colorTransparentStroke: "var(--colorTransparentStroke)",
  colorTransparentStrokeInteractive: "var(--colorTransparentStrokeInteractive)",
  colorTransparentStrokeDisabled: "var(--colorTransparentStrokeDisabled)",
  colorNeutralStrokeAlpha: "var(--colorNeutralStrokeAlpha)",
  colorNeutralStrokeAlpha2: "var(--colorNeutralStrokeAlpha2)",
  colorStrokeFocus1: "var(--colorStrokeFocus1)",
  colorStrokeFocus2: "var(--colorStrokeFocus2)",
  colorNeutralShadowAmbient: "var(--colorNeutralShadowAmbient)",
  colorNeutralShadowKey: "var(--colorNeutralShadowKey)",
  colorNeutralShadowAmbientLighter: "var(--colorNeutralShadowAmbientLighter)",
  colorNeutralShadowKeyLighter: "var(--colorNeutralShadowKeyLighter)",
  colorNeutralShadowAmbientDarker: "var(--colorNeutralShadowAmbientDarker)",
  colorNeutralShadowKeyDarker: "var(--colorNeutralShadowKeyDarker)",
  colorBrandShadowAmbient: "var(--colorBrandShadowAmbient)",
  colorBrandShadowKey: "var(--colorBrandShadowKey)",
  // Color palette tokens
  // Color palette red tokens
  colorPaletteRedBackground1: "var(--colorPaletteRedBackground1)",
  colorPaletteRedBackground2: "var(--colorPaletteRedBackground2)",
  colorPaletteRedBackground3: "var(--colorPaletteRedBackground3)",
  colorPaletteRedBorderActive: "var(--colorPaletteRedBorderActive)",
  colorPaletteRedBorder1: "var(--colorPaletteRedBorder1)",
  colorPaletteRedBorder2: "var(--colorPaletteRedBorder2)",
  colorPaletteRedForeground1: "var(--colorPaletteRedForeground1)",
  colorPaletteRedForeground2: "var(--colorPaletteRedForeground2)",
  colorPaletteRedForeground3: "var(--colorPaletteRedForeground3)",
  colorPaletteRedForegroundInverted: "var(--colorPaletteRedForegroundInverted)",
  // Color palette green tokens
  colorPaletteGreenBackground1: "var(--colorPaletteGreenBackground1)",
  colorPaletteGreenBackground2: "var(--colorPaletteGreenBackground2)",
  colorPaletteGreenBackground3: "var(--colorPaletteGreenBackground3)",
  colorPaletteGreenBorderActive: "var(--colorPaletteGreenBorderActive)",
  colorPaletteGreenBorder1: "var(--colorPaletteGreenBorder1)",
  colorPaletteGreenBorder2: "var(--colorPaletteGreenBorder2)",
  colorPaletteGreenForeground1: "var(--colorPaletteGreenForeground1)",
  colorPaletteGreenForeground2: "var(--colorPaletteGreenForeground2)",
  colorPaletteGreenForeground3: "var(--colorPaletteGreenForeground3)",
  colorPaletteGreenForegroundInverted: "var(--colorPaletteGreenForegroundInverted)",
  // Color palette dark orange tokens
  colorPaletteDarkOrangeBackground1: "var(--colorPaletteDarkOrangeBackground1)",
  colorPaletteDarkOrangeBackground2: "var(--colorPaletteDarkOrangeBackground2)",
  colorPaletteDarkOrangeBackground3: "var(--colorPaletteDarkOrangeBackground3)",
  colorPaletteDarkOrangeBorderActive: "var(--colorPaletteDarkOrangeBorderActive)",
  colorPaletteDarkOrangeBorder1: "var(--colorPaletteDarkOrangeBorder1)",
  colorPaletteDarkOrangeBorder2: "var(--colorPaletteDarkOrangeBorder2)",
  colorPaletteDarkOrangeForeground1: "var(--colorPaletteDarkOrangeForeground1)",
  colorPaletteDarkOrangeForeground2: "var(--colorPaletteDarkOrangeForeground2)",
  colorPaletteDarkOrangeForeground3: "var(--colorPaletteDarkOrangeForeground3)",
  // Color palette yellow tokens
  colorPaletteYellowBackground1: "var(--colorPaletteYellowBackground1)",
  colorPaletteYellowBackground2: "var(--colorPaletteYellowBackground2)",
  colorPaletteYellowBackground3: "var(--colorPaletteYellowBackground3)",
  colorPaletteYellowBorderActive: "var(--colorPaletteYellowBorderActive)",
  colorPaletteYellowBorder1: "var(--colorPaletteYellowBorder1)",
  colorPaletteYellowBorder2: "var(--colorPaletteYellowBorder2)",
  colorPaletteYellowForeground1: "var(--colorPaletteYellowForeground1)",
  colorPaletteYellowForeground2: "var(--colorPaletteYellowForeground2)",
  colorPaletteYellowForeground3: "var(--colorPaletteYellowForeground3)",
  colorPaletteYellowForegroundInverted: "var(--colorPaletteYellowForegroundInverted)",
  // Color palette berry tokens
  colorPaletteBerryBackground1: "var(--colorPaletteBerryBackground1)",
  colorPaletteBerryBackground2: "var(--colorPaletteBerryBackground2)",
  colorPaletteBerryBackground3: "var(--colorPaletteBerryBackground3)",
  colorPaletteBerryBorderActive: "var(--colorPaletteBerryBorderActive)",
  colorPaletteBerryBorder1: "var(--colorPaletteBerryBorder1)",
  colorPaletteBerryBorder2: "var(--colorPaletteBerryBorder2)",
  colorPaletteBerryForeground1: "var(--colorPaletteBerryForeground1)",
  colorPaletteBerryForeground2: "var(--colorPaletteBerryForeground2)",
  colorPaletteBerryForeground3: "var(--colorPaletteBerryForeground3)",
  // Color palette marigold tokens
  colorPaletteMarigoldBackground1: "var(--colorPaletteMarigoldBackground1)",
  colorPaletteMarigoldBackground2: "var(--colorPaletteMarigoldBackground2)",
  colorPaletteMarigoldBackground3: "var(--colorPaletteMarigoldBackground3)",
  colorPaletteMarigoldBorderActive: "var(--colorPaletteMarigoldBorderActive)",
  colorPaletteMarigoldBorder1: "var(--colorPaletteMarigoldBorder1)",
  colorPaletteMarigoldBorder2: "var(--colorPaletteMarigoldBorder2)",
  colorPaletteMarigoldForeground1: "var(--colorPaletteMarigoldForeground1)",
  colorPaletteMarigoldForeground2: "var(--colorPaletteMarigoldForeground2)",
  colorPaletteMarigoldForeground3: "var(--colorPaletteMarigoldForeground3)",
  // Color palette light green tokens
  colorPaletteLightGreenBackground1: "var(--colorPaletteLightGreenBackground1)",
  colorPaletteLightGreenBackground2: "var(--colorPaletteLightGreenBackground2)",
  colorPaletteLightGreenBackground3: "var(--colorPaletteLightGreenBackground3)",
  colorPaletteLightGreenBorderActive: "var(--colorPaletteLightGreenBorderActive)",
  colorPaletteLightGreenBorder1: "var(--colorPaletteLightGreenBorder1)",
  colorPaletteLightGreenBorder2: "var(--colorPaletteLightGreenBorder2)",
  colorPaletteLightGreenForeground1: "var(--colorPaletteLightGreenForeground1)",
  colorPaletteLightGreenForeground2: "var(--colorPaletteLightGreenForeground2)",
  colorPaletteLightGreenForeground3: "var(--colorPaletteLightGreenForeground3)",
  // Color palette anchor tokens
  colorPaletteAnchorBackground2: "var(--colorPaletteAnchorBackground2)",
  colorPaletteAnchorBorderActive: "var(--colorPaletteAnchorBorderActive)",
  colorPaletteAnchorForeground2: "var(--colorPaletteAnchorForeground2)",
  // Color palette beige tokens
  colorPaletteBeigeBackground2: "var(--colorPaletteBeigeBackground2)",
  colorPaletteBeigeBorderActive: "var(--colorPaletteBeigeBorderActive)",
  colorPaletteBeigeForeground2: "var(--colorPaletteBeigeForeground2)",
  // Color palette blue tokens
  colorPaletteBlueBackground2: "var(--colorPaletteBlueBackground2)",
  colorPaletteBlueBorderActive: "var(--colorPaletteBlueBorderActive)",
  colorPaletteBlueForeground2: "var(--colorPaletteBlueForeground2)",
  // Color palette brass tokens
  colorPaletteBrassBackground2: "var(--colorPaletteBrassBackground2)",
  colorPaletteBrassBorderActive: "var(--colorPaletteBrassBorderActive)",
  colorPaletteBrassForeground2: "var(--colorPaletteBrassForeground2)",
  // Color palette brown tokens
  colorPaletteBrownBackground2: "var(--colorPaletteBrownBackground2)",
  colorPaletteBrownBorderActive: "var(--colorPaletteBrownBorderActive)",
  colorPaletteBrownForeground2: "var(--colorPaletteBrownForeground2)",
  // Color palette cornflower tokens
  colorPaletteCornflowerBackground2: "var(--colorPaletteCornflowerBackground2)",
  colorPaletteCornflowerBorderActive: "var(--colorPaletteCornflowerBorderActive)",
  colorPaletteCornflowerForeground2: "var(--colorPaletteCornflowerForeground2)",
  // Color palette cranberry tokens
  colorPaletteCranberryBackground2: "var(--colorPaletteCranberryBackground2)",
  colorPaletteCranberryBorderActive: "var(--colorPaletteCranberryBorderActive)",
  colorPaletteCranberryForeground2: "var(--colorPaletteCranberryForeground2)",
  // Color palette dark green tokens
  colorPaletteDarkGreenBackground2: "var(--colorPaletteDarkGreenBackground2)",
  colorPaletteDarkGreenBorderActive: "var(--colorPaletteDarkGreenBorderActive)",
  colorPaletteDarkGreenForeground2: "var(--colorPaletteDarkGreenForeground2)",
  // Color palette dark red tokens
  colorPaletteDarkRedBackground2: "var(--colorPaletteDarkRedBackground2)",
  colorPaletteDarkRedBorderActive: "var(--colorPaletteDarkRedBorderActive)",
  colorPaletteDarkRedForeground2: "var(--colorPaletteDarkRedForeground2)",
  // Color palette forest tokens
  colorPaletteForestBackground2: "var(--colorPaletteForestBackground2)",
  colorPaletteForestBorderActive: "var(--colorPaletteForestBorderActive)",
  colorPaletteForestForeground2: "var(--colorPaletteForestForeground2)",
  // Color palette gold tokens
  colorPaletteGoldBackground2: "var(--colorPaletteGoldBackground2)",
  colorPaletteGoldBorderActive: "var(--colorPaletteGoldBorderActive)",
  colorPaletteGoldForeground2: "var(--colorPaletteGoldForeground2)",
  // Color palette grape tokens
  colorPaletteGrapeBackground2: "var(--colorPaletteGrapeBackground2)",
  colorPaletteGrapeBorderActive: "var(--colorPaletteGrapeBorderActive)",
  colorPaletteGrapeForeground2: "var(--colorPaletteGrapeForeground2)",
  // Color palette lavender tokens
  colorPaletteLavenderBackground2: "var(--colorPaletteLavenderBackground2)",
  colorPaletteLavenderBorderActive: "var(--colorPaletteLavenderBorderActive)",
  colorPaletteLavenderForeground2: "var(--colorPaletteLavenderForeground2)",
  // Color palette light teal tokens
  colorPaletteLightTealBackground2: "var(--colorPaletteLightTealBackground2)",
  colorPaletteLightTealBorderActive: "var(--colorPaletteLightTealBorderActive)",
  colorPaletteLightTealForeground2: "var(--colorPaletteLightTealForeground2)",
  // Color palette lilac tokens
  colorPaletteLilacBackground2: "var(--colorPaletteLilacBackground2)",
  colorPaletteLilacBorderActive: "var(--colorPaletteLilacBorderActive)",
  colorPaletteLilacForeground2: "var(--colorPaletteLilacForeground2)",
  // Color palette magenta tokens
  colorPaletteMagentaBackground2: "var(--colorPaletteMagentaBackground2)",
  colorPaletteMagentaBorderActive: "var(--colorPaletteMagentaBorderActive)",
  colorPaletteMagentaForeground2: "var(--colorPaletteMagentaForeground2)",
  // Color palette mink tokens
  colorPaletteMinkBackground2: "var(--colorPaletteMinkBackground2)",
  colorPaletteMinkBorderActive: "var(--colorPaletteMinkBorderActive)",
  colorPaletteMinkForeground2: "var(--colorPaletteMinkForeground2)",
  // Color palette navy tokens
  colorPaletteNavyBackground2: "var(--colorPaletteNavyBackground2)",
  colorPaletteNavyBorderActive: "var(--colorPaletteNavyBorderActive)",
  colorPaletteNavyForeground2: "var(--colorPaletteNavyForeground2)",
  // Color palette peach tokens
  colorPalettePeachBackground2: "var(--colorPalettePeachBackground2)",
  colorPalettePeachBorderActive: "var(--colorPalettePeachBorderActive)",
  colorPalettePeachForeground2: "var(--colorPalettePeachForeground2)",
  // Color palette pink tokens
  colorPalettePinkBackground2: "var(--colorPalettePinkBackground2)",
  colorPalettePinkBorderActive: "var(--colorPalettePinkBorderActive)",
  colorPalettePinkForeground2: "var(--colorPalettePinkForeground2)",
  // Color palette platinum tokens
  colorPalettePlatinumBackground2: "var(--colorPalettePlatinumBackground2)",
  colorPalettePlatinumBorderActive: "var(--colorPalettePlatinumBorderActive)",
  colorPalettePlatinumForeground2: "var(--colorPalettePlatinumForeground2)",
  // Color palette plum tokens
  colorPalettePlumBackground2: "var(--colorPalettePlumBackground2)",
  colorPalettePlumBorderActive: "var(--colorPalettePlumBorderActive)",
  colorPalettePlumForeground2: "var(--colorPalettePlumForeground2)",
  // Color palette pumpkin tokens
  colorPalettePumpkinBackground2: "var(--colorPalettePumpkinBackground2)",
  colorPalettePumpkinBorderActive: "var(--colorPalettePumpkinBorderActive)",
  colorPalettePumpkinForeground2: "var(--colorPalettePumpkinForeground2)",
  // Color palette purple tokens
  colorPalettePurpleBackground2: "var(--colorPalettePurpleBackground2)",
  colorPalettePurpleBorderActive: "var(--colorPalettePurpleBorderActive)",
  colorPalettePurpleForeground2: "var(--colorPalettePurpleForeground2)",
  // Color palette royal blue tokens
  colorPaletteRoyalBlueBackground2: "var(--colorPaletteRoyalBlueBackground2)",
  colorPaletteRoyalBlueBorderActive: "var(--colorPaletteRoyalBlueBorderActive)",
  colorPaletteRoyalBlueForeground2: "var(--colorPaletteRoyalBlueForeground2)",
  // Color palette seafoam tokens
  colorPaletteSeafoamBackground2: "var(--colorPaletteSeafoamBackground2)",
  colorPaletteSeafoamBorderActive: "var(--colorPaletteSeafoamBorderActive)",
  colorPaletteSeafoamForeground2: "var(--colorPaletteSeafoamForeground2)",
  // Color palette steel tokens
  colorPaletteSteelBackground2: "var(--colorPaletteSteelBackground2)",
  colorPaletteSteelBorderActive: "var(--colorPaletteSteelBorderActive)",
  colorPaletteSteelForeground2: "var(--colorPaletteSteelForeground2)",
  // Color palette teal tokens
  colorPaletteTealBackground2: "var(--colorPaletteTealBackground2)",
  colorPaletteTealBorderActive: "var(--colorPaletteTealBorderActive)",
  colorPaletteTealForeground2: "var(--colorPaletteTealForeground2)",
  // Color status success tokens
  colorStatusSuccessBackground1: "var(--colorStatusSuccessBackground1)",
  colorStatusSuccessBackground2: "var(--colorStatusSuccessBackground2)",
  colorStatusSuccessBackground3: "var(--colorStatusSuccessBackground3)",
  colorStatusSuccessForeground1: "var(--colorStatusSuccessForeground1)",
  colorStatusSuccessForeground2: "var(--colorStatusSuccessForeground2)",
  colorStatusSuccessForeground3: "var(--colorStatusSuccessForeground3)",
  colorStatusSuccessForegroundInverted: "var(--colorStatusSuccessForegroundInverted)",
  colorStatusSuccessBorderActive: "var(--colorStatusSuccessBorderActive)",
  colorStatusSuccessBorder1: "var(--colorStatusSuccessBorder1)",
  colorStatusSuccessBorder2: "var(--colorStatusSuccessBorder2)",
  // Color status warning tokens
  colorStatusWarningBackground1: "var(--colorStatusWarningBackground1)",
  colorStatusWarningBackground2: "var(--colorStatusWarningBackground2)",
  colorStatusWarningBackground3: "var(--colorStatusWarningBackground3)",
  colorStatusWarningForeground1: "var(--colorStatusWarningForeground1)",
  colorStatusWarningForeground2: "var(--colorStatusWarningForeground2)",
  colorStatusWarningForeground3: "var(--colorStatusWarningForeground3)",
  colorStatusWarningForegroundInverted: "var(--colorStatusWarningForegroundInverted)",
  colorStatusWarningBorderActive: "var(--colorStatusWarningBorderActive)",
  colorStatusWarningBorder1: "var(--colorStatusWarningBorder1)",
  colorStatusWarningBorder2: "var(--colorStatusWarningBorder2)",
  // Color status danger tokens
  colorStatusDangerBackground1: "var(--colorStatusDangerBackground1)",
  colorStatusDangerBackground2: "var(--colorStatusDangerBackground2)",
  colorStatusDangerBackground3: "var(--colorStatusDangerBackground3)",
  colorStatusDangerForeground1: "var(--colorStatusDangerForeground1)",
  colorStatusDangerForeground2: "var(--colorStatusDangerForeground2)",
  colorStatusDangerForeground3: "var(--colorStatusDangerForeground3)",
  colorStatusDangerForegroundInverted: "var(--colorStatusDangerForegroundInverted)",
  colorStatusDangerBorderActive: "var(--colorStatusDangerBorderActive)",
  colorStatusDangerBorder1: "var(--colorStatusDangerBorder1)",
  colorStatusDangerBorder2: "var(--colorStatusDangerBorder2)",
  // Border radius tokens
  borderRadiusNone: "var(--borderRadiusNone)",
  borderRadiusSmall: "var(--borderRadiusSmall)",
  borderRadiusMedium: "var(--borderRadiusMedium)",
  borderRadiusLarge: "var(--borderRadiusLarge)",
  borderRadiusXLarge: "var(--borderRadiusXLarge)",
  borderRadiusCircular: "var(--borderRadiusCircular)",
  // Font family tokens
  fontFamilyBase: "var(--fontFamilyBase)",
  fontFamilyMonospace: "var(--fontFamilyMonospace)",
  fontFamilyNumeric: "var(--fontFamilyNumeric)",
  // Font size tokens
  fontSizeBase100: "var(--fontSizeBase100)",
  fontSizeBase200: "var(--fontSizeBase200)",
  fontSizeBase300: "var(--fontSizeBase300)",
  fontSizeBase400: "var(--fontSizeBase400)",
  fontSizeBase500: "var(--fontSizeBase500)",
  fontSizeBase600: "var(--fontSizeBase600)",
  fontSizeHero700: "var(--fontSizeHero700)",
  fontSizeHero800: "var(--fontSizeHero800)",
  fontSizeHero900: "var(--fontSizeHero900)",
  fontSizeHero1000: "var(--fontSizeHero1000)",
  // Font weight tokens
  fontWeightRegular: "var(--fontWeightRegular)",
  fontWeightMedium: "var(--fontWeightMedium)",
  fontWeightSemibold: "var(--fontWeightSemibold)",
  fontWeightBold: "var(--fontWeightBold)",
  // Line height tokens
  lineHeightBase100: "var(--lineHeightBase100)",
  lineHeightBase200: "var(--lineHeightBase200)",
  lineHeightBase300: "var(--lineHeightBase300)",
  lineHeightBase400: "var(--lineHeightBase400)",
  lineHeightBase500: "var(--lineHeightBase500)",
  lineHeightBase600: "var(--lineHeightBase600)",
  lineHeightHero700: "var(--lineHeightHero700)",
  lineHeightHero800: "var(--lineHeightHero800)",
  lineHeightHero900: "var(--lineHeightHero900)",
  lineHeightHero1000: "var(--lineHeightHero1000)",
  // Shadow tokens
  shadow2: "var(--shadow2)",
  shadow4: "var(--shadow4)",
  shadow8: "var(--shadow8)",
  shadow16: "var(--shadow16)",
  shadow28: "var(--shadow28)",
  shadow64: "var(--shadow64)",
  // Shadow brand tokens
  shadow2Brand: "var(--shadow2Brand)",
  shadow4Brand: "var(--shadow4Brand)",
  shadow8Brand: "var(--shadow8Brand)",
  shadow16Brand: "var(--shadow16Brand)",
  shadow28Brand: "var(--shadow28Brand)",
  shadow64Brand: "var(--shadow64Brand)",
  // Stroke width tokens
  strokeWidthThin: "var(--strokeWidthThin)",
  strokeWidthThick: "var(--strokeWidthThick)",
  strokeWidthThicker: "var(--strokeWidthThicker)",
  strokeWidthThickest: "var(--strokeWidthThickest)",
  // Spacings
  spacingHorizontalNone: "var(--spacingHorizontalNone)",
  spacingHorizontalXXS: "var(--spacingHorizontalXXS)",
  spacingHorizontalXS: "var(--spacingHorizontalXS)",
  spacingHorizontalSNudge: "var(--spacingHorizontalSNudge)",
  spacingHorizontalS: "var(--spacingHorizontalS)",
  spacingHorizontalMNudge: "var(--spacingHorizontalMNudge)",
  spacingHorizontalM: "var(--spacingHorizontalM)",
  spacingHorizontalL: "var(--spacingHorizontalL)",
  spacingHorizontalXL: "var(--spacingHorizontalXL)",
  spacingHorizontalXXL: "var(--spacingHorizontalXXL)",
  spacingHorizontalXXXL: "var(--spacingHorizontalXXXL)",
  spacingVerticalNone: "var(--spacingVerticalNone)",
  spacingVerticalXXS: "var(--spacingVerticalXXS)",
  spacingVerticalXS: "var(--spacingVerticalXS)",
  spacingVerticalSNudge: "var(--spacingVerticalSNudge)",
  spacingVerticalS: "var(--spacingVerticalS)",
  spacingVerticalMNudge: "var(--spacingVerticalMNudge)",
  spacingVerticalM: "var(--spacingVerticalM)",
  spacingVerticalL: "var(--spacingVerticalL)",
  spacingVerticalXL: "var(--spacingVerticalXL)",
  spacingVerticalXXL: "var(--spacingVerticalXXL)",
  spacingVerticalXXXL: "var(--spacingVerticalXXXL)",
  // Durations
  durationUltraFast: "var(--durationUltraFast)",
  durationFaster: "var(--durationFaster)",
  durationFast: "var(--durationFast)",
  durationNormal: "var(--durationNormal)",
  durationGentle: "var(--durationGentle)",
  durationSlow: "var(--durationSlow)",
  durationSlower: "var(--durationSlower)",
  durationUltraSlow: "var(--durationUltraSlow)",
  // Curves
  curveAccelerateMax: "var(--curveAccelerateMax)",
  curveAccelerateMid: "var(--curveAccelerateMid)",
  curveAccelerateMin: "var(--curveAccelerateMin)",
  curveDecelerateMax: "var(--curveDecelerateMax)",
  curveDecelerateMid: "var(--curveDecelerateMid)",
  curveDecelerateMin: "var(--curveDecelerateMin)",
  curveEasyEaseMax: "var(--curveEasyEaseMax)",
  curveEasyEase: "var(--curveEasyEase)",
  curveLinear: "var(--curveLinear)"
};

// node_modules/@fluentui/tokens/lib/global/typographyStyles.js
var typographyStyles = {
  body1: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase300,
    fontWeight: tokens.fontWeightRegular,
    lineHeight: tokens.lineHeightBase300
  },
  body1Strong: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase300,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightBase300
  },
  body1Stronger: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase300,
    fontWeight: tokens.fontWeightBold,
    lineHeight: tokens.lineHeightBase300
  },
  body2: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase400,
    fontWeight: tokens.fontWeightRegular,
    lineHeight: tokens.lineHeightBase400
  },
  caption1: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase200,
    fontWeight: tokens.fontWeightRegular,
    lineHeight: tokens.lineHeightBase200
  },
  caption1Strong: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase200,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightBase200
  },
  caption1Stronger: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase200,
    fontWeight: tokens.fontWeightBold,
    lineHeight: tokens.lineHeightBase200
  },
  caption2: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase100,
    fontWeight: tokens.fontWeightRegular,
    lineHeight: tokens.lineHeightBase100
  },
  caption2Strong: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase100,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightBase100
  },
  subtitle1: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase500,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightBase500
  },
  subtitle2: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase400,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightBase400
  },
  subtitle2Stronger: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase400,
    fontWeight: tokens.fontWeightBold,
    lineHeight: tokens.lineHeightBase400
  },
  title1: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeHero800,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightHero800
  },
  title2: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeHero700,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightHero700
  },
  title3: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase600,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightBase600
  },
  largeTitle: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeHero900,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightHero900
  },
  display: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeHero1000,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightHero1000
  }
};

// node_modules/@fluentui/tokens/lib/utils/shadows.js
function createShadowTokens(ambientColor, keyColor, tokenSuffix = "") {
  return {
    [`shadow2${tokenSuffix}`]: `0 0 2px ${ambientColor}, 0 1px 2px ${keyColor}`,
    [`shadow4${tokenSuffix}`]: `0 0 2px ${ambientColor}, 0 2px 4px ${keyColor}`,
    [`shadow8${tokenSuffix}`]: `0 0 2px ${ambientColor}, 0 4px 8px ${keyColor}`,
    [`shadow16${tokenSuffix}`]: `0 0 2px ${ambientColor}, 0 8px 16px ${keyColor}`,
    [`shadow28${tokenSuffix}`]: `0 0 8px ${ambientColor}, 0 14px 28px ${keyColor}`,
    [`shadow64${tokenSuffix}`]: `0 0 8px ${ambientColor}, 0 32px 64px ${keyColor}`
  };
}

// node_modules/@fluentui/tokens/lib/utils/createLightTheme.js
var createLightTheme = (brand) => {
  const colorTokens = generateColorTokens(brand);
  return {
    ...borderRadius,
    ...fontSizes,
    ...lineHeights,
    ...fontFamilies,
    ...fontWeights,
    ...strokeWidths,
    ...horizontalSpacings,
    ...verticalSpacings,
    ...durations,
    ...curves,
    ...colorTokens,
    ...colorPaletteTokens,
    ...colorStatusTokens,
    ...createShadowTokens(colorTokens.colorNeutralShadowAmbient, colorTokens.colorNeutralShadowKey),
    ...createShadowTokens(colorTokens.colorBrandShadowAmbient, colorTokens.colorBrandShadowKey, "Brand")
  };
};

// node_modules/@fluentui/tokens/lib/global/brandColors.js
var brandWeb = {
  10: `#061724`,
  20: `#082338`,
  30: `#0a2e4a`,
  40: `#0c3b5e`,
  50: `#0e4775`,
  60: `#0f548c`,
  70: `#115ea3`,
  80: `#0f6cbd`,
  90: `#2886de`,
  100: `#479ef5`,
  110: `#62abf5`,
  120: `#77b7f7`,
  130: `#96c6fa`,
  140: `#b4d6fa`,
  150: `#cfe4fa`,
  160: `#ebf3fc`
};
var brandTeams = {
  10: `#2b2b40`,
  20: `#2f2f4a`,
  30: `#333357`,
  40: `#383966`,
  50: `#3d3e78`,
  60: `#444791`,
  70: `#4f52b2`,
  80: `#5b5fc7`,
  90: `#7579eb`,
  100: `#7f85f5`,
  110: `#9299f7`,
  120: `#aab1fa`,
  130: `#b6bcfa`,
  140: `#c5cbfa`,
  150: `#dce0fa`,
  160: `#e8ebfa`
};

// node_modules/@fluentui/tokens/lib/themes/teams/lightTheme.js
var teamsLightTheme = createLightTheme(brandTeams);

// node_modules/@fluentui/tokens/lib/alias/darkColorPalette.js
var statusColorPaletteTokens2 = statusSharedColorNames.reduce((acc, sharedColor) => {
  const color = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
  const sharedColorTokens = {
    [`colorPalette${color}Background1`]: statusSharedColors[sharedColor].shade40,
    [`colorPalette${color}Background2`]: statusSharedColors[sharedColor].shade30,
    [`colorPalette${color}Background3`]: statusSharedColors[sharedColor].primary,
    [`colorPalette${color}Foreground1`]: statusSharedColors[sharedColor].tint30,
    [`colorPalette${color}Foreground2`]: statusSharedColors[sharedColor].tint40,
    [`colorPalette${color}Foreground3`]: statusSharedColors[sharedColor].tint20,
    [`colorPalette${color}BorderActive`]: statusSharedColors[sharedColor].tint30,
    [`colorPalette${color}Border1`]: statusSharedColors[sharedColor].primary,
    [`colorPalette${color}Border2`]: statusSharedColors[sharedColor].tint20
  };
  return Object.assign(acc, sharedColorTokens);
}, {});
statusColorPaletteTokens2.colorPaletteRedForeground3 = statusSharedColors.red.tint30;
statusColorPaletteTokens2.colorPaletteRedBorder2 = statusSharedColors.red.tint30;
statusColorPaletteTokens2.colorPaletteGreenForeground3 = statusSharedColors.green.tint40;
statusColorPaletteTokens2.colorPaletteGreenBorder2 = statusSharedColors.green.tint40;
statusColorPaletteTokens2.colorPaletteDarkOrangeForeground3 = statusSharedColors.darkOrange.tint30;
statusColorPaletteTokens2.colorPaletteDarkOrangeBorder2 = statusSharedColors.darkOrange.tint30;
statusColorPaletteTokens2.colorPaletteRedForegroundInverted = statusSharedColors.red.primary;
statusColorPaletteTokens2.colorPaletteGreenForegroundInverted = statusSharedColors.green.primary;
statusColorPaletteTokens2.colorPaletteYellowForegroundInverted = statusSharedColors.yellow.shade30;
var personaColorPaletteTokens2 = personaSharedColorNames.reduce((acc, sharedColor) => {
  const color = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
  const sharedColorTokens = {
    [`colorPalette${color}Background2`]: personaSharedColors[sharedColor].shade30,
    [`colorPalette${color}Foreground2`]: personaSharedColors[sharedColor].tint40,
    [`colorPalette${color}BorderActive`]: personaSharedColors[sharedColor].tint30
  };
  return Object.assign(acc, sharedColorTokens);
}, {});
personaColorPaletteTokens2.colorPaletteDarkRedBackground2 = personaSharedColors.darkRed.shade20;
personaColorPaletteTokens2.colorPalettePlumBackground2 = personaSharedColors.plum.shade20;
var colorPaletteTokens2 = {
  ...statusColorPaletteTokens2,
  ...personaColorPaletteTokens2
};
var colorStatusTokens2 = Object.entries(statusColorMapping).reduce((acc, [statusColor, sharedColor]) => {
  const color = statusColor.slice(0, 1).toUpperCase() + statusColor.slice(1);
  const statusColorTokens = {
    [`colorStatus${color}Background1`]: mappedStatusColors[sharedColor].shade40,
    [`colorStatus${color}Background2`]: mappedStatusColors[sharedColor].shade30,
    [`colorStatus${color}Background3`]: mappedStatusColors[sharedColor].primary,
    [`colorStatus${color}Foreground1`]: mappedStatusColors[sharedColor].tint30,
    [`colorStatus${color}Foreground2`]: mappedStatusColors[sharedColor].tint40,
    [`colorStatus${color}Foreground3`]: mappedStatusColors[sharedColor].tint20,
    [`colorStatus${color}BorderActive`]: mappedStatusColors[sharedColor].tint30,
    [`colorStatus${color}ForegroundInverted`]: mappedStatusColors[sharedColor].shade10,
    [`colorStatus${color}Border1`]: mappedStatusColors[sharedColor].primary,
    [`colorStatus${color}Border2`]: mappedStatusColors[sharedColor].tint20
  };
  return Object.assign(acc, statusColorTokens);
}, {});
colorStatusTokens2.colorStatusDangerForeground3 = mappedStatusColors[statusColorMapping.danger].tint30;
colorStatusTokens2.colorStatusDangerBorder2 = mappedStatusColors[statusColorMapping.danger].tint30;
colorStatusTokens2.colorStatusSuccessForeground3 = mappedStatusColors[statusColorMapping.success].tint40;
colorStatusTokens2.colorStatusSuccessBorder2 = mappedStatusColors[statusColorMapping.success].tint40;
colorStatusTokens2.colorStatusWarningForegroundInverted = mappedStatusColors[statusColorMapping.warning].shade20;

// node_modules/@fluentui/tokens/lib/alias/teamsDarkColor.js
var generateColorTokens2 = (brand) => ({
  colorNeutralForeground1: white,
  colorNeutralForeground1Hover: white,
  colorNeutralForeground1Pressed: white,
  colorNeutralForeground1Selected: white,
  colorNeutralForeground2: grey[84],
  colorNeutralForeground2Hover: white,
  colorNeutralForeground2Pressed: white,
  colorNeutralForeground2Selected: white,
  colorNeutralForeground2BrandHover: brand[100],
  colorNeutralForeground2BrandPressed: brand[90],
  colorNeutralForeground2BrandSelected: brand[100],
  colorNeutralForeground3: grey[68],
  colorNeutralForeground3Hover: grey[84],
  colorNeutralForeground3Pressed: grey[84],
  colorNeutralForeground3Selected: grey[84],
  colorNeutralForeground3BrandHover: brand[100],
  colorNeutralForeground3BrandPressed: brand[90],
  colorNeutralForeground3BrandSelected: brand[100],
  colorNeutralForeground4: grey[60],
  colorNeutralForegroundDisabled: grey[36],
  colorNeutralForegroundInvertedDisabled: whiteAlpha[40],
  colorBrandForegroundLink: brand[100],
  colorBrandForegroundLinkHover: brand[110],
  colorBrandForegroundLinkPressed: brand[90],
  colorBrandForegroundLinkSelected: brand[100],
  colorNeutralForeground2Link: grey[84],
  colorNeutralForeground2LinkHover: white,
  colorNeutralForeground2LinkPressed: white,
  colorNeutralForeground2LinkSelected: white,
  colorCompoundBrandForeground1: brand[100],
  colorCompoundBrandForeground1Hover: brand[110],
  colorCompoundBrandForeground1Pressed: brand[90],
  colorBrandForeground1: brand[100],
  colorBrandForeground2: brand[120],
  colorBrandForeground2Hover: brand[130],
  colorBrandForeground2Pressed: brand[160],
  colorNeutralForeground1Static: grey[14],
  colorNeutralForegroundStaticInverted: white,
  colorNeutralForegroundInverted: grey[14],
  colorNeutralForegroundInvertedHover: grey[14],
  colorNeutralForegroundInvertedPressed: grey[14],
  colorNeutralForegroundInvertedSelected: grey[14],
  colorNeutralForegroundInverted2: grey[14],
  colorNeutralForegroundOnBrand: white,
  colorNeutralForegroundInvertedLink: white,
  colorNeutralForegroundInvertedLinkHover: white,
  colorNeutralForegroundInvertedLinkPressed: white,
  colorNeutralForegroundInvertedLinkSelected: white,
  colorBrandForegroundInverted: brand[80],
  colorBrandForegroundInvertedHover: brand[70],
  colorBrandForegroundInvertedPressed: brand[60],
  colorBrandForegroundOnLight: brand[80],
  colorBrandForegroundOnLightHover: brand[70],
  colorBrandForegroundOnLightPressed: brand[50],
  colorBrandForegroundOnLightSelected: brand[60],
  colorNeutralBackground1: grey[16],
  colorNeutralBackground1Hover: grey[24],
  colorNeutralBackground1Pressed: grey[12],
  colorNeutralBackground1Selected: grey[22],
  colorNeutralBackground2: grey[14],
  colorNeutralBackground2Hover: grey[22],
  colorNeutralBackground2Pressed: grey[10],
  colorNeutralBackground2Selected: grey[20],
  colorNeutralBackground3: grey[12],
  colorNeutralBackground3Hover: grey[20],
  colorNeutralBackground3Pressed: grey[8],
  colorNeutralBackground3Selected: grey[18],
  colorNeutralBackground4: grey[8],
  colorNeutralBackground4Hover: grey[16],
  colorNeutralBackground4Pressed: grey[4],
  colorNeutralBackground4Selected: grey[14],
  colorNeutralBackground5: grey[4],
  colorNeutralBackground5Hover: grey[12],
  colorNeutralBackground5Pressed: black,
  colorNeutralBackground5Selected: grey[10],
  colorNeutralBackground6: grey[20],
  colorNeutralBackgroundInverted: white,
  colorNeutralBackgroundStatic: grey[24],
  colorNeutralBackgroundAlpha: grey10Alpha[50],
  colorNeutralBackgroundAlpha2: grey12Alpha[70],
  colorSubtleBackground: "transparent",
  colorSubtleBackgroundHover: grey[22],
  colorSubtleBackgroundPressed: grey[18],
  colorSubtleBackgroundSelected: grey[20],
  colorSubtleBackgroundLightAlphaHover: grey14Alpha[80],
  colorSubtleBackgroundLightAlphaPressed: grey14Alpha[50],
  colorSubtleBackgroundLightAlphaSelected: "transparent",
  colorSubtleBackgroundInverted: "transparent",
  colorSubtleBackgroundInvertedHover: blackAlpha[10],
  colorSubtleBackgroundInvertedPressed: blackAlpha[30],
  colorSubtleBackgroundInvertedSelected: blackAlpha[20],
  colorTransparentBackground: "transparent",
  colorTransparentBackgroundHover: "transparent",
  colorTransparentBackgroundPressed: "transparent",
  colorTransparentBackgroundSelected: "transparent",
  colorNeutralBackgroundDisabled: grey[8],
  colorNeutralBackgroundInvertedDisabled: whiteAlpha[10],
  colorNeutralStencil1: grey[34],
  colorNeutralStencil2: grey[20],
  colorNeutralStencil1Alpha: whiteAlpha[10],
  colorNeutralStencil2Alpha: whiteAlpha[5],
  colorBackgroundOverlay: blackAlpha[50],
  colorScrollbarOverlay: whiteAlpha[60],
  colorBrandBackground: brand[70],
  colorBrandBackgroundHover: brand[80],
  colorBrandBackgroundPressed: brand[40],
  colorBrandBackgroundSelected: brand[60],
  colorCompoundBrandBackground: brand[100],
  colorCompoundBrandBackgroundHover: brand[110],
  colorCompoundBrandBackgroundPressed: brand[90],
  colorBrandBackgroundStatic: brand[80],
  colorBrandBackground2: brand[20],
  colorBrandBackground2Hover: brand[40],
  colorBrandBackground2Pressed: brand[10],
  colorBrandBackgroundInverted: white,
  colorBrandBackgroundInvertedHover: brand[160],
  colorBrandBackgroundInvertedPressed: brand[140],
  colorBrandBackgroundInvertedSelected: brand[150],
  colorNeutralStrokeAccessible: grey[68],
  colorNeutralStrokeAccessibleHover: grey[74],
  colorNeutralStrokeAccessiblePressed: grey[70],
  colorNeutralStrokeAccessibleSelected: brand[100],
  colorNeutralStroke1: grey[40],
  colorNeutralStroke1Hover: grey[46],
  colorNeutralStroke1Pressed: grey[42],
  colorNeutralStroke1Selected: grey[44],
  colorNeutralStroke2: grey[32],
  colorNeutralStroke3: grey[24],
  colorNeutralStrokeSubtle: grey[4],
  colorNeutralStrokeOnBrand: grey[16],
  colorNeutralStrokeOnBrand2: white,
  colorNeutralStrokeOnBrand2Hover: white,
  colorNeutralStrokeOnBrand2Pressed: white,
  colorNeutralStrokeOnBrand2Selected: white,
  colorBrandStroke1: brand[100],
  colorBrandStroke2: brand[50],
  colorBrandStroke2Hover: brand[50],
  colorBrandStroke2Pressed: brand[30],
  colorBrandStroke2Contrast: brand[50],
  colorCompoundBrandStroke: brand[90],
  colorCompoundBrandStrokeHover: brand[100],
  colorCompoundBrandStrokePressed: brand[80],
  colorNeutralStrokeDisabled: grey[26],
  colorNeutralStrokeInvertedDisabled: whiteAlpha[40],
  colorTransparentStroke: "transparent",
  colorTransparentStrokeInteractive: "transparent",
  colorTransparentStrokeDisabled: "transparent",
  colorNeutralStrokeAlpha: whiteAlpha[10],
  colorNeutralStrokeAlpha2: whiteAlpha[20],
  colorStrokeFocus1: black,
  colorStrokeFocus2: white,
  colorNeutralShadowAmbient: "rgba(0,0,0,0.24)",
  colorNeutralShadowKey: "rgba(0,0,0,0.28)",
  colorNeutralShadowAmbientLighter: "rgba(0,0,0,0.12)",
  colorNeutralShadowKeyLighter: "rgba(0,0,0,0.14)",
  colorNeutralShadowAmbientDarker: "rgba(0,0,0,0.40)",
  colorNeutralShadowKeyDarker: "rgba(0,0,0,0.48)",
  colorBrandShadowAmbient: "rgba(0,0,0,0.30)",
  colorBrandShadowKey: "rgba(0,0,0,0.25)"
});

// node_modules/@fluentui/tokens/lib/utils/createTeamsDarkTheme.js
var createTeamsDarkTheme = (brand) => {
  const colorTokens = generateColorTokens2(brand);
  return {
    ...borderRadius,
    ...fontSizes,
    ...lineHeights,
    ...fontFamilies,
    ...fontWeights,
    ...strokeWidths,
    ...horizontalSpacings,
    ...verticalSpacings,
    ...durations,
    ...curves,
    ...colorTokens,
    ...colorPaletteTokens2,
    ...colorStatusTokens2,
    ...createShadowTokens(colorTokens.colorNeutralShadowAmbient, colorTokens.colorNeutralShadowKey),
    ...createShadowTokens(colorTokens.colorBrandShadowAmbient, colorTokens.colorBrandShadowKey, "Brand")
  };
};

// node_modules/@fluentui/tokens/lib/themes/teams/darkTheme.js
var teamsDarkTheme = createTeamsDarkTheme(brandTeams);

// node_modules/@fluentui/tokens/lib/alias/highContrastColorPalette.js
var statusColorPaletteTokens3 = statusSharedColorNames.reduce((acc, sharedColor) => {
  const color = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
  const sharedColorTokens = {
    [`colorPalette${color}Background1`]: hcCanvas,
    [`colorPalette${color}Background2`]: hcCanvas,
    [`colorPalette${color}Background3`]: hcCanvasText,
    [`colorPalette${color}Foreground1`]: hcCanvasText,
    [`colorPalette${color}Foreground2`]: hcCanvasText,
    [`colorPalette${color}Foreground3`]: hcCanvasText,
    [`colorPalette${color}BorderActive`]: hcHighlight,
    [`colorPalette${color}Border1`]: hcCanvasText,
    [`colorPalette${color}Border2`]: hcCanvasText
  };
  return Object.assign(acc, sharedColorTokens);
}, {});
statusColorPaletteTokens3.colorPaletteRedForegroundInverted = hcCanvasText;
statusColorPaletteTokens3.colorPaletteGreenForegroundInverted = hcCanvasText;
statusColorPaletteTokens3.colorPaletteYellowForegroundInverted = hcCanvasText;
var personaColorPaletteTokens3 = personaSharedColorNames.reduce((acc, sharedColor) => {
  const color = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
  const sharedColorTokens = {
    [`colorPalette${color}Background2`]: hcCanvas,
    [`colorPalette${color}Foreground2`]: hcCanvasText,
    [`colorPalette${color}BorderActive`]: hcHighlight
  };
  return Object.assign(acc, sharedColorTokens);
}, {});
var colorPaletteTokens3 = {
  ...statusColorPaletteTokens3,
  ...personaColorPaletteTokens3
};
var colorStatusTokens3 = Object.entries(statusColorMapping).reduce((acc, [statusColor, sharedColor]) => {
  const color = statusColor.slice(0, 1).toUpperCase() + statusColor.slice(1);
  const statusColorTokens = {
    [`colorStatus${color}Background1`]: hcCanvas,
    [`colorStatus${color}Background2`]: hcCanvas,
    [`colorStatus${color}Background3`]: hcCanvasText,
    [`colorStatus${color}Foreground1`]: hcCanvasText,
    [`colorStatus${color}Foreground2`]: hcCanvasText,
    [`colorStatus${color}Foreground3`]: hcCanvasText,
    [`colorStatus${color}BorderActive`]: hcHighlight,
    [`colorStatus${color}ForegroundInverted`]: hcCanvasText,
    [`colorStatus${color}Border1`]: hcCanvasText,
    [`colorStatus${color}Border2`]: hcCanvasText
  };
  return Object.assign(acc, statusColorTokens);
}, {});

// node_modules/@fluentui/tokens/lib/alias/highContrastColor.js
var generateColorTokens3 = () => ({
  colorNeutralForeground1: hcCanvasText,
  colorNeutralForeground1Hover: hcHighlightText,
  colorNeutralForeground1Pressed: hcHighlightText,
  colorNeutralForeground1Selected: hcHighlightText,
  colorNeutralForeground2: hcCanvasText,
  colorNeutralForeground2Hover: hcHighlightText,
  colorNeutralForeground2Pressed: hcHighlightText,
  colorNeutralForeground2Selected: hcHighlightText,
  colorNeutralForeground2BrandHover: hcHighlightText,
  colorNeutralForeground2BrandPressed: hcHighlightText,
  colorNeutralForeground2BrandSelected: hcHighlightText,
  colorNeutralForeground3: hcCanvasText,
  colorNeutralForeground3Hover: hcHighlightText,
  colorNeutralForeground3Pressed: hcHighlightText,
  colorNeutralForeground3Selected: hcHighlightText,
  colorNeutralForeground3BrandHover: hcHighlightText,
  colorNeutralForeground3BrandPressed: hcHighlightText,
  colorNeutralForeground3BrandSelected: hcHighlightText,
  colorNeutralForeground4: hcCanvasText,
  colorNeutralForegroundDisabled: hcDisabled,
  colorNeutralForegroundInvertedDisabled: hcDisabled,
  colorBrandForegroundLink: hcHyperlink,
  colorBrandForegroundLinkHover: hcHyperlink,
  colorBrandForegroundLinkPressed: hcHyperlink,
  colorBrandForegroundLinkSelected: hcHyperlink,
  colorNeutralForeground2Link: hcHyperlink,
  colorNeutralForeground2LinkHover: hcHyperlink,
  colorNeutralForeground2LinkPressed: hcHyperlink,
  colorNeutralForeground2LinkSelected: hcHyperlink,
  colorCompoundBrandForeground1: hcHighlight,
  colorCompoundBrandForeground1Hover: hcHighlight,
  colorCompoundBrandForeground1Pressed: hcHighlight,
  colorBrandForeground1: hcCanvasText,
  colorBrandForeground2: hcCanvasText,
  colorBrandForeground2Hover: hcCanvasText,
  colorBrandForeground2Pressed: hcCanvasText,
  colorNeutralForeground1Static: hcCanvas,
  colorNeutralForegroundStaticInverted: hcCanvasText,
  colorNeutralForegroundInverted: hcHighlightText,
  colorNeutralForegroundInvertedHover: hcHighlightText,
  colorNeutralForegroundInvertedPressed: hcHighlightText,
  colorNeutralForegroundInvertedSelected: hcHighlightText,
  colorNeutralForegroundInverted2: hcCanvasText,
  colorNeutralForegroundOnBrand: hcButtonText,
  colorNeutralForegroundInvertedLink: hcHyperlink,
  colorNeutralForegroundInvertedLinkHover: hcHyperlink,
  colorNeutralForegroundInvertedLinkPressed: hcHyperlink,
  colorNeutralForegroundInvertedLinkSelected: hcHyperlink,
  colorBrandForegroundInverted: hcCanvasText,
  colorBrandForegroundInvertedHover: hcHighlightText,
  colorBrandForegroundInvertedPressed: hcHighlightText,
  colorBrandForegroundOnLight: hcButtonText,
  colorBrandForegroundOnLightHover: hcHighlightText,
  colorBrandForegroundOnLightPressed: hcHighlightText,
  colorBrandForegroundOnLightSelected: hcHighlightText,
  colorNeutralBackground1: hcCanvas,
  colorNeutralBackground1Hover: hcHighlight,
  colorNeutralBackground1Pressed: hcHighlight,
  colorNeutralBackground1Selected: hcHighlight,
  colorNeutralBackground2: hcCanvas,
  colorNeutralBackground2Hover: hcHighlight,
  colorNeutralBackground2Pressed: hcHighlight,
  colorNeutralBackground2Selected: hcHighlight,
  colorNeutralBackground3: hcCanvas,
  colorNeutralBackground3Hover: hcHighlight,
  colorNeutralBackground3Pressed: hcHighlight,
  colorNeutralBackground3Selected: hcHighlight,
  colorNeutralBackground4: hcCanvas,
  colorNeutralBackground4Hover: hcHighlight,
  colorNeutralBackground4Pressed: hcHighlight,
  colorNeutralBackground4Selected: hcHighlight,
  colorNeutralBackground5: hcCanvas,
  colorNeutralBackground5Hover: hcHighlight,
  colorNeutralBackground5Pressed: hcHighlight,
  colorNeutralBackground5Selected: hcHighlight,
  colorNeutralBackground6: hcCanvas,
  colorNeutralBackgroundInverted: hcCanvas,
  colorNeutralBackgroundStatic: hcCanvas,
  colorNeutralBackgroundAlpha: hcCanvas,
  colorNeutralBackgroundAlpha2: hcCanvas,
  colorSubtleBackground: "transparent",
  colorSubtleBackgroundHover: hcHighlight,
  colorSubtleBackgroundPressed: hcHighlight,
  colorSubtleBackgroundSelected: hcHighlight,
  colorSubtleBackgroundLightAlphaHover: hcHighlight,
  colorSubtleBackgroundLightAlphaPressed: hcHighlight,
  colorSubtleBackgroundLightAlphaSelected: hcHighlight,
  colorSubtleBackgroundInverted: "transparent",
  colorSubtleBackgroundInvertedHover: hcHighlight,
  colorSubtleBackgroundInvertedPressed: hcHighlight,
  colorSubtleBackgroundInvertedSelected: hcHighlight,
  colorTransparentBackground: "transparent",
  colorTransparentBackgroundHover: hcHighlight,
  colorTransparentBackgroundPressed: hcHighlight,
  colorTransparentBackgroundSelected: hcHighlight,
  colorNeutralBackgroundDisabled: hcCanvas,
  colorNeutralBackgroundInvertedDisabled: hcCanvas,
  colorNeutralStencil1: hcCanvasText,
  colorNeutralStencil2: hcCanvasText,
  colorNeutralStencil1Alpha: hcCanvasText,
  colorNeutralStencil2Alpha: hcCanvasText,
  colorBackgroundOverlay: blackAlpha[50],
  colorScrollbarOverlay: hcButtonFace,
  colorBrandBackground: hcButtonFace,
  colorBrandBackgroundHover: hcHighlight,
  colorBrandBackgroundPressed: hcHighlight,
  colorBrandBackgroundSelected: hcHighlight,
  colorCompoundBrandBackground: hcHighlight,
  colorCompoundBrandBackgroundHover: hcHighlight,
  colorCompoundBrandBackgroundPressed: hcHighlight,
  colorBrandBackgroundStatic: hcCanvas,
  colorBrandBackground2: hcCanvas,
  colorBrandBackground2Hover: hcCanvas,
  colorBrandBackground2Pressed: hcCanvas,
  colorBrandBackgroundInverted: hcButtonFace,
  colorBrandBackgroundInvertedHover: hcHighlight,
  colorBrandBackgroundInvertedPressed: hcHighlight,
  colorBrandBackgroundInvertedSelected: hcHighlight,
  colorNeutralStrokeAccessible: hcCanvasText,
  colorNeutralStrokeAccessibleHover: hcHighlight,
  colorNeutralStrokeAccessiblePressed: hcHighlight,
  colorNeutralStrokeAccessibleSelected: hcHighlight,
  colorNeutralStroke1: hcCanvasText,
  colorNeutralStroke1Hover: hcHighlight,
  colorNeutralStroke1Pressed: hcHighlight,
  colorNeutralStroke1Selected: hcHighlight,
  colorNeutralStroke2: hcCanvasText,
  colorNeutralStroke3: hcCanvasText,
  colorNeutralStrokeSubtle: hcCanvasText,
  colorNeutralStrokeOnBrand: hcCanvas,
  colorNeutralStrokeOnBrand2: hcCanvasText,
  colorNeutralStrokeOnBrand2Hover: hcCanvasText,
  colorNeutralStrokeOnBrand2Pressed: hcCanvasText,
  colorNeutralStrokeOnBrand2Selected: hcCanvasText,
  colorBrandStroke1: hcCanvasText,
  colorBrandStroke2: hcCanvasText,
  colorBrandStroke2Hover: hcHighlight,
  colorBrandStroke2Pressed: hcHighlight,
  colorBrandStroke2Contrast: hcCanvas,
  colorCompoundBrandStroke: hcHighlight,
  colorCompoundBrandStrokeHover: hcHighlight,
  colorCompoundBrandStrokePressed: hcHighlight,
  colorNeutralStrokeDisabled: hcDisabled,
  colorNeutralStrokeInvertedDisabled: hcDisabled,
  colorTransparentStroke: hcCanvasText,
  colorTransparentStrokeInteractive: hcHighlight,
  colorTransparentStrokeDisabled: hcDisabled,
  colorNeutralStrokeAlpha: hcCanvasText,
  colorNeutralStrokeAlpha2: hcCanvas,
  colorStrokeFocus1: hcCanvas,
  colorStrokeFocus2: hcHighlight,
  colorNeutralShadowAmbient: "rgba(0,0,0,0.24)",
  colorNeutralShadowKey: "rgba(0,0,0,0.28)",
  colorNeutralShadowAmbientLighter: "rgba(0,0,0,0.12)",
  colorNeutralShadowKeyLighter: "rgba(0,0,0,0.14)",
  colorNeutralShadowAmbientDarker: "rgba(0,0,0,0.40)",
  colorNeutralShadowKeyDarker: "rgba(0,0,0,0.48)",
  colorBrandShadowAmbient: "rgba(0,0,0,0.30)",
  colorBrandShadowKey: "rgba(0,0,0,0.25)"
});

// node_modules/@fluentui/tokens/lib/utils/createHighContrastTheme.js
var createHighContrastTheme = () => {
  const colorTokens = generateColorTokens3();
  return {
    ...borderRadius,
    ...fontSizes,
    ...lineHeights,
    ...fontFamilies,
    ...fontWeights,
    ...strokeWidths,
    ...horizontalSpacings,
    ...verticalSpacings,
    ...durations,
    ...curves,
    ...colorTokens,
    ...colorPaletteTokens3,
    ...colorStatusTokens3,
    ...createShadowTokens(colorTokens.colorNeutralShadowAmbient, colorTokens.colorNeutralShadowKey),
    ...createShadowTokens(colorTokens.colorBrandShadowAmbient, colorTokens.colorBrandShadowKey, "Brand")
  };
};

// node_modules/@fluentui/tokens/lib/themes/teams/highContrastTheme.js
var teamsHighContrastTheme = createHighContrastTheme();

// node_modules/@fluentui/tokens/lib/themes/web/lightTheme.js
var webLightTheme = createLightTheme(brandWeb);

// node_modules/@fluentui/tokens/lib/alias/darkColor.js
var generateColorTokens4 = (brand) => ({
  colorNeutralForeground1: white,
  colorNeutralForeground1Hover: white,
  colorNeutralForeground1Pressed: white,
  colorNeutralForeground1Selected: white,
  colorNeutralForeground2: grey[84],
  colorNeutralForeground2Hover: white,
  colorNeutralForeground2Pressed: white,
  colorNeutralForeground2Selected: white,
  colorNeutralForeground2BrandHover: brand[100],
  colorNeutralForeground2BrandPressed: brand[90],
  colorNeutralForeground2BrandSelected: brand[100],
  colorNeutralForeground3: grey[68],
  colorNeutralForeground3Hover: grey[84],
  colorNeutralForeground3Pressed: grey[84],
  colorNeutralForeground3Selected: grey[84],
  colorNeutralForeground3BrandHover: brand[100],
  colorNeutralForeground3BrandPressed: brand[90],
  colorNeutralForeground3BrandSelected: brand[100],
  colorNeutralForeground4: grey[60],
  colorNeutralForegroundDisabled: grey[36],
  colorNeutralForegroundInvertedDisabled: whiteAlpha[40],
  colorBrandForegroundLink: brand[100],
  colorBrandForegroundLinkHover: brand[110],
  colorBrandForegroundLinkPressed: brand[90],
  colorBrandForegroundLinkSelected: brand[100],
  colorNeutralForeground2Link: grey[84],
  colorNeutralForeground2LinkHover: white,
  colorNeutralForeground2LinkPressed: white,
  colorNeutralForeground2LinkSelected: white,
  colorCompoundBrandForeground1: brand[100],
  colorCompoundBrandForeground1Hover: brand[110],
  colorCompoundBrandForeground1Pressed: brand[90],
  colorBrandForeground1: brand[100],
  colorBrandForeground2: brand[110],
  colorBrandForeground2Hover: brand[130],
  colorBrandForeground2Pressed: brand[160],
  colorNeutralForeground1Static: grey[14],
  colorNeutralForegroundStaticInverted: white,
  colorNeutralForegroundInverted: grey[14],
  colorNeutralForegroundInvertedHover: grey[14],
  colorNeutralForegroundInvertedPressed: grey[14],
  colorNeutralForegroundInvertedSelected: grey[14],
  colorNeutralForegroundInverted2: grey[14],
  colorNeutralForegroundOnBrand: white,
  colorNeutralForegroundInvertedLink: white,
  colorNeutralForegroundInvertedLinkHover: white,
  colorNeutralForegroundInvertedLinkPressed: white,
  colorNeutralForegroundInvertedLinkSelected: white,
  colorBrandForegroundInverted: brand[80],
  colorBrandForegroundInvertedHover: brand[70],
  colorBrandForegroundInvertedPressed: brand[60],
  colorBrandForegroundOnLight: brand[80],
  colorBrandForegroundOnLightHover: brand[70],
  colorBrandForegroundOnLightPressed: brand[50],
  colorBrandForegroundOnLightSelected: brand[60],
  colorNeutralBackground1: grey[16],
  colorNeutralBackground1Hover: grey[24],
  colorNeutralBackground1Pressed: grey[12],
  colorNeutralBackground1Selected: grey[22],
  colorNeutralBackground2: grey[12],
  colorNeutralBackground2Hover: grey[20],
  colorNeutralBackground2Pressed: grey[8],
  colorNeutralBackground2Selected: grey[18],
  colorNeutralBackground3: grey[8],
  colorNeutralBackground3Hover: grey[16],
  colorNeutralBackground3Pressed: grey[4],
  colorNeutralBackground3Selected: grey[14],
  colorNeutralBackground4: grey[4],
  colorNeutralBackground4Hover: grey[12],
  colorNeutralBackground4Pressed: black,
  colorNeutralBackground4Selected: grey[10],
  colorNeutralBackground5: black,
  colorNeutralBackground5Hover: grey[8],
  colorNeutralBackground5Pressed: grey[2],
  colorNeutralBackground5Selected: grey[6],
  colorNeutralBackground6: grey[20],
  colorNeutralBackgroundInverted: white,
  colorNeutralBackgroundStatic: grey[24],
  colorNeutralBackgroundAlpha: grey10Alpha[50],
  colorNeutralBackgroundAlpha2: grey12Alpha[70],
  colorSubtleBackground: "transparent",
  colorSubtleBackgroundHover: grey[22],
  colorSubtleBackgroundPressed: grey[18],
  colorSubtleBackgroundSelected: grey[20],
  colorSubtleBackgroundLightAlphaHover: grey14Alpha[80],
  colorSubtleBackgroundLightAlphaPressed: grey14Alpha[50],
  colorSubtleBackgroundLightAlphaSelected: "transparent",
  colorSubtleBackgroundInverted: "transparent",
  colorSubtleBackgroundInvertedHover: blackAlpha[10],
  colorSubtleBackgroundInvertedPressed: blackAlpha[30],
  colorSubtleBackgroundInvertedSelected: blackAlpha[20],
  colorTransparentBackground: "transparent",
  colorTransparentBackgroundHover: "transparent",
  colorTransparentBackgroundPressed: "transparent",
  colorTransparentBackgroundSelected: "transparent",
  colorNeutralBackgroundDisabled: grey[8],
  colorNeutralBackgroundInvertedDisabled: whiteAlpha[10],
  colorNeutralStencil1: grey[34],
  colorNeutralStencil2: grey[20],
  colorNeutralStencil1Alpha: whiteAlpha[10],
  colorNeutralStencil2Alpha: whiteAlpha[5],
  colorBackgroundOverlay: blackAlpha[50],
  colorScrollbarOverlay: whiteAlpha[60],
  colorBrandBackground: brand[70],
  colorBrandBackgroundHover: brand[80],
  colorBrandBackgroundPressed: brand[40],
  colorBrandBackgroundSelected: brand[60],
  colorCompoundBrandBackground: brand[100],
  colorCompoundBrandBackgroundHover: brand[110],
  colorCompoundBrandBackgroundPressed: brand[90],
  colorBrandBackgroundStatic: brand[80],
  colorBrandBackground2: brand[20],
  colorBrandBackground2Hover: brand[40],
  colorBrandBackground2Pressed: brand[10],
  colorBrandBackgroundInverted: white,
  colorBrandBackgroundInvertedHover: brand[160],
  colorBrandBackgroundInvertedPressed: brand[140],
  colorBrandBackgroundInvertedSelected: brand[150],
  colorNeutralStrokeAccessible: grey[68],
  colorNeutralStrokeAccessibleHover: grey[74],
  colorNeutralStrokeAccessiblePressed: grey[70],
  colorNeutralStrokeAccessibleSelected: brand[100],
  colorNeutralStroke1: grey[40],
  colorNeutralStroke1Hover: grey[46],
  colorNeutralStroke1Pressed: grey[42],
  colorNeutralStroke1Selected: grey[44],
  colorNeutralStroke2: grey[32],
  colorNeutralStroke3: grey[24],
  colorNeutralStrokeSubtle: grey[4],
  colorNeutralStrokeOnBrand: grey[16],
  colorNeutralStrokeOnBrand2: white,
  colorNeutralStrokeOnBrand2Hover: white,
  colorNeutralStrokeOnBrand2Pressed: white,
  colorNeutralStrokeOnBrand2Selected: white,
  colorBrandStroke1: brand[100],
  colorBrandStroke2: brand[50],
  colorBrandStroke2Hover: brand[50],
  colorBrandStroke2Pressed: brand[30],
  colorBrandStroke2Contrast: brand[50],
  colorCompoundBrandStroke: brand[100],
  colorCompoundBrandStrokeHover: brand[110],
  colorCompoundBrandStrokePressed: brand[90],
  colorNeutralStrokeDisabled: grey[26],
  colorNeutralStrokeInvertedDisabled: whiteAlpha[40],
  colorTransparentStroke: "transparent",
  colorTransparentStrokeInteractive: "transparent",
  colorTransparentStrokeDisabled: "transparent",
  colorNeutralStrokeAlpha: whiteAlpha[10],
  colorNeutralStrokeAlpha2: whiteAlpha[20],
  colorStrokeFocus1: black,
  colorStrokeFocus2: white,
  colorNeutralShadowAmbient: "rgba(0,0,0,0.24)",
  colorNeutralShadowKey: "rgba(0,0,0,0.28)",
  colorNeutralShadowAmbientLighter: "rgba(0,0,0,0.12)",
  colorNeutralShadowKeyLighter: "rgba(0,0,0,0.14)",
  colorNeutralShadowAmbientDarker: "rgba(0,0,0,0.40)",
  colorNeutralShadowKeyDarker: "rgba(0,0,0,0.48)",
  colorBrandShadowAmbient: "rgba(0,0,0,0.30)",
  colorBrandShadowKey: "rgba(0,0,0,0.25)"
});

// node_modules/@fluentui/tokens/lib/utils/createDarkTheme.js
var createDarkTheme = (brand) => {
  const colorTokens = generateColorTokens4(brand);
  return {
    ...borderRadius,
    ...fontSizes,
    ...lineHeights,
    ...fontFamilies,
    ...fontWeights,
    ...strokeWidths,
    ...horizontalSpacings,
    ...verticalSpacings,
    ...durations,
    ...curves,
    ...colorTokens,
    ...colorPaletteTokens2,
    ...colorStatusTokens2,
    ...createShadowTokens(colorTokens.colorNeutralShadowAmbient, colorTokens.colorNeutralShadowKey),
    ...createShadowTokens(colorTokens.colorBrandShadowAmbient, colorTokens.colorBrandShadowKey, "Brand")
  };
};

// node_modules/@fluentui/tokens/lib/themes/web/darkTheme.js
var webDarkTheme = createDarkTheme(brandWeb);

// node_modules/@fluentui/tokens/lib/themeToTokensObject.js
function themeToTokensObject(theme) {
  const tokens2 = {};
  const keys = Object.keys(theme);
  for (const key of keys) {
    tokens2[key] = `var(--${String(key)})`;
  }
  return tokens2;
}

// node_modules/@fluentui/react-table/lib/components/TableResizeHandle/useTableResizeHandleStyles.styles.js
var tableResizeHandleClassNames = {
  root: "fui-TableResizeHandle"
};
var useStyles = __styles({
  root: {
    qhf8xq: "f1euv43f",
    j35jbq: ["f1e31b4d", "f1vgc2s3"],
    Bhzewxz: "f15twtuk",
    B5kzvoi: "f1yab3r1",
    a9b677: "fjw5fx7",
    B6of3ja: "f1hu3pq6",
    t21cq0: ["fn2i5td", "f1eybr6b"],
    jrapky: "f19f4twv",
    Frg6f3: ["f1eybr6b", "fn2i5td"],
    Bceei9c: "fc3en1c",
    abs64n: "fk73vx1",
    Bmy1vo4: "f13u1uyl",
    B3o57yi: "fezquic",
    Bj3rh1h: "f19g0ac",
    B3cna0y: "f1tkae59",
    Brovlpu: "ftqa4ok",
    B7zu5sd: "f15pjodv",
    Bs6t6z0: "ftgrb5f",
    Fdvyjd: "f2df6js",
    Biobvvw: "fshsryb",
    Hdbjpj: "f11ef69",
    jc51t6: ["f12lb1dx", "f13tbxeo"],
    u6d25: "fu4ulse",
    Bj55yzk: "fw2wsqs",
    Bkbwdz4: "f1swzn7y"
  }
}, {
  d: [".f1euv43f{position:absolute;}", ".f1e31b4d{right:0;}", ".f1vgc2s3{left:0;}", ".f15twtuk{top:0;}", ".f1yab3r1{bottom:0;}", ".fjw5fx7{width:16px;}", ".f1hu3pq6{margin-top:0;}", ".fn2i5td{margin-right:-8px;}", ".f1eybr6b{margin-left:-8px;}", ".f19f4twv{margin-bottom:0;}", ".fc3en1c{cursor:col-resize;}", ".fk73vx1{opacity:0;}", ".f13u1uyl{transition-property:opacity;}", ".fezquic{transition-duration:.2s;}", ".f19g0ac{z-index:1;}", '.ftgrb5f:after{content:" ";}', ".f2df6js:after{display:block;}", ".fshsryb:after{width:1px;}", ".f11ef69:after{position:absolute;}", ".f12lb1dx:after{left:50%;}", ".f13tbxeo:after{right:50%;}", ".fu4ulse:after{top:0;}", ".fw2wsqs:after{bottom:0;}", ".f1swzn7y:after{background-color:var(--colorNeutralStroke1);}"],
  f: [".f1tkae59:focus{opacity:1;}", ".ftqa4ok:focus{outline-style:none;}"],
  h: [".f15pjodv:hover{opacity:1;}"]
});
var useTableResizeHandleStyles_unstable = (state) => {
  const styles = useStyles();
  state.root.className = mergeClasses(tableResizeHandleClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-shared-contexts/lib/ThemeContext/ThemeContext.js
var React36 = __toESM(require_react());
var ThemeContext = React36.createContext(void 0);
var ThemeProvider = ThemeContext.Provider;

// node_modules/@fluentui/react-shared-contexts/lib/ThemeClassNameContext/ThemeClassNameContext.js
var React37 = __toESM(require_react());
var ThemeClassNameContext = React37.createContext(void 0);
var themeClassNameContextDefaultVaue = "";
var ThemeClassNameProvider = ThemeClassNameContext.Provider;
function useThemeClassName() {
  var _React_useContext;
  return (_React_useContext = React37.useContext(ThemeClassNameContext)) !== null && _React_useContext !== void 0 ? _React_useContext : themeClassNameContextDefaultVaue;
}

// node_modules/@fluentui/react-shared-contexts/lib/TooltipVisibilityContext/TooltipContext.js
var React38 = __toESM(require_react());
var TooltipVisibilityContext = React38.createContext(void 0);
var tooltipVisibilityContextDefaultValue = {};
var TooltipVisibilityProvider = TooltipVisibilityContext.Provider;
function useTooltipVisibility() {
  var _React_useContext;
  return (_React_useContext = React38.useContext(TooltipVisibilityContext)) !== null && _React_useContext !== void 0 ? _React_useContext : tooltipVisibilityContextDefaultValue;
}

// node_modules/@fluentui/react-shared-contexts/lib/ProviderContext/ProviderContext.js
var React39 = __toESM(require_react());
var ProviderContext = React39.createContext(void 0);
var providerContextDefaultValue = {
  targetDocument: typeof document === "object" ? document : void 0,
  dir: "ltr"
};
var Provider = ProviderContext.Provider;
function useFluent() {
  var _React_useContext;
  return (_React_useContext = React39.useContext(ProviderContext)) !== null && _React_useContext !== void 0 ? _React_useContext : providerContextDefaultValue;
}

// node_modules/@fluentui/react-shared-contexts/lib/OverridesContext/OverridesContext.js
var React40 = __toESM(require_react());
var OverridesContext = React40.createContext(void 0);
var OverridesProvider = OverridesContext.Provider;
function useOverrides() {
  var _React_useContext;
  return (_React_useContext = React40.useContext(OverridesContext)) !== null && _React_useContext !== void 0 ? _React_useContext : {};
}

// node_modules/@fluentui/react-shared-contexts/lib/CustomStyleHooksContext/CustomStyleHooksContext.js
var React41 = __toESM(require_react());
var CustomStyleHooksContext = React41.createContext(void 0);
var noop3 = () => {
};
var CustomStyleHooksProvider = CustomStyleHooksContext.Provider;
var useCustomStyleHook = (hook) => {
  var _React_useContext;
  var _React_useContext_hook;
  return (_React_useContext_hook = (_React_useContext = React41.useContext(CustomStyleHooksContext)) === null || _React_useContext === void 0 ? void 0 : _React_useContext[hook]) !== null && _React_useContext_hook !== void 0 ? _React_useContext_hook : noop3;
};

// node_modules/@fluentui/react-shared-contexts/lib/BackgroundAppearanceContext/BackgroundAppearanceContext.js
var React42 = __toESM(require_react());
var BackgroundAppearanceContext = React42.createContext(void 0);
var BackgroundAppearanceProvider = BackgroundAppearanceContext.Provider;
function useBackgroundAppearance() {
  return React42.useContext(BackgroundAppearanceContext);
}

// node_modules/@fluentui/react-shared-contexts/lib/PortalMountNodeContext.js
var React43 = __toESM(require_react());
var PortalMountNodeContext = React43.createContext(void 0);
var PortalMountNodeProvider = PortalMountNodeContext.Provider;
function usePortalMountNode() {
  return React43.useContext(PortalMountNodeContext);
}

// node_modules/@fluentui/react-shared-contexts/lib/AnnounceContext/AnnounceContext.js
var React44 = __toESM(require_react());
var AnnounceContext = React44.createContext(void 0);
var AnnounceProvider = AnnounceContext.Provider;
function useAnnounce() {
  var _React_useContext;
  return (_React_useContext = React44.useContext(AnnounceContext)) !== null && _React_useContext !== void 0 ? _React_useContext : {
    announce: () => void 0
  };
}

// node_modules/@fluentui/react-table/lib/components/TableResizeHandle/TableResizeHandle.js
var TableResizeHandle = React45.forwardRef((props, ref) => {
  const state = useTableResizeHandle_unstable(props, ref);
  useTableResizeHandleStyles_unstable(state);
  useCustomStyleHook("useTableResizeHandleStyles_unstable")(state);
  return renderTableResizeHandle_unstable(state);
});
TableResizeHandle.displayName = "TableResizeHandle";

// node_modules/@fluentui/react-table/lib/hooks/useMeasureElement.js
var React46 = __toESM(require_react());
function useMeasureElement() {
  const [width, setWidth] = React46.useState(0);
  const container = React46.useRef(void 0);
  const { targetDocument } = useFluent();
  const handleResize = React46.useCallback(() => {
    var _container_current;
    const containerWidth = (_container_current = container.current) === null || _container_current === void 0 ? void 0 : _container_current.getBoundingClientRect().width;
    setWidth(containerWidth || 0);
  }, []);
  const [resizeObserver] = React46.useState(() => createResizeObserverFromDocument(targetDocument, handleResize));
  const measureElementRef = React46.useCallback((el) => {
    if (!targetDocument || !resizeObserver) {
      return;
    }
    if (container.current) {
      resizeObserver.unobserve(container.current);
    }
    container.current = void 0;
    if (el === null || el === void 0 ? void 0 : el.parentElement) {
      container.current = el.parentElement;
      resizeObserver.observe(container.current);
      handleResize();
    }
  }, [
    targetDocument,
    resizeObserver,
    handleResize
  ]);
  React46.useEffect(() => {
    return () => resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.disconnect();
  }, [
    resizeObserver
  ]);
  return {
    width,
    measureElementRef
  };
}
function createResizeObserverFromDocument(targetDocument, callback) {
  var _targetDocument_defaultView;
  if (!(targetDocument === null || targetDocument === void 0 ? void 0 : (_targetDocument_defaultView = targetDocument.defaultView) === null || _targetDocument_defaultView === void 0 ? void 0 : _targetDocument_defaultView.ResizeObserver)) {
    return null;
  }
  return new targetDocument.defaultView.ResizeObserver(callback);
}

// node_modules/@fluentui/react-table/lib/hooks/useTableColumnResizeMouseHandler.js
var React47 = __toESM(require_react());
function useTableColumnResizeMouseHandler(columnResizeState) {
  const mouseX = React47.useRef(0);
  const currentWidth = React47.useRef(0);
  const colId = React47.useRef(void 0);
  const { targetDocument } = useFluent();
  const globalWin = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
  const recalculatePosition = React47.useCallback((e2) => {
    const { clientX } = getEventClientCoords(e2);
    const dx = clientX - mouseX.current;
    currentWidth.current += dx;
    colId.current && columnResizeState.setColumnWidth(e2, {
      columnId: colId.current,
      width: currentWidth.current
    });
    mouseX.current = clientX;
  }, [
    columnResizeState
  ]);
  const onDrag = React47.useCallback((e2) => {
    if (typeof (globalWin === null || globalWin === void 0 ? void 0 : globalWin.requestAnimationFrame) === "function") {
      requestAnimationFrame(() => recalculatePosition(e2));
    } else {
      recalculatePosition(e2);
    }
  }, [
    globalWin === null || globalWin === void 0 ? void 0 : globalWin.requestAnimationFrame,
    recalculatePosition
  ]);
  const onDragEnd = React47.useCallback((event) => {
    if (isMouseEvent(event)) {
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener("mouseup", onDragEnd);
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener("mousemove", onDrag);
    }
    if (isTouchEvent(event)) {
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener("touchend", onDragEnd);
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener("touchmove", onDrag);
    }
  }, [
    onDrag,
    targetDocument
  ]);
  const getOnMouseDown = (columnId) => (event) => {
    currentWidth.current = columnResizeState.getColumnWidth(columnId);
    mouseX.current = getEventClientCoords(event).clientX;
    colId.current = columnId;
    if (isMouseEvent(event)) {
      if (event.target !== event.currentTarget || event.button !== 0) {
        return;
      }
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener("mouseup", onDragEnd);
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener("mousemove", onDrag);
    }
    if (isTouchEvent(event)) {
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener("touchend", onDragEnd);
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener("touchmove", onDrag);
    }
  };
  return {
    getOnMouseDown: (columnId) => getOnMouseDown(columnId)
  };
}

// node_modules/@fluentui/react-table/lib/hooks/useTableColumnResizeState.js
var React48 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/utils/columnResizeUtils.js
var DEFAULT_WIDTH = 150;
var DEFAULT_MIN_WIDTH = 100;
function columnDefinitionsToState(columns, state = [], columnSizingOptions = {}) {
  let updated = false;
  const stateMap = new Map(state.map((s3) => [
    s3.columnId,
    s3
  ]));
  const updatedState = columns.map((column) => {
    const existingColumnState = stateMap.get(column.columnId);
    if (existingColumnState) {
      var _columnSizingOptions_column_columnId;
      const { idealWidth: idealWidth2 = existingColumnState.idealWidth, minWidth: minWidth2 = existingColumnState.minWidth, padding: padding2 = existingColumnState.padding } = (_columnSizingOptions_column_columnId = columnSizingOptions[column.columnId]) !== null && _columnSizingOptions_column_columnId !== void 0 ? _columnSizingOptions_column_columnId : {};
      if (idealWidth2 !== existingColumnState.idealWidth || minWidth2 !== existingColumnState.minWidth || padding2 !== existingColumnState.padding) {
        updated = true;
        return {
          ...existingColumnState,
          idealWidth: idealWidth2,
          width: idealWidth2,
          minWidth: minWidth2,
          padding: padding2
        };
      }
      return existingColumnState;
    }
    var _columnSizingOptions_column_columnId1;
    const { defaultWidth, idealWidth = DEFAULT_WIDTH, minWidth = DEFAULT_MIN_WIDTH, padding } = (_columnSizingOptions_column_columnId1 = columnSizingOptions[column.columnId]) !== null && _columnSizingOptions_column_columnId1 !== void 0 ? _columnSizingOptions_column_columnId1 : {};
    updated = true;
    return {
      columnId: column.columnId,
      width: Math.max(defaultWidth !== null && defaultWidth !== void 0 ? defaultWidth : idealWidth, minWidth),
      minWidth,
      idealWidth: Math.max(defaultWidth !== null && defaultWidth !== void 0 ? defaultWidth : idealWidth, minWidth),
      padding: padding !== null && padding !== void 0 ? padding : 16
    };
  });
  if (updatedState.length !== state.length || updated) {
    const column = updatedState.find((col) => col.width > col.idealWidth);
    if (column) {
      column.width = column.idealWidth;
    }
    updated = true;
  }
  return updated ? updatedState : state;
}
function getColumnById(state, columnId) {
  return state.find((c3) => c3.columnId === columnId);
}
function getColumnByIndex(state, index) {
  return state[index];
}
function getTotalWidth(state) {
  return state.reduce((sum, column) => sum + column.width + column.padding, 0);
}
function getColumnWidth(state, columnId) {
  const column = getColumnById(state, columnId);
  var _column_width;
  return (_column_width = column === null || column === void 0 ? void 0 : column.width) !== null && _column_width !== void 0 ? _column_width : 0;
}
function setColumnProperty(localState, columnId, property, value) {
  const currentColumn = getColumnById(localState, columnId);
  if (!currentColumn || (currentColumn === null || currentColumn === void 0 ? void 0 : currentColumn[property]) === value) {
    return localState;
  }
  const updatedColumn = {
    ...currentColumn,
    [property]: value
  };
  const newState = localState.reduce((acc, current) => {
    if (current.columnId === updatedColumn.columnId) {
      return [
        ...acc,
        updatedColumn
      ];
    }
    return [
      ...acc,
      current
    ];
  }, []);
  return newState;
}
function adjustColumnWidthsToFitContainer(state, containerWidth) {
  let newState = state;
  const totalWidth = getTotalWidth(newState);
  if (totalWidth < containerWidth) {
    let difference = containerWidth - totalWidth;
    let i3 = 0;
    while (i3 < newState.length && difference > 0) {
      const currentCol = getColumnByIndex(newState, i3);
      const colAdjustment = Math.min(currentCol.idealWidth - currentCol.width, difference);
      newState = setColumnProperty(newState, currentCol.columnId, "width", currentCol.width + colAdjustment);
      difference -= colAdjustment;
      if (i3 === newState.length - 1 && difference !== 0) {
        const lastCol = getColumnByIndex(newState, i3);
        newState = setColumnProperty(newState, lastCol.columnId, "width", lastCol.width + difference);
      }
      i3++;
    }
  } else if (totalWidth >= containerWidth) {
    let difference = totalWidth - containerWidth;
    let j2 = newState.length - 1;
    while (j2 >= 0 && difference > 0) {
      const currentCol = getColumnByIndex(newState, j2);
      if (currentCol.width > currentCol.minWidth) {
        const colAdjustment = Math.min(currentCol.width - currentCol.minWidth, difference);
        difference -= colAdjustment;
        newState = setColumnProperty(newState, currentCol.columnId, "width", currentCol.width - colAdjustment);
      }
      j2--;
    }
  }
  return newState;
}

// node_modules/@fluentui/react-table/lib/hooks/useTableColumnResizeState.js
var createReducer = () => (state, action) => {
  switch (action.type) {
    case "CONTAINER_WIDTH_UPDATED":
      return {
        ...state,
        containerWidth: action.containerWidth,
        columnWidthState: adjustColumnWidthsToFitContainer(state.columnWidthState, action.containerWidth)
      };
    case "COLUMNS_UPDATED":
      const newS = columnDefinitionsToState(action.columns, state.columnWidthState, state.columnSizingOptions);
      return {
        ...state,
        columns: action.columns,
        columnWidthState: adjustColumnWidthsToFitContainer(newS, state.containerWidth)
      };
    case "COLUMN_SIZING_OPTIONS_UPDATED":
      const newState = columnDefinitionsToState(state.columns, state.columnWidthState, action.columnSizingOptions);
      return {
        ...state,
        columnSizingOptions: action.columnSizingOptions,
        columnWidthState: adjustColumnWidthsToFitContainer(newState, state.containerWidth)
      };
    case "SET_COLUMN_WIDTH":
      const { columnId, width } = action;
      const { containerWidth } = state;
      const column = getColumnById(state.columnWidthState, columnId);
      let newColumnWidthState = [
        ...state.columnWidthState
      ];
      if (!column) {
        return state;
      }
      newColumnWidthState = setColumnProperty(newColumnWidthState, columnId, "width", width);
      newColumnWidthState = setColumnProperty(newColumnWidthState, columnId, "idealWidth", width);
      newColumnWidthState = adjustColumnWidthsToFitContainer(newColumnWidthState, containerWidth);
      return {
        ...state,
        columnWidthState: newColumnWidthState
      };
  }
};
function useTableColumnResizeState(columns, containerWidth, params = {}) {
  const { onColumnResize, columnSizingOptions } = params;
  const reducer = React48.useMemo(() => createReducer(), []);
  const [state, dispatch] = React48.useReducer(reducer, {
    columns,
    containerWidth: 0,
    columnWidthState: columnDefinitionsToState(columns, void 0, columnSizingOptions),
    columnSizingOptions
  });
  useIsomorphicLayoutEffect(() => {
    dispatch({
      type: "CONTAINER_WIDTH_UPDATED",
      containerWidth
    });
  }, [
    containerWidth
  ]);
  useIsomorphicLayoutEffect(() => {
    dispatch({
      type: "COLUMNS_UPDATED",
      columns
    });
  }, [
    columns
  ]);
  useIsomorphicLayoutEffect(() => {
    dispatch({
      type: "COLUMN_SIZING_OPTIONS_UPDATED",
      columnSizingOptions
    });
  }, [
    columnSizingOptions
  ]);
  const setColumnWidth = useEventCallback((event, data) => {
    let { width } = data;
    const { columnId } = data;
    const col = getColumnById(state.columnWidthState, columnId);
    if (!col) {
      return;
    }
    width = Math.max(col.minWidth || 0, width);
    if (onColumnResize) {
      onColumnResize(event, {
        columnId,
        width
      });
    }
    dispatch({
      type: "SET_COLUMN_WIDTH",
      columnId,
      width
    });
  });
  return {
    getColumnById: (colId) => getColumnById(state.columnWidthState, colId),
    getColumns: () => state.columnWidthState,
    getColumnWidth: (colId) => getColumnWidth(state.columnWidthState, colId),
    setColumnWidth
  };
}

// node_modules/@fluentui/react-table/lib/hooks/useKeyboardResizing.js
var React55 = __toESM(require_react());

// node_modules/@fluentui/keyboard-keys/lib/keyCodes.js
var keyCodes_exports = {};
__export(keyCodes_exports, {
  A: () => A,
  Accept: () => Accept,
  Alt: () => Alt,
  AltGraph: () => AltGraph,
  Ampersand: () => Ampersand,
  ArrowDown: () => ArrowDown,
  ArrowLeft: () => ArrowLeft,
  ArrowRight: () => ArrowRight,
  ArrowUp: () => ArrowUp,
  AtSign: () => AtSign,
  Attn: () => Attn,
  B: () => B,
  BackSlash: () => BackSlash,
  Backspace: () => Backspace,
  C: () => C,
  Cancel: () => Cancel,
  CapsLock: () => CapsLock,
  Caret: () => Caret,
  Clear: () => Clear,
  Comma: () => Comma,
  ContextMenu: () => ContextMenu,
  Control: () => Control,
  Convert: () => Convert,
  CrSel: () => CrSel,
  D: () => D,
  Decimal: () => Decimal,
  Delete: () => Delete,
  Digit0: () => Digit0,
  Digit1: () => Digit1,
  Digit2: () => Digit2,
  Digit3: () => Digit3,
  Digit4: () => Digit4,
  Digit5: () => Digit5,
  Digit6: () => Digit6,
  Digit7: () => Digit7,
  Digit8: () => Digit8,
  Digit9: () => Digit9,
  DollarSign: () => DollarSign,
  DoubleQuote: () => DoubleQuote,
  E: () => E,
  End: () => End,
  Enter: () => Enter,
  EqualsSign: () => EqualsSign,
  EraseEof: () => EraseEof,
  Escape: () => Escape,
  ExSel: () => ExSel,
  ExclamationPoint: () => ExclamationPoint,
  Execute: () => Execute,
  F: () => F,
  F1: () => F1,
  F10: () => F10,
  F11: () => F11,
  F12: () => F12,
  F13: () => F13,
  F14: () => F14,
  F15: () => F15,
  F16: () => F16,
  F17: () => F17,
  F18: () => F18,
  F19: () => F19,
  F2: () => F2,
  F20: () => F20,
  F21: () => F21,
  F22: () => F22,
  F23: () => F23,
  F24: () => F24,
  F3: () => F3,
  F4: () => F4,
  F5: () => F5,
  F6: () => F6,
  F7: () => F7,
  F8: () => F8,
  F9: () => F9,
  ForwardSlash: () => ForwardSlash,
  G: () => G,
  GraveAccent: () => GraveAccent,
  H: () => H,
  Help: () => Help,
  Home: () => Home,
  I: () => I,
  Insert: () => Insert,
  J: () => J,
  K: () => K,
  L: () => L,
  LeftAngleBracket: () => LeftAngleBracket,
  LeftCurlyBrace: () => LeftCurlyBrace,
  LeftParenthesis: () => LeftParenthesis,
  LeftSquareBracket: () => LeftSquareBracket,
  M: () => M,
  Meta: () => Meta,
  MinusSign: () => MinusSign,
  ModeChange: () => ModeChange,
  MultiplicationSign: () => MultiplicationSign,
  N: () => N,
  NonConvert: () => NonConvert,
  NumLock: () => NumLock,
  O: () => O,
  OS: () => OS,
  P: () => P,
  PageDown: () => PageDown,
  PageUp: () => PageUp,
  Pause: () => Pause,
  PercentSign: () => PercentSign,
  Pipe: () => Pipe,
  Play: () => Play,
  PlusSign: () => PlusSign,
  PoundSign: () => PoundSign,
  Print: () => Print,
  PrintScreen: () => PrintScreen,
  Q: () => Q,
  QuestionMark: () => QuestionMark,
  R: () => R,
  RightAngleBracket: () => RightAngleBracket,
  RightCurlyBrace: () => RightCurlyBrace,
  RightParenthesis: () => RightParenthesis,
  RightSquareBracket: () => RightSquareBracket,
  S: () => S,
  ScrollLock: () => ScrollLock,
  Select: () => Select,
  Semicolon: () => Semicolon,
  Shift: () => Shift,
  SingleQuote: () => SingleQuote,
  Space: () => Space,
  T: () => T,
  Tab: () => Tab,
  Tilde: () => Tilde,
  U: () => U,
  Underscore: () => Underscore,
  V: () => V,
  VolumeDown: () => VolumeDown,
  VolumeMute: () => VolumeMute,
  VolumeUp: () => VolumeUp,
  W: () => W,
  X: () => X,
  Y: () => Y,
  Z: () => Z,
  ZoomOut: () => ZoomOut,
  a: () => a,
  b: () => b,
  c: () => c,
  d: () => d,
  e: () => e,
  f: () => f,
  g: () => g,
  h: () => h,
  i: () => i,
  j: () => j,
  k: () => k,
  l: () => l,
  m: () => m,
  n: () => n,
  o: () => o,
  p: () => p,
  q: () => q,
  r: () => r,
  s: () => s,
  t: () => t,
  u: () => u,
  v: () => v,
  w: () => w,
  x: () => x,
  y: () => y,
  z: () => z
});
var Cancel = 3;
var Help = 6;
var Backspace = 8;
var Tab = 9;
var Clear = 12;
var Enter = 13;
var Shift = 16;
var Control = 17;
var Alt = 18;
var Pause = 19;
var CapsLock = 20;
var Escape = 27;
var Convert = 28;
var NonConvert = 29;
var Accept = 30;
var ModeChange = 31;
var Space = 32;
var PageUp = 33;
var PageDown = 34;
var End = 35;
var Home = 36;
var ArrowLeft = 37;
var ArrowUp = 38;
var ArrowRight = 39;
var ArrowDown = 40;
var Select = 41;
var Print = 42;
var Execute = 43;
var PrintScreen = 44;
var Insert = 45;
var Delete = 46;
var Digit0 = 48;
var RightParenthesis = 48;
var Digit1 = 49;
var ExclamationPoint = 49;
var Digit2 = 50;
var AtSign = 50;
var Digit3 = 51;
var PoundSign = 51;
var Digit4 = 52;
var DollarSign = 52;
var Digit5 = 53;
var PercentSign = 53;
var Digit6 = 54;
var Caret = 54;
var Digit7 = 55;
var Ampersand = 55;
var Digit8 = 56;
var MultiplicationSign = 56;
var Digit9 = 57;
var LeftParenthesis = 57;
var a = 65;
var A = 65;
var b = 66;
var B = 66;
var c = 67;
var C = 67;
var d = 68;
var D = 68;
var e = 69;
var E = 69;
var f = 70;
var F = 70;
var g = 71;
var G = 71;
var h = 72;
var H = 72;
var i = 73;
var I = 73;
var j = 74;
var J = 74;
var k = 75;
var K = 75;
var l = 76;
var L = 76;
var m = 77;
var M = 77;
var n = 78;
var N = 78;
var o = 79;
var O = 79;
var p = 80;
var P = 80;
var q = 81;
var Q = 81;
var r = 82;
var R = 82;
var s = 83;
var S = 83;
var t = 84;
var T = 84;
var u = 85;
var U = 85;
var v = 86;
var V = 86;
var w = 87;
var W = 87;
var x = 88;
var X = 88;
var y = 89;
var Y = 89;
var z = 90;
var Z = 90;
var OS = 91;
var ContextMenu = 93;
var F1 = 112;
var F2 = 113;
var F3 = 114;
var F4 = 115;
var F5 = 116;
var F6 = 117;
var F7 = 118;
var F8 = 119;
var F9 = 120;
var F10 = 121;
var F11 = 122;
var F12 = 123;
var F13 = 124;
var F14 = 125;
var F15 = 126;
var F16 = 127;
var F17 = 128;
var F18 = 129;
var F19 = 130;
var F20 = 131;
var F21 = 132;
var F22 = 133;
var F23 = 134;
var F24 = 135;
var NumLock = 144;
var ScrollLock = 145;
var VolumeMute = 181;
var VolumeDown = 182;
var VolumeUp = 183;
var Semicolon = 186;
var EqualsSign = 187;
var PlusSign = 187;
var Comma = 188;
var LeftAngleBracket = 188;
var MinusSign = 189;
var Underscore = 189;
var Decimal = 190;
var RightAngleBracket = 190;
var ForwardSlash = 191;
var QuestionMark = 191;
var GraveAccent = 192;
var Tilde = 192;
var LeftSquareBracket = 219;
var LeftCurlyBrace = 219;
var BackSlash = 220;
var Pipe = 220;
var RightSquareBracket = 221;
var RightCurlyBrace = 221;
var SingleQuote = 222;
var DoubleQuote = 222;
var Meta = 224;
var AltGraph = 225;
var Attn = 246;
var CrSel = 247;
var ExSel = 248;
var EraseEof = 249;
var Play = 250;
var ZoomOut = 251;

// node_modules/@fluentui/keyboard-keys/lib/keys.js
var Shift2 = "Shift";
var Enter2 = "Enter";
var Space2 = " ";
var Tab2 = "Tab";
var ArrowDown2 = "ArrowDown";
var ArrowLeft2 = "ArrowLeft";
var ArrowRight2 = "ArrowRight";
var ArrowUp2 = "ArrowUp";
var End2 = "End";
var Home2 = "Home";
var PageDown2 = "PageDown";
var PageUp2 = "PageUp";
var Backspace2 = "Backspace";
var Delete2 = "Delete";
var Escape2 = "Escape";

// node_modules/keyborg/dist/keyborg.esm.js
var _canUseWeakRef = typeof WeakRef !== "undefined";
var WeakRefInstance = class {
  constructor(instance) {
    if (_canUseWeakRef && typeof instance === "object") {
      this._weakRef = new WeakRef(instance);
    } else {
      this._instance = instance;
    }
  }
  /**
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef/deref}
   */
  deref() {
    var _a, _b, _c;
    let instance;
    if (this._weakRef) {
      instance = (_a = this._weakRef) === null || _a === void 0 ? void 0 : _a.deref();
      if (!instance) {
        delete this._weakRef;
      }
    } else {
      instance = this._instance;
      if ((_c = (_b = instance) === null || _b === void 0 ? void 0 : _b.isDisposed) === null || _c === void 0 ? void 0 : _c.call(_b)) {
        delete this._instance;
      }
    }
    return instance;
  }
};
var KEYBORG_FOCUSIN = "keyborg:focusin";
function canOverrideNativeFocus(win) {
  const HTMLElement2 = win.HTMLElement;
  const origFocus = HTMLElement2.prototype.focus;
  let isCustomFocusCalled = false;
  HTMLElement2.prototype.focus = function focus() {
    isCustomFocusCalled = true;
  };
  const btn = win.document.createElement("button");
  btn.focus();
  HTMLElement2.prototype.focus = origFocus;
  return isCustomFocusCalled;
}
var _canOverrideNativeFocus = false;
function nativeFocus(element) {
  const focus = element.focus;
  if (focus.__keyborgNativeFocus) {
    focus.__keyborgNativeFocus.call(element);
  } else {
    element.focus();
  }
}
function setupFocusEvent(win) {
  const kwin = win;
  if (!_canOverrideNativeFocus) {
    _canOverrideNativeFocus = canOverrideNativeFocus(kwin);
  }
  const origFocus = kwin.HTMLElement.prototype.focus;
  if (origFocus.__keyborgNativeFocus) {
    return;
  }
  kwin.HTMLElement.prototype.focus = focus;
  const data = kwin.__keyborgData = {
    focusInHandler: (e2) => {
      var _a;
      const target = e2.target;
      if (!target) {
        return;
      }
      const event = document.createEvent("HTMLEvents");
      event.initEvent(KEYBORG_FOCUSIN, true, true);
      const details = {
        relatedTarget: e2.relatedTarget || void 0
      };
      if (_canOverrideNativeFocus || data.lastFocusedProgrammatically) {
        details.isFocusedProgrammatically = target === ((_a = data.lastFocusedProgrammatically) === null || _a === void 0 ? void 0 : _a.deref());
        data.lastFocusedProgrammatically = void 0;
      }
      event.details = details;
      target.dispatchEvent(event);
    }
  };
  kwin.document.addEventListener("focusin", kwin.__keyborgData.focusInHandler, true);
  function focus() {
    const keyborgNativeFocusEvent = kwin.__keyborgData;
    if (keyborgNativeFocusEvent) {
      keyborgNativeFocusEvent.lastFocusedProgrammatically = new WeakRefInstance(this);
    }
    return origFocus.apply(this, arguments);
  }
  focus.__keyborgNativeFocus = origFocus;
}
function disposeFocusEvent(win) {
  const kwin = win;
  const proto = kwin.HTMLElement.prototype;
  const origFocus = proto.focus.__keyborgNativeFocus;
  const keyborgNativeFocusEvent = kwin.__keyborgData;
  if (keyborgNativeFocusEvent) {
    kwin.document.removeEventListener("focusin", keyborgNativeFocusEvent.focusInHandler, true);
    delete kwin.__keyborgData;
  }
  if (origFocus) {
    proto.focus = origFocus;
  }
}
var _dismissTimeout = 500;
var _lastId = 0;
var KeyborgState = class {
  constructor() {
    this.__keyborgCoreRefs = {};
    this._isNavigatingWithKeyboard = false;
  }
  add(keyborg) {
    const id = keyborg.id;
    if (!(id in this.__keyborgCoreRefs)) {
      this.__keyborgCoreRefs[id] = new WeakRefInstance(keyborg);
    }
  }
  remove(id) {
    delete this.__keyborgCoreRefs[id];
    if (Object.keys(this.__keyborgCoreRefs).length === 0) {
      this._isNavigatingWithKeyboard = false;
    }
  }
  setVal(isNavigatingWithKeyboard) {
    if (this._isNavigatingWithKeyboard === isNavigatingWithKeyboard) {
      return;
    }
    this._isNavigatingWithKeyboard = isNavigatingWithKeyboard;
    for (const id of Object.keys(this.__keyborgCoreRefs)) {
      const ref = this.__keyborgCoreRefs[id];
      const keyborg = ref.deref();
      if (keyborg) {
        keyborg.update(isNavigatingWithKeyboard);
      } else {
        this.remove(id);
      }
    }
  }
  getVal() {
    return this._isNavigatingWithKeyboard;
  }
};
var _state = new KeyborgState();
var KeyborgCore = class {
  constructor(win, props) {
    this._onFocusIn = (e2) => {
      if (this._isMouseUsedTimer) {
        return;
      }
      if (_state.getVal()) {
        return;
      }
      const details = e2.details;
      if (!details.relatedTarget) {
        return;
      }
      if (details.isFocusedProgrammatically || details.isFocusedProgrammatically === void 0) {
        return;
      }
      _state.setVal(true);
    };
    this._onMouseDown = (e2) => {
      if (e2.buttons === 0 || e2.clientX === 0 && e2.clientY === 0 && e2.screenX === 0 && e2.screenY === 0) {
        return;
      }
      const win2 = this._win;
      if (win2) {
        if (this._isMouseUsedTimer) {
          win2.clearTimeout(this._isMouseUsedTimer);
        }
        this._isMouseUsedTimer = win2.setTimeout(() => {
          delete this._isMouseUsedTimer;
        }, 1e3);
      }
      _state.setVal(false);
    };
    this._onKeyDown = (e2) => {
      var _a, _b;
      const isNavigatingWithKeyboard = _state.getVal();
      const keyCode = e2.keyCode;
      const triggerKeys = this._triggerKeys;
      if (!isNavigatingWithKeyboard && (!triggerKeys || triggerKeys.has(keyCode))) {
        const activeElement = (_a = this._win) === null || _a === void 0 ? void 0 : _a.document.activeElement;
        if (activeElement && (activeElement.tagName === "INPUT" || activeElement.tagName === "TEXTAREA" || activeElement.contentEditable === "true")) {
          return;
        }
        _state.setVal(true);
      } else if (isNavigatingWithKeyboard && ((_b = this._dismissKeys) === null || _b === void 0 ? void 0 : _b.has(keyCode))) {
        this._scheduleDismiss();
      }
    };
    this.id = "c" + ++_lastId;
    this._win = win;
    const doc = win.document;
    if (props) {
      const triggerKeys = props.triggerKeys;
      const dismissKeys = props.dismissKeys;
      if (triggerKeys === null || triggerKeys === void 0 ? void 0 : triggerKeys.length) {
        this._triggerKeys = new Set(triggerKeys);
      }
      if (dismissKeys === null || dismissKeys === void 0 ? void 0 : dismissKeys.length) {
        this._dismissKeys = new Set(dismissKeys);
      }
    }
    doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);
    doc.addEventListener("mousedown", this._onMouseDown, true);
    win.addEventListener("keydown", this._onKeyDown, true);
    setupFocusEvent(win);
    _state.add(this);
  }
  dispose() {
    const win = this._win;
    if (win) {
      if (this._isMouseUsedTimer) {
        win.clearTimeout(this._isMouseUsedTimer);
        this._isMouseUsedTimer = void 0;
      }
      if (this._dismissTimer) {
        win.clearTimeout(this._dismissTimer);
        this._dismissTimer = void 0;
      }
      disposeFocusEvent(win);
      const doc = win.document;
      doc.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);
      doc.removeEventListener("mousedown", this._onMouseDown, true);
      win.removeEventListener("keydown", this._onKeyDown, true);
      delete this._win;
      _state.remove(this.id);
    }
  }
  isDisposed() {
    return !!this._win;
  }
  /**
   * Updates all keyborg instances with the keyboard navigation state
   */
  update(isNavigatingWithKeyboard) {
    var _a, _b;
    const keyborgs = (_b = (_a = this._win) === null || _a === void 0 ? void 0 : _a.__keyborg) === null || _b === void 0 ? void 0 : _b.refs;
    if (keyborgs) {
      for (const id of Object.keys(keyborgs)) {
        Keyborg.update(keyborgs[id], isNavigatingWithKeyboard);
      }
    }
  }
  _scheduleDismiss() {
    const win = this._win;
    if (win) {
      if (this._dismissTimer) {
        win.clearTimeout(this._dismissTimer);
        this._dismissTimer = void 0;
      }
      const was = win.document.activeElement;
      this._dismissTimer = win.setTimeout(() => {
        this._dismissTimer = void 0;
        const cur = win.document.activeElement;
        if (was && cur && was === cur) {
          _state.setVal(false);
        }
      }, _dismissTimeout);
    }
  }
};
var Keyborg = class _Keyborg {
  constructor(win, props) {
    this._cb = [];
    this._id = "k" + ++_lastId;
    this._win = win;
    const current = win.__keyborg;
    if (current) {
      this._core = current.core;
      current.refs[this._id] = this;
    } else {
      this._core = new KeyborgCore(win, props);
      win.__keyborg = {
        core: this._core,
        refs: {
          [this._id]: this
        }
      };
    }
  }
  static create(win, props) {
    return new _Keyborg(win, props);
  }
  static dispose(instance) {
    instance.dispose();
  }
  /**
   * Updates all subscribed callbacks with the keyboard navigation state
   */
  static update(instance, isNavigatingWithKeyboard) {
    instance._cb.forEach((callback) => callback(isNavigatingWithKeyboard));
  }
  dispose() {
    var _a;
    const current = (_a = this._win) === null || _a === void 0 ? void 0 : _a.__keyborg;
    if (current === null || current === void 0 ? void 0 : current.refs[this._id]) {
      delete current.refs[this._id];
      if (Object.keys(current.refs).length === 0) {
        current.core.dispose();
        delete this._win.__keyborg;
      }
    } else if (true) {
      console.error("Keyborg instance " + this._id + " is being disposed incorrectly.");
    }
    this._cb = [];
    delete this._core;
    delete this._win;
  }
  /**
   * @returns Whether the user is navigating with keyboard
   */
  isNavigatingWithKeyboard() {
    return _state.getVal();
  }
  /**
   * @param callback - Called when the keyboard navigation state changes
   */
  subscribe(callback) {
    this._cb.push(callback);
  }
  /**
   * @param callback - Registered with subscribe
   */
  unsubscribe(callback) {
    const index = this._cb.indexOf(callback);
    if (index >= 0) {
      this._cb.splice(index, 1);
    }
  }
  /**
   * Manually set the keyboard navigtion state
   */
  setVal(isNavigatingWithKeyboard) {
    _state.setVal(isNavigatingWithKeyboard);
  }
};
function createKeyborg(win, props) {
  return Keyborg.create(win, props);
}
function disposeKeyborg(instance) {
  Keyborg.dispose(instance);
}

// node_modules/tabster/dist/tabster.esm.js
var TabsterAttributeName = "data-tabster";
var TabsterDummyInputAttributeName = "data-tabster-dummy";
var DeloserEventName = "tabster:deloser";
var ModalizerActiveEventName = "tabster:modalizer:active";
var ModalizerInactiveEventName = "tabster:modalizer:inactive";
var ModalizerFocusInEventName = "tabster:modalizer:focusin";
var ModalizerFocusOutEventName = "tabster:modalizer:focusout";
var ModalizerBeforeFocusOutEventName = "tabster:modalizer:beforefocusout";
var MoverEventName = "tabster:mover";
var FocusInEventName = "tabster:focusin";
var FocusOutEventName = "tabster:focusout";
var FocusableSelector = ["a[href]", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])", "*[tabindex]", "*[contenteditable]"].join(", ");
var ObservedElementAccesibilities = {
  Any: 0,
  Accessible: 1,
  Focusable: 2
};
var RestoreFocusOrders = {
  History: 0,
  DeloserDefault: 1,
  RootDefault: 2,
  DeloserFirst: 3,
  RootFirst: 4
};
var Visibilities = {
  Invisible: 0,
  PartiallyVisible: 1,
  Visible: 2
};
var RestorerTypes = {
  Source: 0,
  Target: 1
};
var MoverDirections = {
  Both: 0,
  Vertical: 1,
  Horizontal: 2,
  Grid: 3,
  GridLinear: 4
};
var GroupperTabbabilities = {
  Unlimited: 0,
  Limited: 1,
  LimitedTrapFocus: 2
};
var SysDummyInputsPositions = {
  Auto: 0,
  Inside: 1,
  Outside: 2
};
var Types = Object.freeze({
  __proto__: null,
  TabsterAttributeName,
  TabsterDummyInputAttributeName,
  DeloserEventName,
  ModalizerActiveEventName,
  ModalizerInactiveEventName,
  ModalizerFocusInEventName,
  ModalizerFocusOutEventName,
  ModalizerBeforeFocusOutEventName,
  MoverEventName,
  FocusInEventName,
  FocusOutEventName,
  FocusableSelector,
  ObservedElementAccesibilities,
  RestoreFocusOrders,
  Visibilities,
  RestorerTypes,
  MoverDirections,
  GroupperTabbabilities,
  SysDummyInputsPositions
});
function getTabsterOnElement(tabster, element) {
  var _a;
  return (_a = tabster.storageEntry(element)) === null || _a === void 0 ? void 0 : _a.tabster;
}
function updateTabsterByAttribute(tabster, element, dispose) {
  var _a, _b;
  const newAttrValue = dispose || tabster._noop ? void 0 : element.getAttribute(TabsterAttributeName);
  let entry = tabster.storageEntry(element);
  let newAttr;
  if (newAttrValue) {
    if (newAttrValue !== ((_a = entry === null || entry === void 0 ? void 0 : entry.attr) === null || _a === void 0 ? void 0 : _a.string)) {
      try {
        const newValue = JSON.parse(newAttrValue);
        if (typeof newValue !== "object") {
          throw new Error(`Value is not a JSON object, got '${newAttrValue}'.`);
        }
        newAttr = {
          string: newAttrValue,
          object: newValue
        };
      } catch (e2) {
        if (true) {
          console.error(`data-tabster attribute error: ${e2}`, element);
        }
      }
    } else {
      return;
    }
  } else if (!entry) {
    return;
  }
  if (!entry) {
    entry = tabster.storageEntry(element, true);
  }
  if (!entry.tabster) {
    entry.tabster = {};
  }
  const tabsterOnElement = entry.tabster || {};
  const oldTabsterProps = ((_b = entry.attr) === null || _b === void 0 ? void 0 : _b.object) || {};
  const newTabsterProps = (newAttr === null || newAttr === void 0 ? void 0 : newAttr.object) || {};
  for (const key of Object.keys(oldTabsterProps)) {
    if (!newTabsterProps[key]) {
      if (key === "root") {
        const root = tabsterOnElement[key];
        if (root) {
          tabster.root.onRoot(root, true);
        }
      }
      switch (key) {
        case "deloser":
        case "root":
        case "groupper":
        case "modalizer":
        case "restorer":
        case "mover":
          const part = tabsterOnElement[key];
          if (part) {
            part.dispose();
            delete tabsterOnElement[key];
          }
          break;
        case "observed":
          delete tabsterOnElement[key];
          if (tabster.observedElement) {
            tabster.observedElement.onObservedElementUpdate(element);
          }
          break;
        case "focusable":
        case "outline":
        case "uncontrolled":
        case "sys":
          delete tabsterOnElement[key];
          break;
      }
    }
  }
  for (const key of Object.keys(newTabsterProps)) {
    const sys = newTabsterProps.sys;
    switch (key) {
      case "deloser":
        if (tabsterOnElement.deloser) {
          tabsterOnElement.deloser.setProps(newTabsterProps.deloser);
        } else {
          if (tabster.deloser) {
            tabsterOnElement.deloser = tabster.deloser.createDeloser(element, newTabsterProps.deloser);
          } else if (true) {
            console.error("Deloser API used before initialization, please call `getDeloser()`");
          }
        }
        break;
      case "root":
        if (tabsterOnElement.root) {
          tabsterOnElement.root.setProps(newTabsterProps.root);
        } else {
          tabsterOnElement.root = tabster.root.createRoot(element, newTabsterProps.root, sys);
        }
        tabster.root.onRoot(tabsterOnElement.root);
        break;
      case "modalizer":
        if (tabsterOnElement.modalizer) {
          tabsterOnElement.modalizer.setProps(newTabsterProps.modalizer);
        } else {
          if (tabster.modalizer) {
            tabsterOnElement.modalizer = tabster.modalizer.createModalizer(element, newTabsterProps.modalizer, sys);
          } else if (true) {
            console.error("Modalizer API used before initialization, please call `getModalizer()`");
          }
        }
        break;
      case "restorer":
        if (tabsterOnElement.restorer) {
          tabsterOnElement.restorer.setProps(newTabsterProps.restorer);
        } else {
          if (tabster.restorer) {
            if (newTabsterProps.restorer) {
              tabsterOnElement.restorer = tabster.restorer.createRestorer(element, newTabsterProps.restorer);
            }
          } else if (true) {
            console.error("Restorer API used before initialization, please call `getRestorer()`");
          }
        }
        break;
      case "focusable":
        tabsterOnElement.focusable = newTabsterProps.focusable;
        break;
      case "groupper":
        if (tabsterOnElement.groupper) {
          tabsterOnElement.groupper.setProps(newTabsterProps.groupper);
        } else {
          if (tabster.groupper) {
            tabsterOnElement.groupper = tabster.groupper.createGroupper(element, newTabsterProps.groupper, sys);
          } else if (true) {
            console.error("Groupper API used before initialization, please call `getGroupper()`");
          }
        }
        break;
      case "mover":
        if (tabsterOnElement.mover) {
          tabsterOnElement.mover.setProps(newTabsterProps.mover);
        } else {
          if (tabster.mover) {
            tabsterOnElement.mover = tabster.mover.createMover(element, newTabsterProps.mover, sys);
          } else if (true) {
            console.error("Mover API used before initialization, please call `getMover()`");
          }
        }
        break;
      case "observed":
        if (tabster.observedElement) {
          tabsterOnElement.observed = newTabsterProps.observed;
          tabster.observedElement.onObservedElementUpdate(element);
        } else if (true) {
          console.error("ObservedElement API used before initialization, please call `getObservedElement()`");
        }
        break;
      case "uncontrolled":
        tabsterOnElement.uncontrolled = newTabsterProps.uncontrolled;
        break;
      case "outline":
        if (tabster.outline) {
          tabsterOnElement.outline = newTabsterProps.outline;
        } else if (true) {
          console.error("Outline API used before initialization, please call `getOutline()`");
        }
        break;
      case "sys":
        tabsterOnElement.sys = newTabsterProps.sys;
        break;
      default:
        console.error(`Unknown key '${key}' in data-tabster attribute value.`);
    }
  }
  if (newAttr) {
    entry.attr = newAttr;
  } else {
    if (Object.keys(tabsterOnElement).length === 0) {
      delete entry.tabster;
      delete entry.attr;
    }
    tabster.storageEntry(element, false);
  }
}
function createEventTarget(getWindow2) {
  const global = getWindow2();
  try {
    if (global.EventTarget) {
      return new global.EventTarget();
    }
  } catch (error) {
    if (!(error instanceof TypeError)) {
      throw error;
    }
  }
  return global.document.createElement("div");
}
var _isBrokenIE11;
var _DOMRect = typeof DOMRect !== "undefined" ? DOMRect : class {
  constructor(x2, y2, width, height) {
    this.left = x2 || 0;
    this.top = y2 || 0;
    this.right = (x2 || 0) + (width || 0);
    this.bottom = (y2 || 0) + (height || 0);
  }
};
var _uidCounter = 0;
try {
  document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT);
  _isBrokenIE11 = false;
} catch (e2) {
  _isBrokenIE11 = true;
}
var _updateDummyInputsTimeout = 100;
function getInstanceContext(getWindow2) {
  const win = getWindow2();
  let ctx = win.__tabsterInstanceContext;
  if (!ctx) {
    ctx = {
      elementByUId: {},
      basics: {
        Promise: win.Promise || void 0,
        WeakRef: win.WeakRef || void 0
      },
      containerBoundingRectCache: {},
      lastContainerBoundingRectCacheId: 0,
      fakeWeakRefs: [],
      fakeWeakRefsStarted: false
    };
    win.__tabsterInstanceContext = ctx;
  }
  return ctx;
}
function disposeInstanceContext(win) {
  const ctx = win.__tabsterInstanceContext;
  if (ctx) {
    ctx.elementByUId = {};
    delete ctx.WeakRef;
    ctx.containerBoundingRectCache = {};
    if (ctx.containerBoundingRectCacheTimer) {
      win.clearTimeout(ctx.containerBoundingRectCacheTimer);
    }
    if (ctx.fakeWeakRefsTimer) {
      win.clearTimeout(ctx.fakeWeakRefsTimer);
    }
    ctx.fakeWeakRefs = [];
    delete win.__tabsterInstanceContext;
  }
}
function createWeakMap(win) {
  const ctx = win.__tabsterInstanceContext;
  return new ((ctx === null || ctx === void 0 ? void 0 : ctx.basics.WeakMap) || WeakMap)();
}
function hasSubFocusable(element) {
  return !!element.querySelector(FocusableSelector);
}
var FakeWeakRef = class {
  constructor(target) {
    this._target = target;
  }
  deref() {
    return this._target;
  }
  static cleanup(fwr, forceRemove) {
    if (!fwr._target) {
      return true;
    }
    if (forceRemove || !documentContains(fwr._target.ownerDocument, fwr._target)) {
      delete fwr._target;
      return true;
    }
    return false;
  }
};
var WeakHTMLElement = class {
  constructor(getWindow2, element, data) {
    const context = getInstanceContext(getWindow2);
    let ref;
    if (context.WeakRef) {
      ref = new context.WeakRef(element);
    } else {
      ref = new FakeWeakRef(element);
      context.fakeWeakRefs.push(ref);
    }
    this._ref = ref;
    this._data = data;
  }
  get() {
    const ref = this._ref;
    let element;
    if (ref) {
      element = ref.deref();
      if (!element) {
        delete this._ref;
      }
    }
    return element;
  }
  getData() {
    return this._data;
  }
};
function cleanupFakeWeakRefs(getWindow2, forceRemove) {
  const context = getInstanceContext(getWindow2);
  context.fakeWeakRefs = context.fakeWeakRefs.filter((e2) => !FakeWeakRef.cleanup(e2, forceRemove));
}
function startFakeWeakRefsCleanup(getWindow2) {
  const context = getInstanceContext(getWindow2);
  if (!context.fakeWeakRefsStarted) {
    context.fakeWeakRefsStarted = true;
    context.WeakRef = getWeakRef(context);
  }
  if (!context.fakeWeakRefsTimer) {
    context.fakeWeakRefsTimer = getWindow2().setTimeout(() => {
      context.fakeWeakRefsTimer = void 0;
      cleanupFakeWeakRefs(getWindow2);
      startFakeWeakRefsCleanup(getWindow2);
    }, 2 * 60 * 1e3);
  }
}
function stopFakeWeakRefsCleanupAndClearStorage(getWindow2) {
  const context = getInstanceContext(getWindow2);
  context.fakeWeakRefsStarted = false;
  if (context.fakeWeakRefsTimer) {
    getWindow2().clearTimeout(context.fakeWeakRefsTimer);
    context.fakeWeakRefsTimer = void 0;
    context.fakeWeakRefs = [];
  }
}
function createElementTreeWalker(doc, root, acceptNode) {
  if (root.nodeType !== Node.ELEMENT_NODE) {
    return void 0;
  }
  const filter = _isBrokenIE11 ? acceptNode : {
    acceptNode
  };
  return doc.createTreeWalker(
    root,
    NodeFilter.SHOW_ELEMENT,
    filter,
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore: We still don't want to completely break IE11, so, entityReferenceExpansion argument is not optional.
    false
    /* Last argument is not optional for IE11! */
  );
}
function getBoundingRect(getWindow2, element) {
  let cacheId = element.__tabsterCacheId;
  const context = getInstanceContext(getWindow2);
  const cached = cacheId ? context.containerBoundingRectCache[cacheId] : void 0;
  if (cached) {
    return cached.rect;
  }
  const scrollingElement = element.ownerDocument && element.ownerDocument.documentElement;
  if (!scrollingElement) {
    return new _DOMRect();
  }
  let left2 = 0;
  let top = 0;
  let right2 = scrollingElement.clientWidth;
  let bottom = scrollingElement.clientHeight;
  if (element !== scrollingElement) {
    const r2 = element.getBoundingClientRect();
    left2 = Math.max(left2, r2.left);
    top = Math.max(top, r2.top);
    right2 = Math.min(right2, r2.right);
    bottom = Math.min(bottom, r2.bottom);
  }
  const rect = new _DOMRect(left2 < right2 ? left2 : -1, top < bottom ? top : -1, left2 < right2 ? right2 - left2 : 0, top < bottom ? bottom - top : 0);
  if (!cacheId) {
    cacheId = "r-" + ++context.lastContainerBoundingRectCacheId;
    element.__tabsterCacheId = cacheId;
  }
  context.containerBoundingRectCache[cacheId] = {
    rect,
    element
  };
  if (!context.containerBoundingRectCacheTimer) {
    context.containerBoundingRectCacheTimer = window.setTimeout(() => {
      context.containerBoundingRectCacheTimer = void 0;
      for (const cId of Object.keys(context.containerBoundingRectCache)) {
        delete context.containerBoundingRectCache[cId].element.__tabsterCacheId;
      }
      context.containerBoundingRectCache = {};
    }, 50);
  }
  return rect;
}
function isElementVerticallyVisibleInContainer(getWindow2, element, tolerance) {
  const container = getScrollableContainer(element);
  if (!container) {
    return false;
  }
  const containerRect = getBoundingRect(getWindow2, container);
  const elementRect = element.getBoundingClientRect();
  const intersectionTolerance = elementRect.height * (1 - tolerance);
  const topIntersection = Math.max(0, containerRect.top - elementRect.top);
  const bottomIntersection = Math.max(0, elementRect.bottom - containerRect.bottom);
  const totalIntersection = topIntersection + bottomIntersection;
  return totalIntersection === 0 || totalIntersection <= intersectionTolerance;
}
function scrollIntoView(getWindow2, element, alignToTop) {
  const container = getScrollableContainer(element);
  if (container) {
    const containerRect = getBoundingRect(getWindow2, container);
    const elementRect = element.getBoundingClientRect();
    if (alignToTop) {
      container.scrollTop += elementRect.top - containerRect.top;
    } else {
      container.scrollTop += elementRect.bottom - containerRect.bottom;
    }
  }
}
function getScrollableContainer(element) {
  const doc = element.ownerDocument;
  if (doc) {
    for (let el = element.parentElement; el; el = el.parentElement) {
      if (el.scrollWidth > el.clientWidth || el.scrollHeight > el.clientHeight) {
        return el;
      }
    }
    return doc.documentElement;
  }
  return null;
}
function makeFocusIgnored(element) {
  element.__shouldIgnoreFocus = true;
}
function shouldIgnoreFocus(element) {
  return !!element.__shouldIgnoreFocus;
}
function getUId(wnd) {
  const rnd = new Uint32Array(4);
  if (wnd.crypto && wnd.crypto.getRandomValues) {
    wnd.crypto.getRandomValues(rnd);
  } else if (wnd.msCrypto && wnd.msCrypto.getRandomValues) {
    wnd.msCrypto.getRandomValues(rnd);
  } else {
    for (let i3 = 0; i3 < rnd.length; i3++) {
      rnd[i3] = 4294967295 * Math.random();
    }
  }
  const srnd = [];
  for (let i3 = 0; i3 < rnd.length; i3++) {
    srnd.push(rnd[i3].toString(36));
  }
  srnd.push("|");
  srnd.push((++_uidCounter).toString(36));
  srnd.push("|");
  srnd.push(Date.now().toString(36));
  return srnd.join("");
}
function getElementUId(getWindow2, element) {
  const context = getInstanceContext(getWindow2);
  let uid = element.__tabsterElementUID;
  if (!uid) {
    uid = element.__tabsterElementUID = getUId(getWindow2());
  }
  if (!context.elementByUId[uid] && documentContains(element.ownerDocument, element)) {
    context.elementByUId[uid] = new WeakHTMLElement(getWindow2, element);
  }
  return uid;
}
function clearElementCache(getWindow2, parent2) {
  const context = getInstanceContext(getWindow2);
  for (const key of Object.keys(context.elementByUId)) {
    const wel = context.elementByUId[key];
    const el = wel && wel.get();
    if (el && parent2) {
      if (!parent2.contains(el)) {
        continue;
      }
    }
    delete context.elementByUId[key];
  }
}
function documentContains(doc, element) {
  var _a;
  return !!((_a = doc === null || doc === void 0 ? void 0 : doc.body) === null || _a === void 0 ? void 0 : _a.contains(element));
}
function matchesSelector(element, selector) {
  const matches = element.matches || element.matchesSelector || element.msMatchesSelector || element.webkitMatchesSelector;
  return matches && matches.call(element, selector);
}
function getPromise(getWindow2) {
  const context = getInstanceContext(getWindow2);
  if (context.basics.Promise) {
    return context.basics.Promise;
  }
  throw new Error("No Promise defined.");
}
function getWeakRef(context) {
  return context.basics.WeakRef;
}
var _lastTabsterPartId = 0;
var TabsterPart = class {
  constructor(tabster, element, props) {
    const getWindow2 = tabster.getWindow;
    this._tabster = tabster;
    this._element = new WeakHTMLElement(getWindow2, element);
    this._props = {
      ...props
    };
    this.id = "i" + ++_lastTabsterPartId;
  }
  getElement() {
    return this._element.get();
  }
  getProps() {
    return this._props;
  }
  setProps(props) {
    this._props = {
      ...props
    };
  }
};
var DummyInput = class {
  constructor(getWindow2, isOutside, props, element, fixedTarget) {
    var _a;
    this._focusIn = (e2) => {
      if (this._fixedTarget) {
        const target = this._fixedTarget.get();
        if (target) {
          nativeFocus(target);
        }
        return;
      }
      const input2 = this.input;
      if (this.onFocusIn && input2) {
        const relatedTarget = e2.relatedTarget;
        this.onFocusIn(this, this._isBackward(true, input2, relatedTarget), relatedTarget);
      }
    };
    this._focusOut = (e2) => {
      if (this._fixedTarget) {
        return;
      }
      this.useDefaultAction = false;
      const input2 = this.input;
      if (this.onFocusOut && input2) {
        const relatedTarget = e2.relatedTarget;
        this.onFocusOut(this, this._isBackward(false, input2, relatedTarget), relatedTarget);
      }
    };
    const win = getWindow2();
    const input = win.document.createElement("i");
    input.tabIndex = 0;
    input.setAttribute("role", "none");
    input.setAttribute(TabsterDummyInputAttributeName, "");
    input.setAttribute("aria-hidden", "true");
    const style = input.style;
    style.position = "fixed";
    style.width = style.height = "1px";
    style.opacity = "0.001";
    style.zIndex = "-1";
    style.setProperty("content-visibility", "hidden");
    makeFocusIgnored(input);
    this.input = input;
    this.isFirst = props.isFirst;
    this.isOutside = isOutside;
    this._isPhantom = (_a = props.isPhantom) !== null && _a !== void 0 ? _a : false;
    this._fixedTarget = fixedTarget;
    input.addEventListener("focusin", this._focusIn);
    input.addEventListener("focusout", this._focusOut);
    input.__tabsterDummyContainer = element;
    if (this._isPhantom) {
      this._disposeTimer = win.setTimeout(() => {
        delete this._disposeTimer;
        this.dispose();
      }, 0);
      this._clearDisposeTimeout = () => {
        if (this._disposeTimer) {
          win.clearTimeout(this._disposeTimer);
          delete this._disposeTimer;
        }
        delete this._clearDisposeTimeout;
      };
    }
  }
  dispose() {
    var _a;
    if (this._clearDisposeTimeout) {
      this._clearDisposeTimeout();
    }
    const input = this.input;
    if (!input) {
      return;
    }
    delete this._fixedTarget;
    delete this.onFocusIn;
    delete this.onFocusOut;
    delete this.input;
    input.removeEventListener("focusin", this._focusIn);
    input.removeEventListener("focusout", this._focusOut);
    delete input.__tabsterDummyContainer;
    (_a = input.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(input);
  }
  setTopLeft(top, left2) {
    var _a;
    const style = (_a = this.input) === null || _a === void 0 ? void 0 : _a.style;
    if (style) {
      style.top = `${top}px`;
      style.left = `${left2}px`;
    }
  }
  _isBackward(isIn, current, previous) {
    return isIn && !previous ? !this.isFirst : !!(previous && current.compareDocumentPosition(previous) & Node.DOCUMENT_POSITION_FOLLOWING);
  }
};
var DummyInputManagerPriorities = {
  Root: 1,
  Modalizer: 2,
  Mover: 3,
  Groupper: 4
};
var DummyInputManager = class {
  constructor(tabster, element, priority, sys, outsideByDefault, callForDefaultAction) {
    this._element = element;
    this._instance = new DummyInputManagerCore(tabster, element, this, priority, sys, outsideByDefault, callForDefaultAction);
  }
  _setHandlers(onFocusIn, onFocusOut) {
    this._onFocusIn = onFocusIn;
    this._onFocusOut = onFocusOut;
  }
  moveOut(backwards) {
    var _a;
    (_a = this._instance) === null || _a === void 0 ? void 0 : _a.moveOut(backwards);
  }
  moveOutWithDefaultAction(backwards) {
    var _a;
    (_a = this._instance) === null || _a === void 0 ? void 0 : _a.moveOutWithDefaultAction(backwards);
  }
  getHandler(isIn) {
    return isIn ? this._onFocusIn : this._onFocusOut;
  }
  setTabbable(tabbable) {
    var _a;
    (_a = this._instance) === null || _a === void 0 ? void 0 : _a.setTabbable(this, tabbable);
  }
  dispose() {
    if (this._instance) {
      this._instance.dispose(this);
      delete this._instance;
    }
    delete this._onFocusIn;
    delete this._onFocusOut;
  }
  static moveWithPhantomDummy(tabster, element, moveOutOfElement, isBackward) {
    var _a;
    const dummy = new DummyInput(tabster.getWindow, true, {
      isPhantom: true,
      isFirst: true
    });
    const input = dummy.input;
    if (input) {
      let parent2;
      let insertBefore;
      if (element.tagName === "BODY") {
        parent2 = element;
        insertBefore = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? element.firstElementChild : null;
      } else {
        if (moveOutOfElement && (!isBackward || isBackward && !tabster.focusable.isFocusable(element, false, true, true))) {
          parent2 = element;
          insertBefore = isBackward ? element.firstElementChild : null;
        } else {
          parent2 = element.parentElement;
          insertBefore = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? element : element.nextElementSibling;
        }
        let potentialDummy;
        let dummyFor;
        do {
          potentialDummy = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? insertBefore === null || insertBefore === void 0 ? void 0 : insertBefore.previousElementSibling : insertBefore;
          dummyFor = (_a = potentialDummy === null || potentialDummy === void 0 ? void 0 : potentialDummy.__tabsterDummyContainer) === null || _a === void 0 ? void 0 : _a.get();
          if (dummyFor === element) {
            insertBefore = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? potentialDummy : potentialDummy === null || potentialDummy === void 0 ? void 0 : potentialDummy.nextElementSibling;
          } else {
            dummyFor = void 0;
          }
        } while (dummyFor);
      }
      if (parent2) {
        parent2.insertBefore(input, insertBefore);
        nativeFocus(input);
      }
    }
  }
  static addPhantomDummyWithTarget(tabster, sourceElement, isBackward, targetElement) {
    const dummy = new DummyInput(tabster.getWindow, true, {
      isPhantom: true,
      isFirst: true
    }, void 0, new WeakHTMLElement(tabster.getWindow, targetElement));
    const input = dummy.input;
    if (input) {
      let dummyParent;
      let insertBefore;
      if (hasSubFocusable(sourceElement) && !isBackward) {
        dummyParent = sourceElement;
        insertBefore = sourceElement.firstElementChild;
      } else {
        dummyParent = sourceElement.parentElement;
        insertBefore = isBackward ? sourceElement : sourceElement.nextElementSibling;
      }
      dummyParent === null || dummyParent === void 0 ? void 0 : dummyParent.insertBefore(input, insertBefore);
    }
  }
};
function setDummyInputDebugValue(dummy, wrappers) {
  var _a;
  const what = {
    1: "Root",
    2: "Modalizer",
    3: "Mover",
    4: "Groupper"
  };
  (_a = dummy.input) === null || _a === void 0 ? void 0 : _a.setAttribute(TabsterDummyInputAttributeName, [`isFirst=${dummy.isFirst}`, `isOutside=${dummy.isOutside}`, ...wrappers.map((w3) => `(${what[w3.priority]}, tabbable=${w3.tabbable})`)].join(", "));
}
var DummyInputObserver = class {
  constructor(win) {
    this._updateQueue = /* @__PURE__ */ new Set();
    this._lastUpdateQueueTime = 0;
    this._changedParents = /* @__PURE__ */ new WeakSet();
    this._dummyElements = [];
    this._dummyCallbacks = /* @__PURE__ */ new WeakMap();
    this._domChanged = (parent2) => {
      var _a;
      if (this._changedParents.has(parent2)) {
        return;
      }
      this._changedParents.add(parent2);
      if (this._updateDummyInputsTimer) {
        return;
      }
      this._updateDummyInputsTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this).setTimeout(() => {
        delete this._updateDummyInputsTimer;
        for (const ref of this._dummyElements) {
          const dummyElement = ref.get();
          if (dummyElement) {
            const callback = this._dummyCallbacks.get(dummyElement);
            if (callback) {
              const dummyParent = dummyElement.parentElement;
              if (!dummyParent || this._changedParents.has(dummyParent)) {
                callback();
              }
            }
          }
        }
        this._changedParents = /* @__PURE__ */ new WeakSet();
      }, _updateDummyInputsTimeout);
    };
    this._win = win;
  }
  add(dummy, callback) {
    if (!this._dummyCallbacks.has(dummy) && this._win) {
      this._dummyElements.push(new WeakHTMLElement(this._win, dummy));
      this._dummyCallbacks.set(dummy, callback);
      this.domChanged = this._domChanged;
    }
  }
  remove(dummy) {
    this._dummyElements = this._dummyElements.filter((ref) => {
      const element = ref.get();
      return element && element !== dummy;
    });
    this._dummyCallbacks.delete(dummy);
    if (this._dummyElements.length === 0) {
      delete this.domChanged;
    }
  }
  dispose() {
    var _a;
    const win = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this);
    if (this._updateTimer) {
      win === null || win === void 0 ? void 0 : win.clearTimeout(this._updateTimer);
      delete this._updateTimer;
    }
    if (this._updateDummyInputsTimer) {
      win === null || win === void 0 ? void 0 : win.clearTimeout(this._updateDummyInputsTimer);
      delete this._updateDummyInputsTimer;
    }
    this._changedParents = /* @__PURE__ */ new WeakSet();
    this._dummyCallbacks = /* @__PURE__ */ new WeakMap();
    this._dummyElements = [];
    this._updateQueue.clear();
    delete this.domChanged;
    delete this._win;
  }
  updatePositions(compute) {
    if (!this._win) {
      return;
    }
    this._updateQueue.add(compute);
    this._lastUpdateQueueTime = Date.now();
    this._scheduledUpdatePositions();
  }
  _scheduledUpdatePositions() {
    var _a;
    if (this._updateTimer) {
      return;
    }
    this._updateTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this).setTimeout(() => {
      delete this._updateTimer;
      if (this._lastUpdateQueueTime + _updateDummyInputsTimeout <= Date.now()) {
        const scrollTopLeftCache = /* @__PURE__ */ new Map();
        const setTopLeftCallbacks = [];
        for (const compute of this._updateQueue) {
          setTopLeftCallbacks.push(compute(scrollTopLeftCache));
        }
        this._updateQueue.clear();
        for (const setTopLeft of setTopLeftCallbacks) {
          setTopLeft();
        }
        scrollTopLeftCache.clear();
      } else {
        this._scheduledUpdatePositions();
      }
    }, _updateDummyInputsTimeout);
  }
};
var DummyInputManagerCore = class {
  constructor(tabster, element, manager, priority, sys, outsideByDefault, callForDefaultAction) {
    this._wrappers = [];
    this._isOutside = false;
    this._transformElements = /* @__PURE__ */ new Set();
    this._onFocusIn = (dummyInput, isBackward, relatedTarget) => {
      this._onFocus(true, dummyInput, isBackward, relatedTarget);
    };
    this._onFocusOut = (dummyInput, isBackward, relatedTarget) => {
      this._onFocus(false, dummyInput, isBackward, relatedTarget);
    };
    this.moveOut = (backwards) => {
      var _a;
      const first = this._firstDummy;
      const last = this._lastDummy;
      if (first && last) {
        this._ensurePosition();
        const firstInput = first.input;
        const lastInput = last.input;
        const element2 = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();
        if (firstInput && lastInput && element2) {
          let toFocus;
          if (backwards) {
            firstInput.tabIndex = 0;
            toFocus = firstInput;
          } else {
            lastInput.tabIndex = 0;
            toFocus = lastInput;
          }
          if (toFocus) {
            nativeFocus(toFocus);
          }
        }
      }
    };
    this.moveOutWithDefaultAction = (backwards) => {
      var _a;
      const first = this._firstDummy;
      const last = this._lastDummy;
      if (first && last) {
        this._ensurePosition();
        const firstInput = first.input;
        const lastInput = last.input;
        const element2 = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();
        if (firstInput && lastInput && element2) {
          let toFocus;
          if (backwards) {
            if (!first.isOutside && this._tabster.focusable.isFocusable(element2, true, true, true)) {
              toFocus = element2;
            } else {
              first.useDefaultAction = true;
              firstInput.tabIndex = 0;
              toFocus = firstInput;
            }
          } else {
            last.useDefaultAction = true;
            lastInput.tabIndex = 0;
            toFocus = lastInput;
          }
          if (toFocus) {
            nativeFocus(toFocus);
          }
        }
      }
    };
    this.setTabbable = (manager2, tabbable) => {
      var _a, _b;
      for (const w3 of this._wrappers) {
        if (w3.manager === manager2) {
          w3.tabbable = tabbable;
          break;
        }
      }
      const wrapper = this._getCurrent();
      if (wrapper) {
        const tabIndex = wrapper.tabbable ? 0 : -1;
        let input = (_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.input;
        if (input) {
          input.tabIndex = tabIndex;
        }
        input = (_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.input;
        if (input) {
          input.tabIndex = tabIndex;
        }
      }
      if (true) {
        this._firstDummy && setDummyInputDebugValue(this._firstDummy, this._wrappers);
        this._lastDummy && setDummyInputDebugValue(this._lastDummy, this._wrappers);
      }
    };
    this._addDummyInputs = () => {
      if (this._addTimer) {
        return;
      }
      this._addTimer = this._getWindow().setTimeout(() => {
        delete this._addTimer;
        this._ensurePosition();
        if (true) {
          this._firstDummy && setDummyInputDebugValue(this._firstDummy, this._wrappers);
          this._lastDummy && setDummyInputDebugValue(this._lastDummy, this._wrappers);
        }
        this._addTransformOffsets();
      }, 0);
    };
    this._addTransformOffsets = () => {
      this._tabster._dummyObserver.updatePositions(this._computeTransformOffsets);
    };
    this._computeTransformOffsets = (scrollTopLeftCache) => {
      var _a, _b;
      const from = ((_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.input) || ((_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.input);
      const transformElements = this._transformElements;
      const newTransformElements = /* @__PURE__ */ new Set();
      let scrollTop = 0;
      let scrollLeft = 0;
      const win = this._getWindow();
      for (let element2 = from; element2 && element2.nodeType === Node.ELEMENT_NODE; element2 = element2.parentElement) {
        let scrollTopLeft = scrollTopLeftCache.get(element2);
        if (scrollTopLeft === void 0) {
          const transform = win.getComputedStyle(element2).transform;
          if (transform && transform !== "none") {
            scrollTopLeft = {
              scrollTop: element2.scrollTop,
              scrollLeft: element2.scrollLeft
            };
          }
          scrollTopLeftCache.set(element2, scrollTopLeft || null);
        }
        if (scrollTopLeft) {
          newTransformElements.add(element2);
          if (!transformElements.has(element2)) {
            element2.addEventListener("scroll", this._addTransformOffsets);
          }
          scrollTop += scrollTopLeft.scrollTop;
          scrollLeft += scrollTopLeft.scrollLeft;
        }
      }
      for (const el2 of transformElements) {
        if (!newTransformElements.has(el2)) {
          el2.removeEventListener("scroll", this._addTransformOffsets);
        }
      }
      this._transformElements = newTransformElements;
      return () => {
        var _a2, _b2;
        (_a2 = this._firstDummy) === null || _a2 === void 0 ? void 0 : _a2.setTopLeft(scrollTop, scrollLeft);
        (_b2 = this._lastDummy) === null || _b2 === void 0 ? void 0 : _b2.setTopLeft(scrollTop, scrollLeft);
      };
    };
    const el = element.get();
    if (!el) {
      throw new Error("No element");
    }
    this._tabster = tabster;
    this._getWindow = tabster.getWindow;
    this._callForDefaultAction = callForDefaultAction;
    const instance = el.__tabsterDummy;
    (instance || this)._wrappers.push({
      manager,
      priority,
      tabbable: true
    });
    if (instance) {
      if (true) {
        this._firstDummy && setDummyInputDebugValue(this._firstDummy, instance._wrappers);
        this._lastDummy && setDummyInputDebugValue(this._lastDummy, instance._wrappers);
      }
      return instance;
    }
    el.__tabsterDummy = this;
    const forcedDummyPosition = sys === null || sys === void 0 ? void 0 : sys.dummyInputsPosition;
    const tagName = el.tagName;
    this._isOutside = !forcedDummyPosition ? (outsideByDefault || tagName === "UL" || tagName === "OL" || tagName === "TABLE") && !(tagName === "LI" || tagName === "TD" || tagName === "TH") : forcedDummyPosition === SysDummyInputsPositions.Outside;
    this._firstDummy = new DummyInput(this._getWindow, this._isOutside, {
      isFirst: true
    }, element);
    this._lastDummy = new DummyInput(this._getWindow, this._isOutside, {
      isFirst: false
    }, element);
    const dummyElement = this._firstDummy.input;
    dummyElement && tabster._dummyObserver.add(dummyElement, this._addDummyInputs);
    this._firstDummy.onFocusIn = this._onFocusIn;
    this._firstDummy.onFocusOut = this._onFocusOut;
    this._lastDummy.onFocusIn = this._onFocusIn;
    this._lastDummy.onFocusOut = this._onFocusOut;
    this._element = element;
    this._addDummyInputs();
  }
  dispose(manager, force) {
    var _a, _b, _c, _d;
    const wrappers = this._wrappers = this._wrappers.filter((w3) => w3.manager !== manager && !force);
    if (true) {
      this._firstDummy && setDummyInputDebugValue(this._firstDummy, wrappers);
      this._lastDummy && setDummyInputDebugValue(this._lastDummy, wrappers);
    }
    if (wrappers.length === 0) {
      delete ((_a = this._element) === null || _a === void 0 ? void 0 : _a.get()).__tabsterDummy;
      for (const el of this._transformElements) {
        el.removeEventListener("scroll", this._addTransformOffsets);
      }
      this._transformElements.clear();
      const win = this._getWindow();
      if (this._addTimer) {
        win.clearTimeout(this._addTimer);
        delete this._addTimer;
      }
      const dummyElement = (_b = this._firstDummy) === null || _b === void 0 ? void 0 : _b.input;
      dummyElement && this._tabster._dummyObserver.remove(dummyElement);
      (_c = this._firstDummy) === null || _c === void 0 ? void 0 : _c.dispose();
      (_d = this._lastDummy) === null || _d === void 0 ? void 0 : _d.dispose();
    }
  }
  _onFocus(isIn, dummyInput, isBackward, relatedTarget) {
    var _a;
    const wrapper = this._getCurrent();
    if (wrapper && (!dummyInput.useDefaultAction || this._callForDefaultAction)) {
      (_a = wrapper.manager.getHandler(isIn)) === null || _a === void 0 ? void 0 : _a(dummyInput, isBackward, relatedTarget);
    }
  }
  _getCurrent() {
    this._wrappers.sort((a3, b2) => {
      if (a3.tabbable !== b2.tabbable) {
        return a3.tabbable ? -1 : 1;
      }
      return a3.priority - b2.priority;
    });
    return this._wrappers[0];
  }
  _ensurePosition() {
    var _a, _b, _c;
    const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();
    const firstDummyInput = (_b = this._firstDummy) === null || _b === void 0 ? void 0 : _b.input;
    const lastDummyInput = (_c = this._lastDummy) === null || _c === void 0 ? void 0 : _c.input;
    if (!element || !firstDummyInput || !lastDummyInput) {
      return;
    }
    if (this._isOutside) {
      const elementParent = element.parentElement;
      if (elementParent) {
        const nextSibling = element.nextElementSibling;
        if (nextSibling !== lastDummyInput) {
          elementParent.insertBefore(lastDummyInput, nextSibling);
        }
        if (element.previousElementSibling !== firstDummyInput) {
          elementParent.insertBefore(firstDummyInput, element);
        }
      }
    } else {
      if (element.lastElementChild !== lastDummyInput) {
        element.appendChild(lastDummyInput);
      }
      const firstElementChild = element.firstElementChild;
      if (firstElementChild && firstElementChild !== firstDummyInput) {
        element.insertBefore(firstDummyInput, firstElementChild);
      }
    }
  }
};
function getLastChild(container) {
  let lastChild = null;
  for (let i3 = container.lastElementChild; i3; i3 = i3.lastElementChild) {
    lastChild = i3;
  }
  return lastChild || void 0;
}
function getAdjacentElement(from, prev) {
  let cur = from;
  let adjacent = null;
  while (cur && !adjacent) {
    adjacent = prev ? cur.previousElementSibling : cur.nextElementSibling;
    cur = cur.parentElement;
  }
  return adjacent || void 0;
}
function triggerEvent(target, name, details) {
  const event = document.createEvent("HTMLEvents");
  event.initEvent(name, true, true);
  event.details = details;
  target.dispatchEvent(event);
  return !event.defaultPrevented;
}
function augmentAttribute(tabster, element, name, value) {
  const entry = tabster.storageEntry(element, true);
  let ret = false;
  if (!entry.aug) {
    if (value === void 0) {
      return ret;
    }
    entry.aug = {};
  }
  if (value === void 0) {
    if (name in entry.aug) {
      const origVal = entry.aug[name];
      delete entry.aug[name];
      if (origVal === null) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, origVal);
      }
      ret = true;
    }
  } else {
    let origValue;
    if (!(name in entry.aug)) {
      origValue = element.getAttribute(name);
    }
    if (origValue !== void 0 && origValue !== value) {
      entry.aug[name] = origValue;
      if (value === null) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value);
      }
      ret = true;
    }
  }
  if (value === void 0 && Object.keys(entry.aug).length === 0) {
    delete entry.aug;
    tabster.storageEntry(element, false);
  }
  return ret;
}
function getTabsterAttribute(props, plain) {
  const attr = JSON.stringify(props);
  if (plain === true) {
    return attr;
  }
  return {
    [TabsterAttributeName]: attr
  };
}
function mergeTabsterProps(props, newProps) {
  for (const key of Object.keys(newProps)) {
    const value = newProps[key];
    if (value) {
      props[key] = value;
    } else {
      delete props[key];
    }
  }
}
function setTabsterAttribute(element, newProps, update) {
  let props;
  if (update) {
    const attr = element.getAttribute(TabsterAttributeName);
    if (attr) {
      try {
        props = JSON.parse(attr);
      } catch (e2) {
        if (true) {
          console.error(`data-tabster attribute error: ${e2}`, element);
        }
      }
    }
  }
  if (!props) {
    props = {};
  }
  mergeTabsterProps(props, newProps);
  if (Object.keys(props).length > 0) {
    element.setAttribute(TabsterAttributeName, getTabsterAttribute(props, true));
  } else {
    element.removeAttribute(TabsterAttributeName);
  }
}
function _setInformativeStyle$3(weakElement, remove, id) {
  if (true) {
    const element = weakElement.get();
    if (element) {
      if (remove) {
        element.style.removeProperty("--tabster-root");
      } else {
        element.style.setProperty("--tabster-root", id + ",");
      }
    }
  }
}
var RootDummyManager = class extends DummyInputManager {
  constructor(tabster, element, setFocused, sys) {
    super(tabster, element, DummyInputManagerPriorities.Root, sys, void 0, true);
    this._onDummyInputFocus = (dummyInput) => {
      var _a;
      if (dummyInput.useDefaultAction) {
        this._setFocused(false);
      } else {
        this._tabster.keyboardNavigation.setNavigatingWithKeyboard(true);
        const element2 = this._element.get();
        if (element2) {
          this._setFocused(true);
          const toFocus = this._tabster.focusedElement.getFirstOrLastTabbable(dummyInput.isFirst, {
            container: element2,
            ignoreAccessibility: true
          });
          if (toFocus) {
            nativeFocus(toFocus);
            return;
          }
        }
        (_a = dummyInput.input) === null || _a === void 0 ? void 0 : _a.blur();
      }
    };
    this._setHandlers(this._onDummyInputFocus);
    this._tabster = tabster;
    this._setFocused = setFocused;
  }
};
var Root = class extends TabsterPart {
  constructor(tabster, element, onDispose, props, sys) {
    super(tabster, element, props);
    this._isFocused = false;
    this._setFocused = (hasFocused) => {
      var _a;
      if (this._setFocusedTimer) {
        this._tabster.getWindow().clearTimeout(this._setFocusedTimer);
        delete this._setFocusedTimer;
      }
      if (this._isFocused === hasFocused) {
        return;
      }
      const element2 = this._element.get();
      if (element2) {
        if (hasFocused) {
          this._isFocused = true;
          (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.setTabbable(false);
          triggerEvent(this._tabster.root.eventTarget, "focus", {
            element: element2
          });
        } else {
          this._setFocusedTimer = this._tabster.getWindow().setTimeout(() => {
            var _a2;
            delete this._setFocusedTimer;
            this._isFocused = false;
            (_a2 = this._dummyManager) === null || _a2 === void 0 ? void 0 : _a2.setTabbable(true);
            triggerEvent(this._tabster.root.eventTarget, "blur", {
              element: element2
            });
          }, 0);
        }
      }
    };
    this._onFocusIn = (event) => {
      const getParent2 = this._tabster.getParent;
      const rootElement = this._element.get();
      let curElement = event.target;
      do {
        if (curElement === rootElement) {
          this._setFocused(true);
          return;
        }
        curElement = curElement && getParent2(curElement);
      } while (curElement);
    };
    this._onFocusOut = () => {
      this._setFocused(false);
    };
    this._onDispose = onDispose;
    const win = tabster.getWindow;
    this.uid = getElementUId(win, element);
    this._sys = sys;
    if (tabster.controlTab || tabster.rootDummyInputs) {
      this.addDummyInputs();
    }
    const w3 = win();
    w3.document.addEventListener("focusin", this._onFocusIn);
    w3.document.addEventListener("focusout", this._onFocusOut);
    this._add();
  }
  addDummyInputs() {
    if (!this._dummyManager) {
      this._dummyManager = new RootDummyManager(this._tabster, this._element, this._setFocused, this._sys);
    }
  }
  dispose() {
    var _a;
    this._onDispose(this);
    const win = this._tabster.getWindow();
    win.document.removeEventListener("focusin", this._onFocusIn);
    win.document.removeEventListener("focusout", this._onFocusOut);
    if (this._setFocusedTimer) {
      win.clearTimeout(this._setFocusedTimer);
      delete this._setFocusedTimer;
    }
    (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();
    this._remove();
  }
  moveOutWithDefaultAction(isBackward) {
    const dummyManager = this._dummyManager;
    if (dummyManager) {
      dummyManager.moveOutWithDefaultAction(isBackward);
    } else {
      const el = this.getElement();
      if (el) {
        RootDummyManager.moveWithPhantomDummy(this._tabster, el, true, isBackward);
      }
    }
  }
  _add() {
    if (true) {
      _setInformativeStyle$3(this._element, false, this.uid);
    }
  }
  _remove() {
    if (true) {
      _setInformativeStyle$3(this._element, true);
    }
  }
};
var RootAPI = class {
  constructor(tabster, autoRoot) {
    this._autoRootWaiting = false;
    this._roots = {};
    this._forceDummy = false;
    this.rootById = {};
    this._autoRootCreate = () => {
      var _a;
      const doc = this._win().document;
      const body = doc.body;
      if (body) {
        this._autoRootUnwait(doc);
        const props = this._autoRoot;
        if (props) {
          setTabsterAttribute(body, {
            root: props
          }, true);
          updateTabsterByAttribute(this._tabster, body);
          return (_a = getTabsterOnElement(this._tabster, body)) === null || _a === void 0 ? void 0 : _a.root;
        }
      } else if (!this._autoRootWaiting) {
        this._autoRootWaiting = true;
        doc.addEventListener("readystatechange", this._autoRootCreate);
      }
      return void 0;
    };
    this._onRootDispose = (root) => {
      delete this._roots[root.id];
    };
    this._tabster = tabster;
    this._win = tabster.getWindow;
    this._autoRoot = autoRoot;
    this.eventTarget = createEventTarget(this._win);
    tabster.queueInit(() => {
      if (this._autoRoot) {
        this._autoRootCreate();
      }
    });
  }
  _autoRootUnwait(doc) {
    doc.removeEventListener("readystatechange", this._autoRootCreate);
    this._autoRootWaiting = false;
  }
  dispose() {
    const win = this._win();
    this._autoRootUnwait(win.document);
    delete this._autoRoot;
    Object.keys(this._roots).forEach((rootId) => {
      if (this._roots[rootId]) {
        this._roots[rootId].dispose();
        delete this._roots[rootId];
      }
    });
    this.rootById = {};
  }
  createRoot(element, props, sys) {
    if (true)
      ;
    const newRoot = new Root(this._tabster, element, this._onRootDispose, props, sys);
    this._roots[newRoot.id] = newRoot;
    if (this._forceDummy) {
      newRoot.addDummyInputs();
    }
    return newRoot;
  }
  addDummyInputs() {
    this._forceDummy = true;
    const roots = this._roots;
    for (const id of Object.keys(roots)) {
      roots[id].addDummyInputs();
    }
  }
  static getRootByUId(getWindow2, id) {
    const tabster = getWindow2().__tabsterInstance;
    return tabster && tabster.root.rootById[id];
  }
  /**
   * Fetches the tabster context for an element walking up its ancestors
   *
   * @param tabster Tabster instance
   * @param element The element the tabster context should represent
   * @param options Additional options
   * @returns undefined if the element is not a child of a tabster root, otherwise all applicable tabster behaviours and configurations
   */
  static getTabsterContext(tabster, element, options) {
    if (options === void 0) {
      options = {};
    }
    var _a, _b, _c, _d;
    if (!element.ownerDocument) {
      return void 0;
    }
    const {
      checkRtl,
      referenceElement
    } = options;
    const getParent2 = tabster.getParent;
    tabster.drainInitQueue();
    let root;
    let modalizer;
    let groupper;
    let mover;
    let excludedFromMover = false;
    let groupperBeforeMover;
    let modalizerInGroupper;
    let dirRightToLeft;
    let uncontrolled;
    let curElement = referenceElement || element;
    const ignoreKeydown = {};
    while (curElement && (!root || checkRtl)) {
      const tabsterOnElement = getTabsterOnElement(tabster, curElement);
      if (checkRtl && dirRightToLeft === void 0) {
        const dir = curElement.dir;
        if (dir) {
          dirRightToLeft = dir.toLowerCase() === "rtl";
        }
      }
      if (!tabsterOnElement) {
        curElement = getParent2(curElement);
        continue;
      }
      const tagName = curElement.tagName;
      if (tabsterOnElement.uncontrolled || tagName === "IFRAME" || tagName === "WEBVIEW") {
        uncontrolled = curElement;
      }
      if (!mover && ((_a = tabsterOnElement.focusable) === null || _a === void 0 ? void 0 : _a.excludeFromMover) && !groupper) {
        excludedFromMover = true;
      }
      const curModalizer = tabsterOnElement.modalizer;
      const curGroupper = tabsterOnElement.groupper;
      const curMover = tabsterOnElement.mover;
      if (!modalizer && curModalizer) {
        modalizer = curModalizer;
      }
      if (!groupper && curGroupper && (!modalizer || curModalizer)) {
        if (modalizer) {
          if (!curGroupper.isActive() && curGroupper.getProps().tabbability && modalizer.userId !== ((_b = tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {
            modalizer = void 0;
            groupper = curGroupper;
          }
          modalizerInGroupper = curGroupper;
        } else {
          groupper = curGroupper;
        }
      }
      if (!mover && curMover && (!modalizer || curModalizer) && (!curGroupper || curElement !== element)) {
        mover = curMover;
        groupperBeforeMover = !!groupper && groupper !== curGroupper;
      }
      if (tabsterOnElement.root) {
        root = tabsterOnElement.root;
      }
      if ((_c = tabsterOnElement.focusable) === null || _c === void 0 ? void 0 : _c.ignoreKeydown) {
        Object.assign(ignoreKeydown, tabsterOnElement.focusable.ignoreKeydown);
      }
      curElement = getParent2(curElement);
    }
    if (!root) {
      const rootAPI = tabster.root;
      const autoRoot = rootAPI._autoRoot;
      if (autoRoot) {
        if ((_d = element.ownerDocument) === null || _d === void 0 ? void 0 : _d.body) {
          root = rootAPI._autoRootCreate();
        }
      }
    }
    if (groupper && !mover) {
      groupperBeforeMover = true;
    }
    if (!root) {
      if (modalizer || groupper || mover) {
        console.error("Tabster Root is required for Mover, Groupper and Modalizer to work.");
      }
    }
    const shouldIgnoreKeydown = (event) => !!ignoreKeydown[event.key];
    return root ? {
      root,
      modalizer,
      groupper,
      mover,
      groupperBeforeMover,
      modalizerInGroupper,
      rtl: checkRtl ? !!dirRightToLeft : void 0,
      uncontrolled,
      excludedFromMover,
      ignoreKeydown: shouldIgnoreKeydown
    } : void 0;
  }
  static getRoot(tabster, element) {
    var _a;
    const getParent2 = tabster.getParent;
    for (let el = element; el; el = getParent2(el)) {
      const root = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.root;
      if (root) {
        return root;
      }
    }
    return void 0;
  }
  onRoot(root, removed) {
    if (removed) {
      delete this.rootById[root.uid];
    } else {
      this.rootById[root.uid] = root;
    }
  }
};
var Subscribable = class {
  constructor() {
    this._callbacks = [];
  }
  dispose() {
    this._callbacks = [];
    delete this._val;
  }
  subscribe(callback) {
    const callbacks = this._callbacks;
    const index = callbacks.indexOf(callback);
    if (index < 0) {
      callbacks.push(callback);
    }
  }
  subscribeFirst(callback) {
    const callbacks = this._callbacks;
    const index = callbacks.indexOf(callback);
    if (index >= 0) {
      callbacks.splice(index, 1);
    }
    callbacks.unshift(callback);
  }
  unsubscribe(callback) {
    const index = this._callbacks.indexOf(callback);
    if (index >= 0) {
      this._callbacks.splice(index, 1);
    }
  }
  setVal(val, details) {
    if (this._val === val) {
      return;
    }
    this._val = val;
    this._callCallbacks(val, details);
  }
  getVal() {
    return this._val;
  }
  trigger(val, details) {
    this._callCallbacks(val, details);
  }
  _callCallbacks(val, details) {
    this._callbacks.forEach((callback) => callback(val, details));
  }
};
var FocusableAPI = class {
  constructor(tabster) {
    this._tabster = tabster;
  }
  dispose() {
  }
  getProps(element) {
    const tabsterOnElement = getTabsterOnElement(this._tabster, element);
    return tabsterOnElement && tabsterOnElement.focusable || {};
  }
  isFocusable(el, includeProgrammaticallyFocusable, noVisibleCheck, noAccessibleCheck) {
    if (matchesSelector(el, FocusableSelector) && (includeProgrammaticallyFocusable || el.tabIndex !== -1)) {
      return (noVisibleCheck || this.isVisible(el)) && (noAccessibleCheck || this.isAccessible(el));
    }
    return false;
  }
  isVisible(el) {
    if (!el.ownerDocument || el.nodeType !== Node.ELEMENT_NODE) {
      return false;
    }
    if (el.offsetParent === null && el.ownerDocument.body !== el) {
      return false;
    }
    const win = el.ownerDocument.defaultView;
    if (!win) {
      return false;
    }
    const rect = el.ownerDocument.body.getBoundingClientRect();
    if (rect.width === 0 && rect.height === 0) {
      return false;
    }
    const computedStyle = win.getComputedStyle(el);
    if (computedStyle.visibility === "hidden") {
      return false;
    }
    return true;
  }
  isAccessible(el) {
    var _a;
    for (let e2 = el; e2; e2 = e2.parentElement) {
      const tabsterOnElement = getTabsterOnElement(this._tabster, e2);
      if (this._isHidden(e2)) {
        return false;
      }
      const ignoreDisabled = (_a = tabsterOnElement === null || tabsterOnElement === void 0 ? void 0 : tabsterOnElement.focusable) === null || _a === void 0 ? void 0 : _a.ignoreAriaDisabled;
      if (!ignoreDisabled && this._isDisabled(e2)) {
        return false;
      }
    }
    return true;
  }
  _isDisabled(el) {
    return el.hasAttribute("disabled");
  }
  _isHidden(el) {
    var _a;
    const attrVal = el.getAttribute("aria-hidden");
    if (attrVal && attrVal.toLowerCase() === "true") {
      if (!((_a = this._tabster.modalizer) === null || _a === void 0 ? void 0 : _a.isAugmented(el))) {
        return true;
      }
    }
    return false;
  }
  findFirst(options, out) {
    return this.findElement({
      ...options
    }, out);
  }
  findLast(options, out) {
    return this.findElement({
      isBackward: true,
      ...options
    }, out);
  }
  findNext(options, out) {
    return this.findElement({
      ...options
    }, out);
  }
  findPrev(options, out) {
    return this.findElement({
      ...options,
      isBackward: true
    }, out);
  }
  findDefault(options, out) {
    return this.findElement({
      ...options,
      acceptCondition: (el) => this.isFocusable(el, options.includeProgrammaticallyFocusable) && !!this.getProps(el).isDefault
    }, out) || null;
  }
  findAll(options) {
    return this._findElements(true, options) || [];
  }
  findElement(options, out) {
    const found = this._findElements(false, options, out);
    return found ? found[0] : found;
  }
  _findElements(findAll, options, out) {
    var _a, _b, _c;
    const {
      container,
      currentElement = null,
      includeProgrammaticallyFocusable,
      useActiveModalizer,
      ignoreAccessibility,
      modalizerId,
      isBackward,
      onElement
    } = options;
    if (!out) {
      out = {};
    }
    const elements = [];
    let {
      acceptCondition
    } = options;
    const hasCustomCondition = !!acceptCondition;
    if (!container) {
      return null;
    }
    if (!acceptCondition) {
      acceptCondition = (el) => this.isFocusable(el, includeProgrammaticallyFocusable, false, ignoreAccessibility);
    }
    const acceptElementState = {
      container,
      modalizerUserId: modalizerId === void 0 && useActiveModalizer ? (_a = this._tabster.modalizer) === null || _a === void 0 ? void 0 : _a.activeId : modalizerId || ((_c = (_b = RootAPI.getTabsterContext(this._tabster, container)) === null || _b === void 0 ? void 0 : _b.modalizer) === null || _c === void 0 ? void 0 : _c.userId),
      from: currentElement || container,
      isBackward,
      acceptCondition,
      hasCustomCondition,
      includeProgrammaticallyFocusable,
      ignoreAccessibility,
      cachedGrouppers: {}
    };
    const walker = createElementTreeWalker(container.ownerDocument, container, (node) => this._acceptElement(node, acceptElementState));
    if (!walker) {
      return null;
    }
    const prepareForNextElement = (shouldContinueIfNotFound) => {
      var _a2, _b2;
      const foundElement = (_a2 = acceptElementState.foundElement) !== null && _a2 !== void 0 ? _a2 : acceptElementState.foundBackward;
      if (foundElement) {
        elements.push(foundElement);
      }
      if (findAll) {
        if (foundElement) {
          acceptElementState.found = false;
          delete acceptElementState.foundElement;
          delete acceptElementState.foundBackward;
          delete acceptElementState.fromCtx;
          acceptElementState.from = foundElement;
          if (onElement && !onElement(foundElement)) {
            return false;
          }
        }
        return !!(foundElement || shouldContinueIfNotFound);
      } else {
        if (foundElement && out) {
          out.uncontrolled = (_b2 = RootAPI.getTabsterContext(this._tabster, foundElement)) === null || _b2 === void 0 ? void 0 : _b2.uncontrolled;
        }
        return !!(shouldContinueIfNotFound && !foundElement);
      }
    };
    if (!currentElement) {
      out.outOfDOMOrder = true;
    }
    if (currentElement) {
      walker.currentNode = currentElement;
    } else if (isBackward) {
      const lastChild = getLastChild(container);
      if (!lastChild) {
        return null;
      }
      if (this._acceptElement(lastChild, acceptElementState) === NodeFilter.FILTER_ACCEPT && !prepareForNextElement(true)) {
        if (acceptElementState.skippedFocusable) {
          out.outOfDOMOrder = true;
        }
        return elements;
      }
      walker.currentNode = lastChild;
    }
    do {
      if (isBackward) {
        walker.previousNode();
      } else {
        walker.nextNode();
      }
    } while (prepareForNextElement());
    if (acceptElementState.skippedFocusable) {
      out.outOfDOMOrder = true;
    }
    return elements.length ? elements : null;
  }
  _acceptElement(element, state) {
    var _a, _b, _c, _d;
    if (state.found) {
      return NodeFilter.FILTER_ACCEPT;
    }
    const foundBackward = state.foundBackward;
    if (foundBackward && (element === foundBackward || !foundBackward.contains(element))) {
      state.found = true;
      state.foundElement = foundBackward;
      return NodeFilter.FILTER_ACCEPT;
    }
    const container = state.container;
    if (element === container) {
      return NodeFilter.FILTER_SKIP;
    }
    if (!container.contains(element)) {
      return NodeFilter.FILTER_REJECT;
    }
    if (element.__tabsterDummyContainer) {
      return NodeFilter.FILTER_REJECT;
    }
    if ((_a = state.rejectElementsFrom) === null || _a === void 0 ? void 0 : _a.contains(element)) {
      return NodeFilter.FILTER_REJECT;
    }
    const ctx = state.currentCtx = RootAPI.getTabsterContext(this._tabster, element);
    if (!ctx) {
      return NodeFilter.FILTER_SKIP;
    }
    if (shouldIgnoreFocus(element)) {
      if (this.isFocusable(element, void 0, true, true)) {
        state.skippedFocusable = true;
      }
      return NodeFilter.FILTER_SKIP;
    }
    if (!state.hasCustomCondition && (element.tagName === "IFRAME" || element.tagName === "WEBVIEW")) {
      if (((_b = ctx.modalizer) === null || _b === void 0 ? void 0 : _b.userId) === ((_c = this._tabster.modalizer) === null || _c === void 0 ? void 0 : _c.activeId)) {
        state.found = true;
        state.rejectElementsFrom = state.foundElement = element;
        return NodeFilter.FILTER_ACCEPT;
      } else {
        return NodeFilter.FILTER_REJECT;
      }
    }
    if (!state.ignoreAccessibility && !this.isAccessible(element)) {
      if (this.isFocusable(element, false, true, true)) {
        state.skippedFocusable = true;
      }
      return NodeFilter.FILTER_REJECT;
    }
    let result;
    let fromCtx = state.fromCtx;
    if (!fromCtx) {
      fromCtx = state.fromCtx = RootAPI.getTabsterContext(this._tabster, state.from);
    }
    const fromMover = fromCtx === null || fromCtx === void 0 ? void 0 : fromCtx.mover;
    let groupper = ctx.groupper;
    let mover = ctx.mover;
    result = (_d = this._tabster.modalizer) === null || _d === void 0 ? void 0 : _d.acceptElement(element, state);
    if (result !== void 0) {
      state.skippedFocusable = true;
    }
    if (result === void 0 && (groupper || mover || fromMover)) {
      const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();
      const fromMoverElement = fromMover === null || fromMover === void 0 ? void 0 : fromMover.getElement();
      let moverElement = mover === null || mover === void 0 ? void 0 : mover.getElement();
      if (moverElement && (fromMoverElement === null || fromMoverElement === void 0 ? void 0 : fromMoverElement.contains(moverElement)) && container.contains(fromMoverElement) && (!groupperElement || !mover || fromMoverElement.contains(groupperElement))) {
        mover = fromMover;
        moverElement = fromMoverElement;
      }
      if (groupperElement && (groupperElement === container || !container.contains(groupperElement))) {
        groupper = void 0;
      }
      if (moverElement && !container.contains(moverElement)) {
        mover = void 0;
      }
      if (groupper && mover) {
        if (moverElement && groupperElement && !groupperElement.contains(moverElement)) {
          mover = void 0;
        } else {
          groupper = void 0;
        }
      }
      if (groupper) {
        result = groupper.acceptElement(element, state);
      }
      if (mover) {
        result = mover.acceptElement(element, state);
      }
    }
    if (result === void 0) {
      result = state.acceptCondition(element) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      if (result === NodeFilter.FILTER_SKIP && this.isFocusable(element, false, true, true)) {
        state.skippedFocusable = true;
      }
    }
    if (result === NodeFilter.FILTER_ACCEPT && !state.found) {
      if (state.isBackward) {
        state.foundBackward = element;
        result = NodeFilter.FILTER_SKIP;
      } else {
        state.found = true;
        state.foundElement = element;
      }
    }
    return result;
  }
};
var Keys = {
  Tab: 9,
  Enter: 13,
  Esc: 27,
  Space: 32,
  PageUp: 33,
  PageDown: 34,
  End: 35,
  Home: 36,
  Left: 37,
  Up: 38,
  Right: 39,
  Down: 40
};
function getUncontrolledCompletelyContainer(tabster, element) {
  var _a;
  const getParent2 = tabster.getParent;
  let el = element;
  do {
    const uncontrolledOnElement = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.uncontrolled;
    if (uncontrolledOnElement && tabster.uncontrolled.isUncontrolledCompletely(el, !!uncontrolledOnElement.completely)) {
      return el;
    }
    el = getParent2(el);
  } while (el);
  return void 0;
}
var FocusedElementState = class _FocusedElementState extends Subscribable {
  constructor(tabster, getWindow2) {
    super();
    this._init = () => {
      const win = this._win();
      const doc = win.document;
      doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);
      doc.addEventListener("focusout", this._onFocusOut, true);
      win.addEventListener("keydown", this._onKeyDown, true);
      const activeElement = doc.activeElement;
      if (activeElement && activeElement !== doc.body) {
        this._setFocusedElement(activeElement);
      }
      this.subscribe(this._onChanged);
    };
    this._onFocusIn = (e2) => {
      this._setFocusedElement(e2.target, e2.details.relatedTarget, e2.details.isFocusedProgrammatically);
    };
    this._onFocusOut = (e2) => {
      this._setFocusedElement(void 0, e2.relatedTarget);
    };
    this._validateFocusedElement = (element) => {
    };
    this._onKeyDown = (e2) => {
      if (e2.keyCode !== Keys.Tab || e2.ctrlKey) {
        return;
      }
      const currentElement = this.getVal();
      if (!currentElement || !currentElement.ownerDocument || currentElement.contentEditable === "true") {
        return;
      }
      const tabster2 = this._tabster;
      const controlTab = tabster2.controlTab;
      const ctx = RootAPI.getTabsterContext(tabster2, currentElement);
      if (!ctx || ctx.ignoreKeydown(e2)) {
        return;
      }
      const isBackward = e2.shiftKey;
      const next = _FocusedElementState.findNextTabbable(tabster2, ctx, void 0, currentElement, void 0, isBackward, true);
      const nextElement = next === null || next === void 0 ? void 0 : next.element;
      const uncontrolledCompletelyContainer = getUncontrolledCompletelyContainer(tabster2, currentElement);
      if (nextElement) {
        const nextUncontrolled = next.uncontrolled;
        if (ctx.uncontrolled || (nextUncontrolled === null || nextUncontrolled === void 0 ? void 0 : nextUncontrolled.contains(currentElement))) {
          if (!next.outOfDOMOrder && nextUncontrolled === ctx.uncontrolled || uncontrolledCompletelyContainer && !uncontrolledCompletelyContainer.contains(nextElement)) {
            return;
          }
          DummyInputManager.addPhantomDummyWithTarget(tabster2, currentElement, isBackward, nextElement);
          return;
        }
        if (nextUncontrolled || nextElement.tagName === "IFRAME") {
          DummyInputManager.moveWithPhantomDummy(this._tabster, nextUncontrolled !== null && nextUncontrolled !== void 0 ? nextUncontrolled : nextElement, false, isBackward);
          return;
        }
        if (controlTab || (next === null || next === void 0 ? void 0 : next.outOfDOMOrder)) {
          e2.preventDefault();
          e2.stopImmediatePropagation();
          nativeFocus(nextElement);
        }
      } else {
        if (!uncontrolledCompletelyContainer) {
          ctx.root.moveOutWithDefaultAction(isBackward);
        }
      }
    };
    this._onChanged = (element, details) => {
      var _a, _b;
      if (element) {
        triggerEvent(element, FocusInEventName, details);
      } else {
        const last = (_a = this._lastVal) === null || _a === void 0 ? void 0 : _a.get();
        if (last) {
          const d3 = {
            ...details
          };
          const lastCtx = RootAPI.getTabsterContext(this._tabster, last);
          const modalizerId = (_b = lastCtx === null || lastCtx === void 0 ? void 0 : lastCtx.modalizer) === null || _b === void 0 ? void 0 : _b.userId;
          if (modalizerId) {
            d3.modalizerId = modalizerId;
          }
          triggerEvent(last, FocusOutEventName, d3);
        }
      }
    };
    this._tabster = tabster;
    this._win = getWindow2;
    tabster.queueInit(this._init);
  }
  dispose() {
    super.dispose();
    const win = this._win();
    win.document.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);
    win.document.removeEventListener("focusout", this._onFocusOut, true);
    win.removeEventListener("keydown", this._onKeyDown, true);
    this.unsubscribe(this._onChanged);
    delete _FocusedElementState._lastResetElement;
    delete this._nextVal;
    delete this._lastVal;
  }
  static forgetMemorized(instance, parent2) {
    var _a, _b;
    let wel = _FocusedElementState._lastResetElement;
    let el = wel && wel.get();
    if (el && parent2.contains(el)) {
      delete _FocusedElementState._lastResetElement;
    }
    el = (_b = (_a = instance._nextVal) === null || _a === void 0 ? void 0 : _a.element) === null || _b === void 0 ? void 0 : _b.get();
    if (el && parent2.contains(el)) {
      delete instance._nextVal;
    }
    wel = instance._lastVal;
    el = wel && wel.get();
    if (el && parent2.contains(el)) {
      delete instance._lastVal;
    }
  }
  getFocusedElement() {
    return this.getVal();
  }
  getLastFocusedElement() {
    var _a;
    let el = (_a = this._lastVal) === null || _a === void 0 ? void 0 : _a.get();
    if (!el || el && !documentContains(el.ownerDocument, el)) {
      this._lastVal = el = void 0;
    }
    return el;
  }
  focus(element, noFocusedProgrammaticallyFlag, noAccessibleCheck) {
    if (!this._tabster.focusable.isFocusable(element, noFocusedProgrammaticallyFlag, false, noAccessibleCheck)) {
      return false;
    }
    element.focus();
    return true;
  }
  focusDefault(container) {
    const el = this._tabster.focusable.findDefault({
      container
    });
    if (el) {
      this._tabster.focusedElement.focus(el);
      return true;
    }
    return false;
  }
  getFirstOrLastTabbable(isFirst, props) {
    var _a;
    const {
      container,
      ignoreAccessibility
    } = props;
    let toFocus;
    if (container) {
      const ctx = RootAPI.getTabsterContext(this._tabster, container);
      if (ctx) {
        toFocus = (_a = _FocusedElementState.findNextTabbable(this._tabster, ctx, container, void 0, void 0, !isFirst, ignoreAccessibility)) === null || _a === void 0 ? void 0 : _a.element;
      }
    }
    if (toFocus && !(container === null || container === void 0 ? void 0 : container.contains(toFocus))) {
      toFocus = void 0;
    }
    return toFocus || void 0;
  }
  _focusFirstOrLast(isFirst, props) {
    const toFocus = this.getFirstOrLastTabbable(isFirst, props);
    if (toFocus) {
      this.focus(toFocus, false, true);
      return true;
    }
    return false;
  }
  focusFirst(props) {
    return this._focusFirstOrLast(true, props);
  }
  focusLast(props) {
    return this._focusFirstOrLast(false, props);
  }
  resetFocus(container) {
    if (!this._tabster.focusable.isVisible(container)) {
      return false;
    }
    if (!this._tabster.focusable.isFocusable(container, true, true, true)) {
      const prevTabIndex = container.getAttribute("tabindex");
      const prevAriaHidden = container.getAttribute("aria-hidden");
      container.tabIndex = -1;
      container.setAttribute("aria-hidden", "true");
      _FocusedElementState._lastResetElement = new WeakHTMLElement(this._win, container);
      this.focus(container, true, true);
      this._setOrRemoveAttribute(container, "tabindex", prevTabIndex);
      this._setOrRemoveAttribute(container, "aria-hidden", prevAriaHidden);
    } else {
      this.focus(container);
    }
    return true;
  }
  _setOrRemoveAttribute(element, name, value) {
    if (value === null) {
      element.removeAttribute(name);
    } else {
      element.setAttribute(name, value);
    }
  }
  _setFocusedElement(element, relatedTarget, isFocusedProgrammatically) {
    var _a, _b;
    if (this._tabster._noop) {
      return;
    }
    const details = {
      relatedTarget
    };
    if (element) {
      const lastResetElement = (_a = _FocusedElementState._lastResetElement) === null || _a === void 0 ? void 0 : _a.get();
      _FocusedElementState._lastResetElement = void 0;
      if (lastResetElement === element || shouldIgnoreFocus(element)) {
        return;
      }
      details.isFocusedProgrammatically = isFocusedProgrammatically;
      const ctx = RootAPI.getTabsterContext(this._tabster, element);
      const modalizerId = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer) === null || _b === void 0 ? void 0 : _b.userId;
      if (modalizerId) {
        details.modalizerId = modalizerId;
      }
    }
    const nextVal = this._nextVal = {
      element: element ? new WeakHTMLElement(this._win, element) : void 0,
      details
    };
    if (element && element !== this._val) {
      this._validateFocusedElement(element);
    }
    if (this._nextVal === nextVal) {
      this.setVal(element, details);
    }
    this._nextVal = void 0;
  }
  setVal(val, details) {
    super.setVal(val, details);
    if (val) {
      this._lastVal = new WeakHTMLElement(this._win, val);
    }
  }
  static findNextTabbable(tabster, ctx, container, currentElement, referenceElement, isBackward, ignoreAccessibility) {
    const actualContainer = container || ctx.root.getElement();
    if (!actualContainer) {
      return null;
    }
    let next = null;
    const isTabbingTimer = _FocusedElementState._isTabbingTimer;
    const win = tabster.getWindow();
    if (isTabbingTimer) {
      win.clearTimeout(isTabbingTimer);
    }
    _FocusedElementState.isTabbing = true;
    _FocusedElementState._isTabbingTimer = win.setTimeout(() => {
      delete _FocusedElementState._isTabbingTimer;
      _FocusedElementState.isTabbing = false;
    }, 0);
    const modalizer = ctx.modalizer;
    const groupper = ctx.groupper;
    const mover = ctx.mover;
    const callFindNext = (what) => {
      var _a;
      next = what.findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility);
      if (currentElement && !(next === null || next === void 0 ? void 0 : next.element)) {
        const parentElement = what !== modalizer && ((_a = what.getElement()) === null || _a === void 0 ? void 0 : _a.parentElement);
        if (parentElement) {
          const parentCtx = RootAPI.getTabsterContext(tabster, currentElement, {
            referenceElement: parentElement
          });
          if (parentCtx) {
            const currentScopeElement = what.getElement();
            const newCurrent = isBackward ? currentScopeElement : currentScopeElement && getLastChild(currentScopeElement) || currentScopeElement;
            if (newCurrent) {
              next = _FocusedElementState.findNextTabbable(tabster, parentCtx, container, newCurrent, parentElement, isBackward, ignoreAccessibility);
              if (next) {
                next.outOfDOMOrder = true;
              }
            }
          }
        }
      }
    };
    if (groupper && mover) {
      callFindNext(ctx.groupperBeforeMover ? groupper : mover);
    } else if (groupper) {
      callFindNext(groupper);
    } else if (mover) {
      callFindNext(mover);
    } else if (modalizer) {
      callFindNext(modalizer);
    } else {
      const findProps = {
        container: actualContainer,
        currentElement,
        referenceElement,
        ignoreAccessibility,
        useActiveModalizer: true
      };
      const findPropsOut = {};
      const nextElement = tabster.focusable[isBackward ? "findPrev" : "findNext"](findProps, findPropsOut);
      next = {
        element: nextElement,
        outOfDOMOrder: findPropsOut.outOfDOMOrder,
        uncontrolled: findPropsOut.uncontrolled
      };
    }
    return next;
  }
};
FocusedElementState.isTabbing = false;
var GroupperDummyManager = class extends DummyInputManager {
  constructor(element, groupper, tabster, sys) {
    super(tabster, element, DummyInputManagerPriorities.Groupper, sys, true);
    this._setHandlers((dummyInput, isBackward, relatedTarget) => {
      var _a, _b;
      const container = element.get();
      const input = dummyInput.input;
      if (container && input) {
        const ctx = RootAPI.getTabsterContext(tabster, input);
        if (ctx) {
          let next;
          next = (_a = groupper.findNextTabbable(relatedTarget || void 0, void 0, isBackward, true)) === null || _a === void 0 ? void 0 : _a.element;
          if (!next) {
            next = (_b = FocusedElementState.findNextTabbable(tabster, ctx, void 0, dummyInput.isOutside ? input : getAdjacentElement(container, !isBackward), void 0, isBackward, true)) === null || _b === void 0 ? void 0 : _b.element;
          }
          if (next) {
            nativeFocus(next);
          }
        }
      }
    });
  }
};
var Groupper = class extends TabsterPart {
  constructor(tabster, element, onDispose, props, sys) {
    super(tabster, element, props);
    this._shouldTabInside = false;
    this.makeTabbable(false);
    this._onDispose = onDispose;
    if (!tabster.controlTab) {
      this.dummyManager = new GroupperDummyManager(this._element, this, tabster, sys);
    }
  }
  dispose() {
    var _a;
    this._onDispose(this);
    const element = this._element.get();
    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();
    delete this.dummyManager;
    if (element) {
      if (true) {
        _setInformativeStyle$1(this._element, true);
      }
    }
    delete this._first;
  }
  findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility) {
    var _a;
    const groupperElement = this.getElement();
    if (!groupperElement) {
      return null;
    }
    const currentIsDummy = ((_a = currentElement === null || currentElement === void 0 ? void 0 : currentElement.__tabsterDummyContainer) === null || _a === void 0 ? void 0 : _a.get()) === groupperElement;
    if (!this._shouldTabInside && currentElement && groupperElement.contains(currentElement) && !currentIsDummy) {
      return {
        element: void 0,
        outOfDOMOrder: true
      };
    }
    const groupperFirstFocusable = this.getFirst(true);
    if (!currentElement || !groupperElement.contains(currentElement) || currentIsDummy) {
      return {
        element: groupperFirstFocusable,
        outOfDOMOrder: true
      };
    }
    const tabster = this._tabster;
    let next = null;
    let outOfDOMOrder = false;
    let uncontrolled;
    if (this._shouldTabInside && groupperFirstFocusable) {
      const findProps = {
        container: groupperElement,
        currentElement,
        referenceElement,
        ignoreAccessibility,
        useActiveModalizer: true
      };
      const findPropsOut = {};
      next = tabster.focusable[isBackward ? "findPrev" : "findNext"](findProps, findPropsOut);
      outOfDOMOrder = !!findPropsOut.outOfDOMOrder;
      if (!next && this._props.tabbability === GroupperTabbabilities.LimitedTrapFocus) {
        next = tabster.focusable[isBackward ? "findLast" : "findFirst"]({
          container: groupperElement,
          ignoreAccessibility,
          useActiveModalizer: true
        }, findPropsOut);
        outOfDOMOrder = true;
      }
      uncontrolled = findPropsOut.uncontrolled;
    }
    return {
      element: next,
      uncontrolled,
      outOfDOMOrder
    };
  }
  makeTabbable(isTabbable) {
    this._shouldTabInside = isTabbable || !this._props.tabbability;
    if (true) {
      _setInformativeStyle$1(this._element, !this._shouldTabInside);
    }
  }
  isActive(noIfFirstIsFocused) {
    var _a;
    const element = this.getElement() || null;
    let isParentActive = true;
    for (let e2 = element === null || element === void 0 ? void 0 : element.parentElement; e2; e2 = e2.parentElement) {
      const g2 = (_a = getTabsterOnElement(this._tabster, e2)) === null || _a === void 0 ? void 0 : _a.groupper;
      if (g2) {
        if (!g2._shouldTabInside) {
          isParentActive = false;
        }
      }
    }
    let ret = isParentActive ? this._props.tabbability ? this._shouldTabInside : false : void 0;
    if (ret && noIfFirstIsFocused) {
      const focused = this._tabster.focusedElement.getFocusedElement();
      if (focused) {
        ret = focused !== this.getFirst(true);
      }
    }
    return ret;
  }
  getFirst(orContainer) {
    var _a;
    const groupperElement = this.getElement();
    let first;
    if (groupperElement) {
      if (orContainer && this._tabster.focusable.isFocusable(groupperElement)) {
        return groupperElement;
      }
      first = (_a = this._first) === null || _a === void 0 ? void 0 : _a.get();
      if (!first) {
        first = this._tabster.focusable.findFirst({
          container: groupperElement,
          useActiveModalizer: true
        }) || void 0;
        if (first) {
          this.setFirst(first);
        }
      }
    }
    return first;
  }
  setFirst(element) {
    if (element) {
      this._first = new WeakHTMLElement(this._tabster.getWindow, element);
    } else {
      delete this._first;
    }
  }
  acceptElement(element, state) {
    var _a;
    const cachedGrouppers = state.cachedGrouppers;
    const parentElement = (_a = this.getElement()) === null || _a === void 0 ? void 0 : _a.parentElement;
    const parentCtx = parentElement && RootAPI.getTabsterContext(this._tabster, parentElement);
    const parentCtxGroupper = parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupper;
    const parentGroupper = (parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupperBeforeMover) ? parentCtxGroupper : void 0;
    let parentGroupperElement;
    const getIsActive = (groupper) => {
      let cached = cachedGrouppers[groupper.id];
      let isActive2;
      if (cached) {
        isActive2 = cached.isActive;
      } else {
        isActive2 = this.isActive(true);
        cached = cachedGrouppers[groupper.id] = {
          isActive: isActive2
        };
      }
      return isActive2;
    };
    if (parentGroupper) {
      parentGroupperElement = parentGroupper.getElement();
      if (!getIsActive(parentGroupper) && parentGroupperElement && state.container !== parentGroupperElement && state.container.contains(parentGroupperElement)) {
        state.skippedFocusable = true;
        return NodeFilter.FILTER_REJECT;
      }
    }
    const isActive = getIsActive(this);
    const groupperElement = this.getElement();
    if (groupperElement) {
      if (isActive !== true) {
        if (groupperElement === element && parentCtxGroupper) {
          if (!parentGroupperElement) {
            parentGroupperElement = parentCtxGroupper.getElement();
          }
          if (parentGroupperElement && !getIsActive(parentCtxGroupper) && state.container.contains(parentGroupperElement) && parentGroupperElement !== state.container) {
            state.skippedFocusable = true;
            return NodeFilter.FILTER_REJECT;
          }
        }
        if (groupperElement !== element && groupperElement.contains(element)) {
          state.skippedFocusable = true;
          return NodeFilter.FILTER_REJECT;
        }
        const cached = cachedGrouppers[this.id];
        let first;
        if ("first" in cached) {
          first = cached.first;
        } else {
          first = cached.first = this.getFirst(true);
        }
        if (first && state.acceptCondition(first)) {
          state.rejectElementsFrom = groupperElement;
          state.skippedFocusable = true;
          if (first !== state.from) {
            state.found = true;
            state.foundElement = first;
            return NodeFilter.FILTER_ACCEPT;
          } else {
            return NodeFilter.FILTER_REJECT;
          }
        }
      }
    }
    return void 0;
  }
};
var GroupperAPI = class {
  constructor(tabster, getWindow2) {
    this._current = {};
    this._grouppers = {};
    this._init = () => {
      const win = this._win();
      this._tabster.focusedElement.subscribeFirst(this._onFocus);
      win.document.addEventListener("mousedown", this._onMouseDown, true);
      win.addEventListener("keydown", this._onKeyDown, true);
    };
    this._onGroupperDispose = (groupper) => {
      delete this._grouppers[groupper.id];
    };
    this._onFocus = (element) => {
      if (element) {
        this._updateCurrent(element, true, true);
      }
    };
    this._onMouseDown = (e2) => {
      if (e2.target) {
        this._updateCurrent(e2.target, true);
      }
    };
    this._onKeyDown = (event) => {
      if (event.keyCode !== Keys.Enter && event.keyCode !== Keys.Esc) {
        return;
      }
      if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {
        return;
      }
      const element = this._tabster.focusedElement.getFocusedElement();
      if (element) {
        this.handleKeyPress(element, event);
      }
    };
    this._tabster = tabster;
    this._win = getWindow2;
    tabster.queueInit(this._init);
  }
  dispose() {
    const win = this._win();
    this._current = {};
    if (this._updateTimer) {
      win.clearTimeout(this._updateTimer);
      delete this._updateTimer;
    }
    this._tabster.focusedElement.unsubscribe(this._onFocus);
    win.document.removeEventListener("mousedown", this._onMouseDown, true);
    win.removeEventListener("keydown", this._onKeyDown, true);
    Object.keys(this._grouppers).forEach((groupperId) => {
      if (this._grouppers[groupperId]) {
        this._grouppers[groupperId].dispose();
        delete this._grouppers[groupperId];
      }
    });
  }
  createGroupper(element, props, sys) {
    if (true)
      ;
    const newGroupper = new Groupper(this._tabster, element, this._onGroupperDispose, props, sys);
    this._grouppers[newGroupper.id] = newGroupper;
    const focusedElement = this._tabster.focusedElement.getFocusedElement();
    if (focusedElement && element.contains(focusedElement) && !this._updateTimer) {
      this._updateTimer = this._win().setTimeout(() => {
        delete this._updateTimer;
        if (focusedElement === this._tabster.focusedElement.getFocusedElement()) {
          this._updateCurrent(focusedElement, true, true);
        }
      }, 0);
    }
    return newGroupper;
  }
  forgetCurrentGrouppers() {
    this._current = {};
  }
  _updateCurrent(element, includeTarget, checkTarget) {
    var _a;
    if (this._updateTimer) {
      this._win().clearTimeout(this._updateTimer);
      delete this._updateTimer;
    }
    const newIds = {};
    let isTarget = true;
    for (let el = element; el; el = el.parentElement) {
      const groupper = (_a = getTabsterOnElement(this._tabster, el)) === null || _a === void 0 ? void 0 : _a.groupper;
      if (groupper) {
        newIds[groupper.id] = true;
        if (isTarget && checkTarget && el !== element) {
          isTarget = false;
        }
        if (includeTarget || !isTarget) {
          this._current[groupper.id] = groupper;
          const isTabbable = groupper.isActive() || element !== el && (!groupper.getProps().delegated || groupper.getFirst(false) !== element);
          groupper.makeTabbable(isTabbable);
        }
        isTarget = false;
      }
    }
    for (const id of Object.keys(this._current)) {
      const groupper = this._current[id];
      if (!(groupper.id in newIds)) {
        groupper.makeTabbable(false);
        groupper.setFirst(void 0);
        delete this._current[id];
      }
    }
  }
  handleKeyPress(element, event, noGoUp) {
    var _a;
    const tabster = this._tabster;
    const ctx = RootAPI.getTabsterContext(tabster, element);
    const modalizerInGroupper = ctx === null || ctx === void 0 ? void 0 : ctx.modalizerInGroupper;
    let groupper = (ctx === null || ctx === void 0 ? void 0 : ctx.groupper) || modalizerInGroupper;
    if (ctx && groupper) {
      if (ctx.ignoreKeydown(event)) {
        return;
      }
      let next;
      const groupperElement = groupper.getElement();
      if (event.keyCode === Keys.Enter) {
        if (groupperElement && (element === groupperElement || groupper.getProps().delegated && element === groupper.getFirst(false))) {
          next = tabster.focusable.findNext({
            container: groupperElement,
            currentElement: element,
            useActiveModalizer: true
          });
        }
      } else if (event.keyCode === Keys.Esc) {
        if (groupperElement && groupperElement.contains(element)) {
          if (element !== groupperElement || noGoUp) {
            next = groupper.getFirst(true);
          } else {
            const parentElement = groupperElement.parentElement;
            const parentCtx = parentElement ? RootAPI.getTabsterContext(tabster, parentElement) : void 0;
            groupper = parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupper;
            next = groupper === null || groupper === void 0 ? void 0 : groupper.getFirst(true);
          }
        }
        if (groupper) {
          groupper.makeTabbable(false);
          if (modalizerInGroupper) {
            (_a = tabster.modalizer) === null || _a === void 0 ? void 0 : _a.setActive(void 0);
          }
        }
      }
      if (next) {
        event.preventDefault();
        event.stopImmediatePropagation();
        next.focus();
      }
    }
  }
};
function _setInformativeStyle$1(weakElement, remove) {
  if (true) {
    const element = weakElement.get();
    if (element) {
      if (remove) {
        element.style.removeProperty("--tabster-groupper");
      } else {
        element.style.setProperty("--tabster-groupper", "unlimited");
      }
    }
  }
}
var KeyboardNavigationState = class extends Subscribable {
  constructor(getWindow2) {
    super();
    this._onChange = (isNavigatingWithKeyboard) => {
      this.setVal(isNavigatingWithKeyboard, void 0);
    };
    this._keyborg = createKeyborg(getWindow2());
    this._keyborg.subscribe(this._onChange);
  }
  dispose() {
    super.dispose();
    if (this._keyborg) {
      this._keyborg.unsubscribe(this._onChange);
      disposeKeyborg(this._keyborg);
      delete this._keyborg;
    }
  }
  setNavigatingWithKeyboard(isNavigatingWithKeyboard) {
    var _a;
    (_a = this._keyborg) === null || _a === void 0 ? void 0 : _a.setVal(isNavigatingWithKeyboard);
  }
  isNavigatingWithKeyboard() {
    var _a;
    return !!((_a = this._keyborg) === null || _a === void 0 ? void 0 : _a.isNavigatingWithKeyboard());
  }
};
var _wasFocusedCounter = 0;
var _ariaHidden = "aria-hidden";
function _setInformativeStyle(weakElement, remove, internalId, userId, isActive, wasFocused) {
  if (true) {
    const element = weakElement.get();
    if (element) {
      if (remove) {
        element.style.removeProperty("--tabster-modalizer");
      } else {
        element.style.setProperty("--tabster-modalizer", internalId + "," + userId + "," + (isActive ? "active" : "inactive") + ",," + (wasFocused ? `focused(${wasFocused})` : "not-focused"));
      }
    }
  }
}
var ModalizerDummyManager = class extends DummyInputManager {
  constructor(element, tabster, sys) {
    super(tabster, element, DummyInputManagerPriorities.Modalizer, sys);
    this._setHandlers((dummyInput, isBackward) => {
      var _a, _b, _c;
      const el = element.get();
      const container = el && ((_a = RootAPI.getRoot(tabster, el)) === null || _a === void 0 ? void 0 : _a.getElement());
      const input = dummyInput.input;
      let toFocus;
      if (container && input) {
        const dummyContainer = (_b = input.__tabsterDummyContainer) === null || _b === void 0 ? void 0 : _b.get();
        const ctx = RootAPI.getTabsterContext(tabster, dummyContainer || input);
        if (ctx) {
          toFocus = (_c = FocusedElementState.findNextTabbable(tabster, ctx, container, input, void 0, isBackward, true)) === null || _c === void 0 ? void 0 : _c.element;
        }
        if (toFocus) {
          nativeFocus(toFocus);
        }
      }
    });
  }
};
var Modalizer = class extends TabsterPart {
  constructor(tabster, element, onDispose, props, sys, activeElements) {
    super(tabster, element, props);
    this._wasFocused = 0;
    this.userId = props.id;
    this._onDispose = onDispose;
    this._activeElements = activeElements;
    if (!tabster.controlTab) {
      this.dummyManager = new ModalizerDummyManager(this._element, tabster, sys);
    }
    if (true) {
      _setInformativeStyle(this._element, false, this.id, this.userId, this._isActive, this._wasFocused);
    }
  }
  makeActive(isActive) {
    if (this._isActive !== isActive) {
      this._isActive = isActive;
      const element = this.getElement();
      if (element) {
        const activeElements = this._activeElements;
        const index = activeElements.map((e2) => e2.get()).indexOf(element);
        if (isActive) {
          if (index < 0) {
            activeElements.push(new WeakHTMLElement(this._tabster.getWindow, element));
          }
        } else {
          if (index >= 0) {
            activeElements.splice(index, 1);
          }
        }
      }
      if (true) {
        _setInformativeStyle(this._element, false, this.id, this.userId, this._isActive, this._wasFocused);
      }
      this.triggerFocusEvent(isActive ? ModalizerActiveEventName : ModalizerInactiveEventName);
    }
  }
  focused(noIncrement) {
    if (!noIncrement) {
      this._wasFocused = ++_wasFocusedCounter;
    }
    return this._wasFocused;
  }
  setProps(props) {
    if (props.id) {
      this.userId = props.id;
    }
    this._props = {
      ...props
    };
  }
  dispose() {
    var _a;
    this.makeActive(false);
    this._onDispose(this);
    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();
    delete this.dummyManager;
    this._activeElements = [];
    this._remove();
  }
  isActive() {
    return !!this._isActive;
  }
  contains(element) {
    var _a;
    return !!((_a = this.getElement()) === null || _a === void 0 ? void 0 : _a.contains(element));
  }
  findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility) {
    var _a, _b;
    const modalizerElement = this.getElement();
    if (!modalizerElement) {
      return null;
    }
    const tabster = this._tabster;
    let next = null;
    let outOfDOMOrder = false;
    let uncontrolled;
    const container = currentElement && ((_a = RootAPI.getRoot(tabster, currentElement)) === null || _a === void 0 ? void 0 : _a.getElement());
    if (container) {
      const findProps = {
        container,
        currentElement,
        referenceElement,
        ignoreAccessibility,
        useActiveModalizer: true
      };
      const findPropsOut = {};
      next = tabster.focusable[isBackward ? "findPrev" : "findNext"](findProps, findPropsOut);
      if (!next && this._props.isTrapped && ((_b = tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {
        next = tabster.focusable[isBackward ? "findLast" : "findFirst"]({
          container,
          ignoreAccessibility,
          useActiveModalizer: true
        }, findPropsOut);
        outOfDOMOrder = true;
      } else {
        outOfDOMOrder = !!findPropsOut.outOfDOMOrder;
      }
      uncontrolled = findPropsOut.uncontrolled;
    }
    return {
      element: next,
      uncontrolled,
      outOfDOMOrder
    };
  }
  triggerFocusEvent(eventName, allElements) {
    const element = this.getElement();
    let defaultPrevented = false;
    if (element) {
      const elements = allElements ? this._activeElements.map((e2) => e2.get()) : [element];
      for (const el of elements) {
        if (el && !triggerEvent(el, eventName, {
          id: this.userId,
          element,
          eventName
        })) {
          defaultPrevented = true;
        }
      }
    }
    return defaultPrevented;
  }
  _remove() {
    if (true) {
      _setInformativeStyle(this._element, true);
    }
  }
};
var ModalizerAPI = class {
  constructor(tabster, alwaysAccessibleSelector, accessibleCheck) {
    this._onModalizerDispose = (modalizer) => {
      const id = modalizer.id;
      const userId = modalizer.userId;
      const part = this._parts[userId];
      delete this._modalizers[id];
      if (part) {
        delete part[id];
        if (Object.keys(part).length === 0) {
          delete this._parts[userId];
          if (this.activeId === userId) {
            this.setActive(void 0);
          }
        }
      }
    };
    this._onKeyDown = (event) => {
      var _a;
      if (event.keyCode !== Keys.Esc) {
        return;
      }
      const tabster2 = this._tabster;
      const element = tabster2.focusedElement.getFocusedElement();
      if (element) {
        const ctx = RootAPI.getTabsterContext(tabster2, element);
        const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;
        if (ctx && !ctx.groupper && (modalizer === null || modalizer === void 0 ? void 0 : modalizer.isActive()) && !ctx.ignoreKeydown(event)) {
          const activeId = modalizer.userId;
          if (activeId) {
            const part = this._parts[activeId];
            if (part) {
              const focusedSince = Object.keys(part).map((id) => {
                var _a2;
                const m3 = part[id];
                const el = m3.getElement();
                let groupper;
                if (el) {
                  groupper = (_a2 = getTabsterOnElement(this._tabster, el)) === null || _a2 === void 0 ? void 0 : _a2.groupper;
                }
                return m3 && el && groupper ? {
                  el,
                  focusedSince: m3.focused(true)
                } : {
                  focusedSince: 0
                };
              }).filter((f3) => f3.focusedSince > 0).sort((a3, b2) => a3.focusedSince > b2.focusedSince ? -1 : a3.focusedSince < b2.focusedSince ? 1 : 0);
              if (focusedSince.length) {
                const groupperElement = focusedSince[0].el;
                if (groupperElement) {
                  (_a = tabster2.groupper) === null || _a === void 0 ? void 0 : _a.handleKeyPress(groupperElement, event, true);
                }
              }
            }
          }
        }
      }
    };
    this._onFocus = (focusedElement, details) => {
      var _a, _b;
      const ctx = focusedElement && RootAPI.getTabsterContext(this._tabster, focusedElement);
      if (!ctx || !focusedElement) {
        return;
      }
      const augmentedMap = this._augMap;
      for (let e2 = focusedElement; e2; e2 = e2.parentElement) {
        if (augmentedMap.has(e2)) {
          augmentedMap.delete(e2);
          augmentAttribute(this._tabster, e2, _ariaHidden);
        }
      }
      const modalizer = ctx.modalizer;
      (_b = modalizer || ((_a = getTabsterOnElement(this._tabster, focusedElement)) === null || _a === void 0 ? void 0 : _a.modalizer)) === null || _b === void 0 ? void 0 : _b.focused();
      if ((modalizer === null || modalizer === void 0 ? void 0 : modalizer.userId) === this.activeId) {
        this.currentIsOthersAccessible = modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isOthersAccessible;
        return;
      }
      if (details.isFocusedProgrammatically || this.currentIsOthersAccessible || (modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isAlwaysAccessible)) {
        this.setActive(modalizer);
      } else {
        const win2 = this._win();
        win2.clearTimeout(this._restoreModalizerFocusTimer);
        this._restoreModalizerFocusTimer = win2.setTimeout(() => this._restoreModalizerFocus(focusedElement), 100);
      }
    };
    this._tabster = tabster;
    this._win = tabster.getWindow;
    this._modalizers = {};
    this._parts = {};
    this._augMap = /* @__PURE__ */ new WeakMap();
    this._aug = [];
    this._alwaysAccessibleSelector = alwaysAccessibleSelector;
    this._accessibleCheck = accessibleCheck;
    this.activeElements = [];
    if (!tabster.controlTab) {
      tabster.root.addDummyInputs();
    }
    const win = this._win();
    win.addEventListener("keydown", this._onKeyDown, true);
    tabster.queueInit(() => {
      this._tabster.focusedElement.subscribe(this._onFocus);
    });
  }
  dispose() {
    const win = this._win();
    win.removeEventListener("keydown", this._onKeyDown, true);
    Object.keys(this._modalizers).forEach((modalizerId) => {
      if (this._modalizers[modalizerId]) {
        this._modalizers[modalizerId].dispose();
        delete this._modalizers[modalizerId];
      }
    });
    win.clearTimeout(this._restoreModalizerFocusTimer);
    win.clearTimeout(this._hiddenUpdateTimer);
    this._parts = {};
    delete this.activeId;
    this.activeElements = [];
    this._augMap = /* @__PURE__ */ new WeakMap();
    this._aug = [];
    this._tabster.focusedElement.unsubscribe(this._onFocus);
  }
  createModalizer(element, props, sys) {
    var _a;
    if (true)
      ;
    const modalizer = new Modalizer(this._tabster, element, this._onModalizerDispose, props, sys, this.activeElements);
    const id = modalizer.id;
    const userId = props.id;
    this._modalizers[id] = modalizer;
    let part = this._parts[userId];
    if (!part) {
      part = this._parts[userId] = {};
    }
    part[id] = modalizer;
    if (element.contains((_a = this._tabster.focusedElement.getFocusedElement()) !== null && _a !== void 0 ? _a : null)) {
      if (userId !== this.activeId) {
        this.setActive(modalizer);
      } else {
        modalizer.makeActive(true);
      }
    }
    return modalizer;
  }
  isAugmented(element) {
    return this._augMap.has(element);
  }
  hiddenUpdate() {
    if (this._hiddenUpdateTimer) {
      return;
    }
    this._hiddenUpdateTimer = this._win().setTimeout(() => {
      delete this._hiddenUpdateTimer;
      this._hiddenUpdate();
    }, 250);
  }
  setActive(modalizer) {
    const userId = modalizer === null || modalizer === void 0 ? void 0 : modalizer.userId;
    const activeId = this.activeId;
    if (activeId === userId) {
      return;
    }
    this.activeId = userId;
    if (activeId) {
      const part = this._parts[activeId];
      if (part) {
        for (const id of Object.keys(part)) {
          part[id].makeActive(false);
        }
      }
    }
    if (userId) {
      const part = this._parts[userId];
      if (part) {
        for (const id of Object.keys(part)) {
          part[id].makeActive(true);
        }
      }
    }
    this.currentIsOthersAccessible = modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isOthersAccessible;
    this.hiddenUpdate();
  }
  focus(elementFromModalizer, noFocusFirst, noFocusDefault) {
    const ctx = RootAPI.getTabsterContext(this._tabster, elementFromModalizer);
    const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;
    if (modalizer) {
      this.setActive(modalizer);
      const props = modalizer.getProps();
      const modalizerRoot = modalizer.getElement();
      if (modalizerRoot) {
        if (noFocusFirst === void 0) {
          noFocusFirst = props.isNoFocusFirst;
        }
        if (!noFocusFirst && this._tabster.keyboardNavigation.isNavigatingWithKeyboard() && this._tabster.focusedElement.focusFirst({
          container: modalizerRoot
        })) {
          return true;
        }
        if (noFocusDefault === void 0) {
          noFocusDefault = props.isNoFocusDefault;
        }
        if (!noFocusDefault && this._tabster.focusedElement.focusDefault(modalizerRoot)) {
          return true;
        }
        this._tabster.focusedElement.resetFocus(modalizerRoot);
      }
    } else if (true) {
      console.error("Element is not in Modalizer.", elementFromModalizer);
    }
    return false;
  }
  acceptElement(element, state) {
    var _a;
    const modalizerUserId = state.modalizerUserId;
    const currentModalizer = (_a = state.currentCtx) === null || _a === void 0 ? void 0 : _a.modalizer;
    if (modalizerUserId) {
      for (const e2 of this.activeElements) {
        const el = e2.get();
        if (el && (element.contains(el) || el === element)) {
          return NodeFilter.FILTER_SKIP;
        }
      }
    }
    const ret = modalizerUserId === (currentModalizer === null || currentModalizer === void 0 ? void 0 : currentModalizer.userId) || !modalizerUserId && (currentModalizer === null || currentModalizer === void 0 ? void 0 : currentModalizer.getProps().isAlwaysAccessible) ? void 0 : NodeFilter.FILTER_SKIP;
    if (ret !== void 0) {
      state.skippedFocusable = true;
    }
    return ret;
  }
  _hiddenUpdate() {
    var _a;
    const tabster = this._tabster;
    const body = tabster.getWindow().document.body;
    const activeId = this.activeId;
    const parts = this._parts;
    const visibleElements = [];
    const hiddenElements = [];
    const alwaysAccessibleSelector = this._alwaysAccessibleSelector;
    const alwaysAccessibleElements = alwaysAccessibleSelector ? Array.from(body.querySelectorAll(alwaysAccessibleSelector)) : [];
    const activeModalizerElements = [];
    for (const userId of Object.keys(parts)) {
      const modalizerParts = parts[userId];
      for (const id of Object.keys(modalizerParts)) {
        const modalizer = modalizerParts[id];
        const el = modalizer.getElement();
        const props = modalizer.getProps();
        const isAlwaysAccessible = props.isAlwaysAccessible;
        if (el) {
          if (userId === activeId) {
            activeModalizerElements.push(el);
            if (!this.currentIsOthersAccessible) {
              visibleElements.push(el);
            }
          } else if (isAlwaysAccessible) {
            alwaysAccessibleElements.push(el);
          } else {
            hiddenElements.push(el);
          }
        }
      }
    }
    const augmentedMap = this._augMap;
    const allVisibleElements = visibleElements.length > 0 ? [...visibleElements, ...alwaysAccessibleElements] : void 0;
    const newAugmented = [];
    const newAugmentedMap = /* @__PURE__ */ new WeakMap();
    const toggle = (element, hide2) => {
      var _a2;
      const tagName = element.tagName;
      if (tagName === "SCRIPT" || tagName === "STYLE") {
        return;
      }
      let isAugmented = false;
      if (augmentedMap.has(element)) {
        if (hide2) {
          isAugmented = true;
        } else {
          augmentedMap.delete(element);
          augmentAttribute(tabster, element, _ariaHidden);
        }
      } else if (hide2 && !((_a2 = this._accessibleCheck) === null || _a2 === void 0 ? void 0 : _a2.call(this, element, activeModalizerElements)) && augmentAttribute(tabster, element, _ariaHidden, "true")) {
        augmentedMap.set(element, true);
        isAugmented = true;
      }
      if (isAugmented) {
        newAugmented.push(new WeakHTMLElement(tabster.getWindow, element));
        newAugmentedMap.set(element, true);
      }
    };
    const walk = (element) => {
      for (let el = element.firstElementChild; el; el = el.nextElementSibling) {
        let skip = false;
        let containsModalizer = false;
        if (allVisibleElements) {
          for (const c3 of allVisibleElements) {
            if (el === c3) {
              skip = true;
              break;
            }
            if (el.contains(c3)) {
              containsModalizer = true;
              break;
            }
          }
          if (containsModalizer) {
            walk(el);
          } else if (!skip) {
            toggle(el, true);
          }
        } else {
          toggle(el, false);
        }
      }
    };
    if (!allVisibleElements) {
      alwaysAccessibleElements.forEach((e2) => toggle(e2, false));
    }
    hiddenElements.forEach((e2) => toggle(e2, true));
    if (body) {
      walk(body);
    }
    (_a = this._aug) === null || _a === void 0 ? void 0 : _a.map((e2) => e2.get()).forEach((e2) => {
      if (e2 && !newAugmentedMap.get(e2)) {
        toggle(e2, false);
      }
    });
    this._aug = newAugmented;
    this._augMap = newAugmentedMap;
  }
  /**
   * Called when an element is focused outside of an active modalizer.
   * Attempts to pull focus back into the active modalizer
   * @param outsideElement - An element being focused outside of the modalizer
   */
  _restoreModalizerFocus(outsideElement) {
    const ownerDocument = outsideElement === null || outsideElement === void 0 ? void 0 : outsideElement.ownerDocument;
    if (!outsideElement || !ownerDocument) {
      return;
    }
    const ctx = RootAPI.getTabsterContext(this._tabster, outsideElement);
    const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;
    const activeId = this.activeId;
    if (!modalizer && !activeId || modalizer && activeId === modalizer.userId) {
      return;
    }
    const container = ctx === null || ctx === void 0 ? void 0 : ctx.root.getElement();
    if (container) {
      let toFocus = this._tabster.focusable.findFirst({
        container,
        useActiveModalizer: true
      });
      if (toFocus) {
        if (outsideElement.compareDocumentPosition(toFocus) & document.DOCUMENT_POSITION_PRECEDING) {
          toFocus = this._tabster.focusable.findLast({
            container,
            useActiveModalizer: true
          });
          if (!toFocus) {
            throw new Error("Something went wrong.");
          }
        }
        this._tabster.focusedElement.focus(toFocus);
        return;
      }
    }
    outsideElement.blur();
  }
};
var _inputSelector = ["input", "textarea", "*[contenteditable]"].join(", ");
var MoverDummyManager = class extends DummyInputManager {
  constructor(element, tabster, getMemorized, sys) {
    super(tabster, element, DummyInputManagerPriorities.Mover, sys);
    this._onFocusDummyInput = (dummyInput) => {
      var _a, _b;
      const container = this._element.get();
      const input = dummyInput.input;
      if (container && input) {
        const ctx = RootAPI.getTabsterContext(this._tabster, container);
        let toFocus;
        if (ctx) {
          toFocus = (_a = FocusedElementState.findNextTabbable(this._tabster, ctx, void 0, input, void 0, !dummyInput.isFirst, true)) === null || _a === void 0 ? void 0 : _a.element;
        }
        const memorized = (_b = this._getMemorized()) === null || _b === void 0 ? void 0 : _b.get();
        if (memorized) {
          toFocus = memorized;
        }
        if (toFocus) {
          nativeFocus(toFocus);
        }
      }
    };
    this._tabster = tabster;
    this._getMemorized = getMemorized;
    this._setHandlers(this._onFocusDummyInput);
  }
};
var _moverUpdateAdd = 1;
var _moverUpdateAttr = 2;
var _moverUpdateRemove = 3;
var Mover = class extends TabsterPart {
  constructor(tabster, element, onDispose, props, sys) {
    var _a;
    super(tabster, element, props);
    this._visible = {};
    this._onIntersection = (entries) => {
      for (const entry of entries) {
        const el = entry.target;
        const id = getElementUId(this._win, el);
        let newVisibility;
        let fullyVisible = this._fullyVisible;
        if (entry.intersectionRatio >= 0.25) {
          newVisibility = entry.intersectionRatio >= 0.75 ? Visibilities.Visible : Visibilities.PartiallyVisible;
          if (newVisibility === Visibilities.Visible) {
            fullyVisible = id;
          }
        } else {
          newVisibility = Visibilities.Invisible;
        }
        if (this._visible[id] !== newVisibility) {
          if (newVisibility === void 0) {
            delete this._visible[id];
            if (fullyVisible === id) {
              delete this._fullyVisible;
            }
          } else {
            this._visible[id] = newVisibility;
            this._fullyVisible = fullyVisible;
          }
          const state = this.getState(el);
          if (state) {
            triggerEvent(el, MoverEventName, state);
          }
        }
      }
    };
    this._win = tabster.getWindow;
    this.visibilityTolerance = (_a = props.visibilityTolerance) !== null && _a !== void 0 ? _a : 0.8;
    if (this._props.trackState || this._props.visibilityAware) {
      this._intersectionObserver = new IntersectionObserver(this._onIntersection, {
        threshold: [0, 0.25, 0.5, 0.75, 1]
      });
      this._observeState();
    }
    this._onDispose = onDispose;
    const getMemorized = () => props.memorizeCurrent ? this._current : void 0;
    if (!tabster.controlTab) {
      this.dummyManager = new MoverDummyManager(this._element, tabster, getMemorized, sys);
    }
  }
  dispose() {
    var _a;
    this._onDispose(this);
    if (this._intersectionObserver) {
      this._intersectionObserver.disconnect();
      delete this._intersectionObserver;
    }
    delete this._current;
    delete this._fullyVisible;
    delete this._allElements;
    delete this._updateQueue;
    if (this._unobserve) {
      this._unobserve();
      delete this._unobserve;
    }
    const win = this._win();
    if (this._setCurrentTimer) {
      win.clearTimeout(this._setCurrentTimer);
      delete this._setCurrentTimer;
    }
    if (this._updateTimer) {
      win.clearTimeout(this._updateTimer);
      delete this._updateTimer;
    }
    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();
    delete this.dummyManager;
  }
  setCurrent(element) {
    if (element) {
      this._current = new WeakHTMLElement(this._win, element);
    } else {
      this._current = void 0;
    }
    if ((this._props.trackState || this._props.visibilityAware) && !this._setCurrentTimer) {
      this._setCurrentTimer = this._win().setTimeout(() => {
        var _a;
        delete this._setCurrentTimer;
        const changed = [];
        if (this._current !== this._prevCurrent) {
          changed.push(this._current);
          changed.push(this._prevCurrent);
          this._prevCurrent = this._current;
        }
        for (const weak of changed) {
          const el = weak === null || weak === void 0 ? void 0 : weak.get();
          if (el && ((_a = this._allElements) === null || _a === void 0 ? void 0 : _a.get(el)) === this) {
            const props = this._props;
            if (el && (props.visibilityAware !== void 0 || props.trackState)) {
              const state = this.getState(el);
              if (state) {
                triggerEvent(el, MoverEventName, state);
              }
            }
          }
        }
      });
    }
  }
  getCurrent() {
    var _a;
    return ((_a = this._current) === null || _a === void 0 ? void 0 : _a.get()) || null;
  }
  findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility) {
    var _a;
    const container = this.getElement();
    const currentIsDummy = container && ((_a = currentElement === null || currentElement === void 0 ? void 0 : currentElement.__tabsterDummyContainer) === null || _a === void 0 ? void 0 : _a.get()) === container;
    if (!container) {
      return null;
    }
    let next = null;
    let outOfDOMOrder = false;
    let uncontrolled;
    if (this._props.tabbable || currentIsDummy || currentElement && !container.contains(currentElement)) {
      const findProps = {
        currentElement,
        referenceElement,
        container,
        ignoreAccessibility,
        useActiveModalizer: true
      };
      const findPropsOut = {};
      next = this._tabster.focusable[isBackward ? "findPrev" : "findNext"](findProps, findPropsOut);
      outOfDOMOrder = !!findPropsOut.outOfDOMOrder;
      uncontrolled = findPropsOut.uncontrolled;
    }
    return {
      element: next,
      uncontrolled,
      outOfDOMOrder
    };
  }
  acceptElement(element, state) {
    var _a, _b, _c;
    if (!FocusedElementState.isTabbing) {
      return ((_a = state.currentCtx) === null || _a === void 0 ? void 0 : _a.excludedFromMover) ? NodeFilter.FILTER_REJECT : void 0;
    }
    const {
      memorizeCurrent,
      visibilityAware,
      hasDefault = true
    } = this._props;
    const moverElement = this.getElement();
    if (moverElement && (memorizeCurrent || visibilityAware || hasDefault) && (!moverElement.contains(state.from) || ((_b = state.from.__tabsterDummyContainer) === null || _b === void 0 ? void 0 : _b.get()) === moverElement)) {
      let found;
      if (memorizeCurrent) {
        const current = (_c = this._current) === null || _c === void 0 ? void 0 : _c.get();
        if (current && state.acceptCondition(current)) {
          found = current;
        }
      }
      if (!found && hasDefault) {
        found = this._tabster.focusable.findDefault({
          container: moverElement,
          useActiveModalizer: true
        });
      }
      if (!found && visibilityAware) {
        found = this._tabster.focusable.findElement({
          container: moverElement,
          useActiveModalizer: true,
          isBackward: state.isBackward,
          acceptCondition: (el) => {
            var _a2;
            const id = getElementUId(this._win, el);
            const visibility = this._visible[id];
            return moverElement !== el && !!((_a2 = this._allElements) === null || _a2 === void 0 ? void 0 : _a2.get(el)) && state.acceptCondition(el) && (visibility === Visibilities.Visible || visibility === Visibilities.PartiallyVisible && (visibilityAware === Visibilities.PartiallyVisible || !this._fullyVisible));
          }
        });
      }
      if (found) {
        state.found = true;
        state.foundElement = found;
        state.rejectElementsFrom = moverElement;
        state.skippedFocusable = true;
        return NodeFilter.FILTER_ACCEPT;
      }
    }
    return void 0;
  }
  _observeState() {
    const element = this.getElement();
    if (this._unobserve || !element || typeof MutationObserver === "undefined") {
      return;
    }
    const win = this._win();
    const allElements = this._allElements = /* @__PURE__ */ new WeakMap();
    const tabsterFocusable = this._tabster.focusable;
    let updateQueue = this._updateQueue = [];
    const observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        const target = mutation.target;
        const removed = mutation.removedNodes;
        const added = mutation.addedNodes;
        if (mutation.type === "attributes") {
          if (mutation.attributeName === "tabindex") {
            updateQueue.push({
              element: target,
              type: _moverUpdateAttr
            });
          }
        } else {
          for (let i3 = 0; i3 < removed.length; i3++) {
            updateQueue.push({
              element: removed[i3],
              type: _moverUpdateRemove
            });
          }
          for (let i3 = 0; i3 < added.length; i3++) {
            updateQueue.push({
              element: added[i3],
              type: _moverUpdateAdd
            });
          }
        }
      }
      requestUpdate();
    });
    const setElement = (element2, remove) => {
      var _a, _b;
      const current = allElements.get(element2);
      if (current && remove) {
        (_a = this._intersectionObserver) === null || _a === void 0 ? void 0 : _a.unobserve(element2);
        allElements.delete(element2);
      }
      if (!current && !remove) {
        allElements.set(element2, this);
        (_b = this._intersectionObserver) === null || _b === void 0 ? void 0 : _b.observe(element2);
      }
    };
    const updateElement = (element2) => {
      const isFocusable = tabsterFocusable.isFocusable(element2);
      const current = allElements.get(element2);
      if (current) {
        if (!isFocusable) {
          setElement(element2, true);
        }
      } else {
        if (isFocusable) {
          setElement(element2);
        }
      }
    };
    const addNewElements = (element2) => {
      const {
        mover
      } = getMoverGroupper(element2);
      if (mover && mover !== this) {
        if (mover.getElement() === element2 && tabsterFocusable.isFocusable(element2)) {
          setElement(element2);
        } else {
          return;
        }
      }
      const walker = createElementTreeWalker(win.document, element2, (node) => {
        const {
          mover: mover2,
          groupper
        } = getMoverGroupper(node);
        if (mover2 && mover2 !== this) {
          return NodeFilter.FILTER_REJECT;
        }
        const groupperFirstFocusable = groupper === null || groupper === void 0 ? void 0 : groupper.getFirst(true);
        if (groupper && groupper.getElement() !== node && groupperFirstFocusable && groupperFirstFocusable !== node) {
          return NodeFilter.FILTER_REJECT;
        }
        if (tabsterFocusable.isFocusable(node)) {
          setElement(node);
        }
        return NodeFilter.FILTER_SKIP;
      });
      if (walker) {
        walker.currentNode = element2;
        while (walker.nextNode()) {
        }
      }
    };
    const removeWalk = (element2) => {
      const current = allElements.get(element2);
      if (current) {
        setElement(element2, true);
      }
      for (let el = element2.firstElementChild; el; el = el.nextElementSibling) {
        removeWalk(el);
      }
    };
    const requestUpdate = () => {
      if (!this._updateTimer && updateQueue.length) {
        this._updateTimer = win.setTimeout(() => {
          delete this._updateTimer;
          for (const {
            element: element2,
            type
          } of updateQueue) {
            switch (type) {
              case _moverUpdateAttr:
                updateElement(element2);
                break;
              case _moverUpdateAdd:
                addNewElements(element2);
                break;
              case _moverUpdateRemove:
                removeWalk(element2);
                break;
            }
          }
          updateQueue = this._updateQueue = [];
        }, 0);
      }
    };
    const getMoverGroupper = (element2) => {
      const ret = {};
      for (let el = element2; el; el = el.parentElement) {
        const toe = getTabsterOnElement(this._tabster, el);
        if (toe) {
          if (toe.groupper && !ret.groupper) {
            ret.groupper = toe.groupper;
          }
          if (toe.mover) {
            ret.mover = toe.mover;
            break;
          }
        }
      }
      return ret;
    };
    updateQueue.push({
      element,
      type: _moverUpdateAdd
    });
    requestUpdate();
    observer.observe(element, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: ["tabindex"]
    });
    this._unobserve = () => {
      observer.disconnect();
    };
  }
  getState(element) {
    const id = getElementUId(this._win, element);
    if (id in this._visible) {
      const visibility = this._visible[id] || Visibilities.Invisible;
      const isCurrent = this._current ? this._current.get() === element : void 0;
      return {
        isCurrent,
        visibility
      };
    }
    return void 0;
  }
};
function getDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {
  const xDistance = ax2 < bx1 ? bx1 - ax2 : bx2 < ax1 ? ax1 - bx2 : 0;
  const yDistance = ay2 < by1 ? by1 - ay2 : by2 < ay1 ? ay1 - by2 : 0;
  return xDistance === 0 ? yDistance : yDistance === 0 ? xDistance : Math.sqrt(xDistance * xDistance + yDistance * yDistance);
}
var MoverAPI = class {
  constructor(tabster, getWindow2) {
    this._init = () => {
      const win = this._win();
      win.addEventListener("keydown", this._onKeyDown, true);
      this._tabster.focusedElement.subscribe(this._onFocus);
    };
    this._onMoverDispose = (mover) => {
      delete this._movers[mover.id];
    };
    this._onFocus = (element) => {
      var _a;
      let currentFocusableElement = element;
      let deepestFocusableElement = element;
      for (let el = element === null || element === void 0 ? void 0 : element.parentElement; el; el = el.parentElement) {
        const mover = (_a = getTabsterOnElement(this._tabster, el)) === null || _a === void 0 ? void 0 : _a.mover;
        if (mover) {
          mover.setCurrent(deepestFocusableElement);
          currentFocusableElement = void 0;
        }
        if (!currentFocusableElement && this._tabster.focusable.isFocusable(el)) {
          currentFocusableElement = deepestFocusableElement = el;
        }
      }
    };
    this._onKeyDown = async (event) => {
      var _a, _b, _c, _d;
      if (this._ignoredInputTimer) {
        this._win().clearTimeout(this._ignoredInputTimer);
        delete this._ignoredInputTimer;
      }
      (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);
      let keyCode = event.keyCode;
      if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {
        return;
      }
      switch (keyCode) {
        case Keys.Down:
        case Keys.Right:
        case Keys.Up:
        case Keys.Left:
        case Keys.PageDown:
        case Keys.PageUp:
        case Keys.Home:
        case Keys.End:
          break;
        default:
          return;
      }
      const tabster2 = this._tabster;
      const focused = tabster2.focusedElement.getFocusedElement();
      if (!focused || await this._isIgnoredInput(focused, keyCode)) {
        return;
      }
      const ctx = RootAPI.getTabsterContext(tabster2, focused, {
        checkRtl: true
      });
      if (!ctx || !ctx.mover || ctx.excludedFromMover || ctx.ignoreKeydown(event)) {
        return;
      }
      const mover = ctx.mover;
      const container = mover.getElement();
      if (ctx.groupperBeforeMover) {
        const groupper = ctx.groupper;
        if (groupper && !groupper.isActive(true)) {
          for (let el = (_b = groupper.getElement()) === null || _b === void 0 ? void 0 : _b.parentElement; el && el !== container; el = el.parentElement) {
            if ((_d = (_c = getTabsterOnElement(tabster2, el)) === null || _c === void 0 ? void 0 : _c.groupper) === null || _d === void 0 ? void 0 : _d.isActive(true)) {
              return;
            }
          }
        } else {
          return;
        }
      }
      if (!container) {
        return;
      }
      const focusable = tabster2.focusable;
      const moverProps = mover.getProps();
      const direction = moverProps.direction || MoverDirections.Both;
      const isBoth = direction === MoverDirections.Both;
      const isVertical = isBoth || direction === MoverDirections.Vertical;
      const isHorizontal = isBoth || direction === MoverDirections.Horizontal;
      const isGridLinear = direction === MoverDirections.GridLinear;
      const isGrid = isGridLinear || direction === MoverDirections.Grid;
      const isCyclic = moverProps.cyclic;
      let next;
      let focusedElementRect;
      let focusedElementX1 = 0;
      let focusedElementX2 = 0;
      if (isGrid) {
        focusedElementRect = focused.getBoundingClientRect();
        focusedElementX1 = Math.ceil(focusedElementRect.left);
        focusedElementX2 = Math.floor(focusedElementRect.right);
      }
      if (ctx.rtl) {
        if (keyCode === Keys.Right) {
          keyCode = Keys.Left;
        } else if (keyCode === Keys.Left) {
          keyCode = Keys.Right;
        }
      }
      if (keyCode === Keys.Down && isVertical || keyCode === Keys.Right && (isHorizontal || isGrid)) {
        next = focusable.findNext({
          currentElement: focused,
          container,
          useActiveModalizer: true
        });
        if (next && isGrid) {
          const nextElementX1 = Math.ceil(next.getBoundingClientRect().left);
          if (!isGridLinear && focusedElementX2 > nextElementX1) {
            next = void 0;
          }
        } else if (!next && isCyclic) {
          next = focusable.findFirst({
            container,
            useActiveModalizer: true
          });
        }
      } else if (keyCode === Keys.Up && isVertical || keyCode === Keys.Left && (isHorizontal || isGrid)) {
        next = focusable.findPrev({
          currentElement: focused,
          container,
          useActiveModalizer: true
        });
        if (next && isGrid) {
          const nextElementX2 = Math.floor(next.getBoundingClientRect().right);
          if (!isGridLinear && nextElementX2 > focusedElementX1) {
            next = void 0;
          }
        } else if (!next && isCyclic) {
          next = focusable.findLast({
            container,
            useActiveModalizer: true
          });
        }
      } else if (keyCode === Keys.Home) {
        if (isGrid) {
          focusable.findElement({
            container,
            currentElement: focused,
            useActiveModalizer: true,
            isBackward: true,
            acceptCondition: (el) => {
              var _a2;
              if (!focusable.isFocusable(el)) {
                return false;
              }
              const nextElementX1 = Math.ceil((_a2 = el.getBoundingClientRect().left) !== null && _a2 !== void 0 ? _a2 : 0);
              if (el !== focused && focusedElementX1 <= nextElementX1) {
                return true;
              }
              next = el;
              return false;
            }
          });
        } else {
          next = focusable.findFirst({
            container,
            useActiveModalizer: true
          });
        }
      } else if (keyCode === Keys.End) {
        if (isGrid) {
          focusable.findElement({
            container,
            currentElement: focused,
            useActiveModalizer: true,
            acceptCondition: (el) => {
              var _a2;
              if (!focusable.isFocusable(el)) {
                return false;
              }
              const nextElementX1 = Math.ceil((_a2 = el.getBoundingClientRect().left) !== null && _a2 !== void 0 ? _a2 : 0);
              if (el !== focused && focusedElementX1 >= nextElementX1) {
                return true;
              }
              next = el;
              return false;
            }
          });
        } else {
          next = focusable.findLast({
            container,
            useActiveModalizer: true
          });
        }
      } else if (keyCode === Keys.PageUp) {
        focusable.findElement({
          currentElement: focused,
          container,
          useActiveModalizer: true,
          isBackward: true,
          acceptCondition: (el) => {
            if (!focusable.isFocusable(el)) {
              return false;
            }
            if (isElementVerticallyVisibleInContainer(this._win, el, mover.visibilityTolerance)) {
              next = el;
              return false;
            }
            return true;
          }
        });
        if (isGrid && next) {
          const firstColumnX1 = Math.ceil(next.getBoundingClientRect().left);
          focusable.findElement({
            currentElement: next,
            container,
            useActiveModalizer: true,
            acceptCondition: (el) => {
              if (!focusable.isFocusable(el)) {
                return false;
              }
              const nextElementX1 = Math.ceil(el.getBoundingClientRect().left);
              if (focusedElementX1 < nextElementX1 || firstColumnX1 >= nextElementX1) {
                return true;
              }
              next = el;
              return false;
            }
          });
        }
        if (next) {
          scrollIntoView(this._win, next, false);
        }
      } else if (keyCode === Keys.PageDown) {
        focusable.findElement({
          currentElement: focused,
          container,
          useActiveModalizer: true,
          acceptCondition: (el) => {
            if (!focusable.isFocusable(el)) {
              return false;
            }
            if (isElementVerticallyVisibleInContainer(this._win, el, mover.visibilityTolerance)) {
              next = el;
              return false;
            }
            return true;
          }
        });
        if (isGrid && next) {
          const lastColumnX1 = Math.ceil(next.getBoundingClientRect().left);
          focusable.findElement({
            currentElement: next,
            container,
            useActiveModalizer: true,
            isBackward: true,
            acceptCondition: (el) => {
              if (!focusable.isFocusable(el)) {
                return false;
              }
              const nextElementX1 = Math.ceil(el.getBoundingClientRect().left);
              if (focusedElementX1 > nextElementX1 || lastColumnX1 <= nextElementX1) {
                return true;
              }
              next = el;
              return false;
            }
          });
        }
        if (next) {
          scrollIntoView(this._win, next, true);
        }
      } else if (isGrid) {
        const isBackward = keyCode === Keys.Up;
        const ax1 = focusedElementX1;
        const ay1 = Math.ceil(focusedElementRect.top);
        const ax2 = focusedElementX2;
        const ay2 = Math.floor(focusedElementRect.bottom);
        let targetElement;
        let lastDistance;
        let lastIntersection = 0;
        focusable.findAll({
          container,
          currentElement: focused,
          isBackward,
          onElement: (el) => {
            const rect = el.getBoundingClientRect();
            const bx1 = Math.ceil(rect.left);
            const by1 = Math.ceil(rect.top);
            const bx2 = Math.floor(rect.right);
            const by2 = Math.floor(rect.bottom);
            if (isBackward && ay1 < by2 || !isBackward && ay2 > by1) {
              return true;
            }
            const xIntersectionWidth = Math.ceil(Math.min(ax2, bx2)) - Math.floor(Math.max(ax1, bx1));
            const minWidth = Math.ceil(Math.min(ax2 - ax1, bx2 - bx1));
            if (xIntersectionWidth > 0 && minWidth >= xIntersectionWidth) {
              const intersection = xIntersectionWidth / minWidth;
              if (intersection > lastIntersection) {
                targetElement = el;
                lastIntersection = intersection;
              }
            } else if (lastIntersection === 0) {
              const distance = getDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2);
              if (lastDistance === void 0 || distance < lastDistance) {
                lastDistance = distance;
                targetElement = el;
              }
            } else if (lastIntersection > 0) {
              return false;
            }
            return true;
          }
        });
        next = targetElement;
      }
      if (next) {
        event.preventDefault();
        event.stopImmediatePropagation();
        nativeFocus(next);
      }
    };
    this._tabster = tabster;
    this._win = getWindow2;
    this._movers = {};
    tabster.queueInit(this._init);
  }
  dispose() {
    var _a;
    const win = this._win();
    this._tabster.focusedElement.unsubscribe(this._onFocus);
    (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);
    if (this._ignoredInputTimer) {
      win.clearTimeout(this._ignoredInputTimer);
      delete this._ignoredInputTimer;
    }
    win.removeEventListener("keydown", this._onKeyDown, true);
    Object.keys(this._movers).forEach((moverId) => {
      if (this._movers[moverId]) {
        this._movers[moverId].dispose();
        delete this._movers[moverId];
      }
    });
  }
  createMover(element, props, sys) {
    if (true)
      ;
    const newMover = new Mover(this._tabster, element, this._onMoverDispose, props, sys);
    this._movers[newMover.id] = newMover;
    return newMover;
  }
  async _isIgnoredInput(element, keyCode) {
    var _a;
    if (element.getAttribute("aria-expanded") === "true" && element.hasAttribute("aria-activedescendant")) {
      return true;
    }
    if (matchesSelector(element, _inputSelector)) {
      let selectionStart = 0;
      let selectionEnd = 0;
      let textLength = 0;
      let asyncRet;
      if (element.tagName === "INPUT" || element.tagName === "TEXTAREA") {
        const type = element.type;
        const value = element.value;
        textLength = (value || "").length;
        if (type === "email" || type === "number") {
          if (textLength) {
            const selection = (_a = element.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.getSelection();
            if (selection) {
              const initialLength = selection.toString().length;
              const isBackward = keyCode === Keys.Left || keyCode === Keys.Up;
              selection.modify("extend", isBackward ? "backward" : "forward", "character");
              if (initialLength !== selection.toString().length) {
                selection.modify("extend", isBackward ? "forward" : "backward", "character");
                return true;
              } else {
                textLength = 0;
              }
            }
          }
        } else {
          const selStart = element.selectionStart;
          if (selStart === null) {
            return type === "hidden";
          }
          selectionStart = selStart || 0;
          selectionEnd = element.selectionEnd || 0;
        }
      } else if (element.contentEditable === "true") {
        asyncRet = new (getPromise(this._win))((resolve) => {
          this._ignoredInputResolve = (value) => {
            delete this._ignoredInputResolve;
            resolve(value);
          };
          const win = this._win();
          if (this._ignoredInputTimer) {
            win.clearTimeout(this._ignoredInputTimer);
          }
          const {
            anchorNode: prevAnchorNode,
            focusNode: prevFocusNode,
            anchorOffset: prevAnchorOffset,
            focusOffset: prevFocusOffset
          } = win.getSelection() || {};
          this._ignoredInputTimer = win.setTimeout(() => {
            var _a2, _b, _c;
            delete this._ignoredInputTimer;
            const {
              anchorNode,
              focusNode,
              anchorOffset,
              focusOffset
            } = win.getSelection() || {};
            if (anchorNode !== prevAnchorNode || focusNode !== prevFocusNode || anchorOffset !== prevAnchorOffset || focusOffset !== prevFocusOffset) {
              (_a2 = this._ignoredInputResolve) === null || _a2 === void 0 ? void 0 : _a2.call(this, false);
              return;
            }
            selectionStart = anchorOffset || 0;
            selectionEnd = focusOffset || 0;
            textLength = ((_b = element.textContent) === null || _b === void 0 ? void 0 : _b.length) || 0;
            if (anchorNode && focusNode) {
              if (element.contains(anchorNode) && element.contains(focusNode)) {
                if (anchorNode !== element) {
                  let anchorFound = false;
                  const addOffsets = (node) => {
                    if (node === anchorNode) {
                      anchorFound = true;
                    } else if (node === focusNode) {
                      return true;
                    }
                    const nodeText = node.textContent;
                    if (nodeText && !node.firstChild) {
                      const len = nodeText.length;
                      if (anchorFound) {
                        if (focusNode !== anchorNode) {
                          selectionEnd += len;
                        }
                      } else {
                        selectionStart += len;
                        selectionEnd += len;
                      }
                    }
                    let stop = false;
                    for (let e2 = node.firstChild; e2 && !stop; e2 = e2.nextSibling) {
                      stop = addOffsets(e2);
                    }
                    return stop;
                  };
                  addOffsets(element);
                }
              }
            }
            (_c = this._ignoredInputResolve) === null || _c === void 0 ? void 0 : _c.call(this, true);
          }, 0);
        });
      }
      if (asyncRet && !await asyncRet) {
        return true;
      }
      if (selectionStart !== selectionEnd) {
        return true;
      }
      if (selectionStart > 0 && (keyCode === Keys.Left || keyCode === Keys.Up || keyCode === Keys.Home)) {
        return true;
      }
      if (selectionStart < textLength && (keyCode === Keys.Right || keyCode === Keys.Down || keyCode === Keys.End)) {
        return true;
      }
    }
    return false;
  }
};
function observeMutations(doc, tabster, updateTabsterByAttribute2, syncState) {
  if (typeof MutationObserver === "undefined") {
    return () => {
    };
  }
  const getWindow2 = tabster.getWindow;
  let elementByUId;
  const onMutation = (mutations) => {
    var _a, _b, _c, _d, _e;
    for (const mutation of mutations) {
      const target = mutation.target;
      const removed = mutation.removedNodes;
      const added = mutation.addedNodes;
      if (mutation.type === "attributes") {
        if (mutation.attributeName === TabsterAttributeName) {
          updateTabsterByAttribute2(tabster, target);
        }
      } else {
        for (let i3 = 0; i3 < removed.length; i3++) {
          updateTabsterElements(removed[i3], true);
          (_b = (_a = tabster._dummyObserver).domChanged) === null || _b === void 0 ? void 0 : _b.call(_a, target);
        }
        for (let i3 = 0; i3 < added.length; i3++) {
          updateTabsterElements(added[i3]);
          (_d = (_c = tabster._dummyObserver).domChanged) === null || _d === void 0 ? void 0 : _d.call(_c, target);
        }
      }
    }
    (_e = tabster.modalizer) === null || _e === void 0 ? void 0 : _e.hiddenUpdate();
  };
  function updateTabsterElements(node, removed) {
    if (!elementByUId) {
      elementByUId = getInstanceContext(getWindow2).elementByUId;
    }
    processNode(node, removed);
    const walker = createElementTreeWalker(doc, node, (element) => {
      return processNode(element, removed);
    });
    if (walker) {
      while (walker.nextNode()) {
      }
    }
  }
  function processNode(element, removed) {
    var _a;
    if (!element.getAttribute) {
      return NodeFilter.FILTER_SKIP;
    }
    const uid = element.__tabsterElementUID;
    if (uid && elementByUId) {
      if (removed) {
        delete elementByUId[uid];
      } else {
        (_a = elementByUId[uid]) !== null && _a !== void 0 ? _a : elementByUId[uid] = new WeakHTMLElement(getWindow2, element);
      }
    }
    if (getTabsterOnElement(tabster, element) || element.hasAttribute(TabsterAttributeName)) {
      updateTabsterByAttribute2(tabster, element, removed);
    }
    return NodeFilter.FILTER_SKIP;
  }
  const observer = new MutationObserver(onMutation);
  if (syncState) {
    updateTabsterElements(getWindow2().document.body);
  }
  observer.observe(doc, {
    childList: true,
    subtree: true,
    attributes: true,
    attributeFilter: [TabsterAttributeName]
  });
  return () => {
    observer.disconnect();
  };
}
var _conditionCheckTimeout = 100;
var ObservedElementAPI = class extends Subscribable {
  constructor(tabster) {
    super();
    this._waiting = {};
    this._lastRequestFocusId = 0;
    this._observedById = {};
    this._observedByName = {};
    this._currentRequestTimestamp = 0;
    this._onFocus = (e2) => {
      if (e2) {
        const current = this._currentRequest;
        if (current) {
          const delta = Date.now() - this._currentRequestTimestamp;
          const settleTime = 300;
          if (delta >= settleTime) {
            delete this._currentRequest;
            current.cancel();
          }
        }
      }
    };
    this.onObservedElementUpdate = (element) => {
      var _a;
      const observed = (_a = getTabsterOnElement(this._tabster, element)) === null || _a === void 0 ? void 0 : _a.observed;
      const uid = getElementUId(this._win, element);
      let info = this._observedById[uid];
      if (observed && documentContains(element.ownerDocument, element)) {
        if (!info) {
          info = this._observedById[uid] = {
            element: new WeakHTMLElement(this._win, element)
          };
        }
        observed.names.sort();
        const observedNames = observed.names;
        const prevNames = info.prevNames;
        if (this._isObservedNamesUpdated(observedNames, prevNames)) {
          if (prevNames) {
            prevNames.forEach((prevName) => {
              const obn = this._observedByName[prevName];
              if (obn && obn[uid]) {
                if (Object.keys(obn).length > 1) {
                  delete obn[uid];
                } else {
                  delete this._observedByName[prevName];
                }
              }
            });
          }
          info.prevNames = observedNames;
        }
        observedNames.forEach((observedName) => {
          let obn = this._observedByName[observedName];
          if (!obn) {
            obn = this._observedByName[observedName] = {};
          }
          obn[uid] = info;
          this._waitConditional(observedName);
        });
      } else if (info) {
        const prevNames = info.prevNames;
        if (prevNames) {
          prevNames.forEach((prevName) => {
            const obn = this._observedByName[prevName];
            if (obn && obn[uid]) {
              if (Object.keys(obn).length > 1) {
                delete obn[uid];
              } else {
                delete this._observedByName[prevName];
              }
            }
          });
        }
        delete this._observedById[uid];
      }
    };
    this._tabster = tabster;
    this._win = tabster.getWindow;
    tabster.queueInit(() => {
      this._tabster.focusedElement.subscribe(this._onFocus);
    });
  }
  dispose() {
    this._tabster.focusedElement.unsubscribe(this._onFocus);
    for (const key of Object.keys(this._waiting)) {
      this._rejectWaiting(key);
    }
    this._observedById = {};
    this._observedByName = {};
  }
  _rejectWaiting(key, shouldResolve) {
    const w3 = this._waiting[key];
    if (w3) {
      const win = this._win();
      if (w3.timer) {
        win.clearTimeout(w3.timer);
      }
      if (w3.conditionTimer) {
        win.clearTimeout(w3.conditionTimer);
      }
      if (!shouldResolve && w3.reject) {
        w3.reject();
      } else if (shouldResolve && w3.resolve) {
        w3.resolve(null);
      }
      delete this._waiting[key];
    }
  }
  _isObservedNamesUpdated(cur, prev) {
    if (!prev || cur.length !== prev.length) {
      return true;
    }
    for (let i3 = 0; i3 < cur.length; ++i3) {
      if (cur[i3] !== prev[i3]) {
        return true;
      }
    }
    return false;
  }
  /**
   * Returns existing element by observed name
   *
   * @param observedName An observed name
   * @param accessibility Optionally, return only if the element is accessible or focusable
   * @returns HTMLElement | null
   */
  getElement(observedName, accessibility) {
    const o2 = this._observedByName[observedName];
    if (o2) {
      for (const uid of Object.keys(o2)) {
        let el = o2[uid].element.get() || null;
        if (el) {
          if (accessibility === ObservedElementAccesibilities.Accessible && !this._tabster.focusable.isAccessible(el) || accessibility === ObservedElementAccesibilities.Focusable && !this._tabster.focusable.isFocusable(el, true)) {
            el = null;
          }
        } else {
          delete o2[uid];
          delete this._observedById[uid];
        }
        return el;
      }
    }
    return null;
  }
  /**
   * Waits for the element to appear in the DOM and returns it.
   *
   * @param observedName An observed name
   * @param timeout Wait no longer than this timeout
   * @param accessibility Optionally, wait for the element to also become accessible or focusable before returning it
   * @returns Promise<HTMLElement | null>
   */
  waitElement(observedName, timeout, accessibility) {
    const el = this.getElement(observedName, accessibility);
    if (el) {
      return {
        result: getPromise(this._win).resolve(el),
        cancel: () => {
        }
      };
    }
    let prefix;
    if (accessibility === ObservedElementAccesibilities.Accessible) {
      prefix = "a";
    } else if (accessibility === ObservedElementAccesibilities.Focusable) {
      prefix = "f";
    } else {
      prefix = "_";
    }
    const key = prefix + observedName;
    let w3 = this._waiting[key];
    if (w3 && w3.request) {
      return w3.request;
    }
    w3 = this._waiting[key] = {
      timer: this._win().setTimeout(() => {
        if (w3.conditionTimer) {
          this._win().clearTimeout(w3.conditionTimer);
        }
        delete this._waiting[key];
        if (w3.resolve) {
          w3.resolve(null);
        }
      }, timeout)
    };
    const promise = new (getPromise(this._win))((resolve, reject) => {
      w3.resolve = resolve;
      w3.reject = reject;
    });
    w3.request = {
      result: promise,
      cancel: () => {
        this._rejectWaiting(key, true);
      }
    };
    if (accessibility && this.getElement(observedName)) {
      this._waitConditional(observedName);
    }
    return w3.request;
  }
  requestFocus(observedName, timeout) {
    const requestId = ++this._lastRequestFocusId;
    const currentRequestFocus = this._currentRequest;
    if (currentRequestFocus) {
      currentRequestFocus.cancel();
    }
    const request = this.waitElement(observedName, timeout, ObservedElementAccesibilities.Focusable);
    this._currentRequest = request;
    this._currentRequestTimestamp = Date.now();
    request.result.finally(() => {
      if (this._currentRequest === request) {
        delete this._currentRequest;
      }
    });
    return {
      result: request.result.then((element) => this._lastRequestFocusId === requestId && element ? this._tabster.focusedElement.focus(element, true) : false),
      cancel: () => {
        request.cancel();
      }
    };
  }
  _waitConditional(observedName) {
    const waitingElementKey = "_" + observedName;
    const waitingAccessibleElementKey = "a" + observedName;
    const waitingFocusableElementKey = "f" + observedName;
    const waitingElement = this._waiting[waitingElementKey];
    const waitingAccessibleElement = this._waiting[waitingAccessibleElementKey];
    const waitingFocusableElement = this._waiting[waitingFocusableElementKey];
    const win = this._win();
    const resolve = (element, key, waiting, accessibility) => {
      var _a;
      const observed = (_a = getTabsterOnElement(this._tabster, element)) === null || _a === void 0 ? void 0 : _a.observed;
      if (!observed || !observed.names.includes(observedName)) {
        return;
      }
      if (waiting.timer) {
        win.clearTimeout(waiting.timer);
      }
      delete this._waiting[key];
      if (waiting.resolve) {
        waiting.resolve(element);
      }
      this.trigger(element, {
        names: [observedName],
        details: observed.details,
        accessibility
      });
    };
    if (waitingElement) {
      const element = this.getElement(observedName);
      if (element && documentContains(element.ownerDocument, element)) {
        resolve(element, waitingElementKey, waitingElement, ObservedElementAccesibilities.Any);
      }
    }
    if (waitingAccessibleElement && !waitingAccessibleElement.conditionTimer) {
      const resolveAccessible = () => {
        const element = this.getElement(observedName);
        if (element && documentContains(element.ownerDocument, element) && this._tabster.focusable.isAccessible(element)) {
          resolve(element, waitingAccessibleElementKey, waitingAccessibleElement, ObservedElementAccesibilities.Accessible);
        } else {
          waitingAccessibleElement.conditionTimer = win.setTimeout(resolveAccessible, _conditionCheckTimeout);
        }
      };
      resolveAccessible();
    }
    if (waitingFocusableElement && !waitingFocusableElement.conditionTimer) {
      const resolveFocusable = () => {
        const element = this.getElement(observedName);
        if (element && documentContains(element.ownerDocument, element) && this._tabster.focusable.isFocusable(element, true)) {
          resolve(element, waitingFocusableElementKey, waitingFocusableElement, ObservedElementAccesibilities.Focusable);
        } else {
          waitingFocusableElement.conditionTimer = win.setTimeout(resolveFocusable, _conditionCheckTimeout);
        }
      };
      resolveFocusable();
    }
  }
};
var UncontrolledAPI = class {
  constructor(isUncontrolledCompletely) {
    this._isUncontrolledCompletely = isUncontrolledCompletely;
  }
  isUncontrolledCompletely(element, completely) {
    var _a;
    const isUncontrolledCompletely = (_a = this._isUncontrolledCompletely) === null || _a === void 0 ? void 0 : _a.call(this, element, completely);
    return isUncontrolledCompletely === void 0 ? completely : isUncontrolledCompletely;
  }
};
var EVENT_NAME = "restorer:restorefocus";
var HISOTRY_DEPTH = 10;
var Restorer = class extends TabsterPart {
  constructor(tabster, element, props) {
    var _a;
    super(tabster, element, props);
    this._hasFocus = false;
    this._onFocusOut = (e2) => {
      var _a2;
      const element2 = (_a2 = this._element) === null || _a2 === void 0 ? void 0 : _a2.get();
      if (element2 && e2.relatedTarget === null) {
        element2.dispatchEvent(new Event(EVENT_NAME, {
          bubbles: true
        }));
      }
      if (element2 && !element2.contains(e2.relatedTarget)) {
        this._hasFocus = false;
      }
    };
    this._onFocusIn = () => {
      this._hasFocus = true;
    };
    if (this._props.type === RestorerTypes.Source) {
      const element2 = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();
      element2 === null || element2 === void 0 ? void 0 : element2.addEventListener("focusout", this._onFocusOut);
      element2 === null || element2 === void 0 ? void 0 : element2.addEventListener("focusin", this._onFocusIn);
    }
  }
  dispose() {
    var _a, _b;
    if (this._props.type === RestorerTypes.Source) {
      const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();
      element === null || element === void 0 ? void 0 : element.removeEventListener("focusout", this._onFocusOut);
      element === null || element === void 0 ? void 0 : element.removeEventListener("focusin", this._onFocusIn);
      if (this._hasFocus) {
        const doc = this._tabster.getWindow().document;
        (_b = doc.body) === null || _b === void 0 ? void 0 : _b.dispatchEvent(new Event(EVENT_NAME, {
          bubbles: true
        }));
      }
    }
  }
};
var RestorerAPI = class {
  constructor(tabster) {
    this._history = [];
    this._restoreFocusTimeout = 0;
    this._onRestoreFocus = (e2) => {
      const win = this._getWindow();
      if (this._restoreFocusTimeout) {
        win.clearTimeout(this._restoreFocusTimeout);
      }
      this._restoreFocusTimeout = win.setTimeout(() => this._restoreFocus(e2.target));
    };
    this._onFocusIn = (element) => {
      var _a;
      if (!element) {
        return;
      }
      const tabsterAttribute = getTabsterOnElement(this._tabster, element);
      if (((_a = tabsterAttribute === null || tabsterAttribute === void 0 ? void 0 : tabsterAttribute.restorer) === null || _a === void 0 ? void 0 : _a.getProps().type) !== RestorerTypes.Target) {
        return;
      }
      this._addToHistory(element);
    };
    this._restoreFocus = (source) => {
      var _a, _b, _c;
      const doc = this._getWindow().document;
      if (doc.activeElement !== doc.body) {
        return;
      }
      if (
        // clicking on any empty space focuses body - this is can be a false positive
        !this._keyboardNavState.isNavigatingWithKeyboard() && // Source no longer exists on DOM - always restore focus
        doc.body.contains(source)
      ) {
        return;
      }
      let weakElement = this._history.pop();
      while (weakElement && !doc.body.contains((_b = (_a = weakElement.get()) === null || _a === void 0 ? void 0 : _a.parentElement) !== null && _b !== void 0 ? _b : null)) {
        weakElement = this._history.pop();
      }
      (_c = weakElement === null || weakElement === void 0 ? void 0 : weakElement.get()) === null || _c === void 0 ? void 0 : _c.focus();
    };
    this._tabster = tabster;
    this._getWindow = tabster.getWindow;
    this._getWindow().addEventListener(EVENT_NAME, this._onRestoreFocus);
    this._keyboardNavState = tabster.keyboardNavigation;
    this._focusedElementState = tabster.focusedElement;
    this._focusedElementState.subscribe(this._onFocusIn);
  }
  dispose() {
    const win = this._getWindow();
    this._focusedElementState.unsubscribe(this._onFocusIn);
    win.removeEventListener(EVENT_NAME, this._onRestoreFocus);
    if (this._restoreFocusTimeout) {
      win.clearTimeout(this._restoreFocusTimeout);
    }
  }
  _addToHistory(element) {
    var _a;
    if (((_a = this._history[this._history.length - 1]) === null || _a === void 0 ? void 0 : _a.get()) === element) {
      return;
    }
    if (this._history.length > HISOTRY_DEPTH) {
      this._history.shift();
    }
    this._history.push(new WeakHTMLElement(this._getWindow, element));
  }
  createRestorer(element, props) {
    const restorer = new Restorer(this._tabster, element, props);
    if (props.type === RestorerTypes.Target && element.ownerDocument.activeElement === element) {
      this._addToHistory(element);
    }
    return restorer;
  }
};
var Tabster = class {
  constructor(tabster) {
    this.keyboardNavigation = tabster.keyboardNavigation;
    this.focusedElement = tabster.focusedElement;
    this.focusable = tabster.focusable;
    this.root = tabster.root;
    this.uncontrolled = tabster.uncontrolled;
    this.core = tabster;
  }
};
var TabsterCore = class {
  constructor(win, props) {
    var _a, _b;
    this._forgetMemorizedElements = [];
    this._wrappers = /* @__PURE__ */ new Set();
    this._initQueue = [];
    this._version = "5.1.0";
    this._noop = false;
    this.getWindow = () => {
      if (!this._win) {
        throw new Error("Using disposed Tabster.");
      }
      return this._win;
    };
    this._storage = createWeakMap(win);
    this._win = win;
    const getWindow2 = this.getWindow;
    this.keyboardNavigation = new KeyboardNavigationState(getWindow2);
    this.focusedElement = new FocusedElementState(this, getWindow2);
    this.focusable = new FocusableAPI(this);
    this.root = new RootAPI(this, props === null || props === void 0 ? void 0 : props.autoRoot);
    this.uncontrolled = new UncontrolledAPI(
      // TODO: Remove checkUncontrolledTrappingFocus in the next major version.
      (props === null || props === void 0 ? void 0 : props.checkUncontrolledCompletely) || (props === null || props === void 0 ? void 0 : props.checkUncontrolledTrappingFocus)
    );
    this.controlTab = (_a = props === null || props === void 0 ? void 0 : props.controlTab) !== null && _a !== void 0 ? _a : true;
    this.rootDummyInputs = !!(props === null || props === void 0 ? void 0 : props.rootDummyInputs);
    this._dummyObserver = new DummyInputObserver(getWindow2);
    this.getParent = (_b = props === null || props === void 0 ? void 0 : props.getParent) !== null && _b !== void 0 ? _b : (el) => el.parentElement;
    this.internal = {
      stopObserver: () => {
        if (this._unobserve) {
          this._unobserve();
          delete this._unobserve;
        }
      },
      resumeObserver: (syncState) => {
        if (!this._unobserve) {
          const doc = getWindow2().document;
          this._unobserve = observeMutations(doc, this, updateTabsterByAttribute, syncState);
        }
      }
    };
    startFakeWeakRefsCleanup(getWindow2);
    this.queueInit(() => {
      this.internal.resumeObserver(true);
    });
  }
  /**
   * Merges external props with the current props. Not all
   * props can/should be mergeable, so let's add more as we move on.
   * @param props Tabster props
   */
  _mergeProps(props) {
    var _a;
    if (!props) {
      return;
    }
    this.getParent = (_a = props.getParent) !== null && _a !== void 0 ? _a : this.getParent;
  }
  createTabster(noRefCount, props) {
    const wrapper = new Tabster(this);
    if (!noRefCount) {
      this._wrappers.add(wrapper);
    }
    this._mergeProps(props);
    return wrapper;
  }
  disposeTabster(wrapper, allInstances) {
    if (allInstances) {
      this._wrappers.clear();
    } else {
      this._wrappers.delete(wrapper);
    }
    if (this._wrappers.size === 0) {
      this.dispose();
    }
  }
  dispose() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    this.internal.stopObserver();
    const win = this._win;
    win === null || win === void 0 ? void 0 : win.clearTimeout(this._initTimer);
    delete this._initTimer;
    this._initQueue = [];
    this._forgetMemorizedElements = [];
    if (win && this._forgetMemorizedTimer) {
      win.clearTimeout(this._forgetMemorizedTimer);
      delete this._forgetMemorizedTimer;
    }
    (_a = this.outline) === null || _a === void 0 ? void 0 : _a.dispose();
    (_b = this.crossOrigin) === null || _b === void 0 ? void 0 : _b.dispose();
    (_c = this.deloser) === null || _c === void 0 ? void 0 : _c.dispose();
    (_d = this.groupper) === null || _d === void 0 ? void 0 : _d.dispose();
    (_e = this.mover) === null || _e === void 0 ? void 0 : _e.dispose();
    (_f = this.modalizer) === null || _f === void 0 ? void 0 : _f.dispose();
    (_g = this.observedElement) === null || _g === void 0 ? void 0 : _g.dispose();
    (_h = this.restorer) === null || _h === void 0 ? void 0 : _h.dispose();
    this.keyboardNavigation.dispose();
    this.focusable.dispose();
    this.focusedElement.dispose();
    this.root.dispose();
    this._dummyObserver.dispose();
    stopFakeWeakRefsCleanupAndClearStorage(this.getWindow);
    clearElementCache(this.getWindow);
    this._storage = /* @__PURE__ */ new WeakMap();
    this._wrappers.clear();
    if (win) {
      disposeInstanceContext(win);
      delete win.__tabsterInstance;
      delete this._win;
    }
  }
  storageEntry(element, addremove) {
    const storage = this._storage;
    let entry = storage.get(element);
    if (entry) {
      if (addremove === false && Object.keys(entry).length === 0) {
        storage.delete(element);
      }
    } else if (addremove === true) {
      entry = {};
      storage.set(element, entry);
    }
    return entry;
  }
  forceCleanup() {
    if (!this._win) {
      return;
    }
    this._forgetMemorizedElements.push(this._win.document.body);
    if (this._forgetMemorizedTimer) {
      return;
    }
    this._forgetMemorizedTimer = this._win.setTimeout(() => {
      delete this._forgetMemorizedTimer;
      for (let el = this._forgetMemorizedElements.shift(); el; el = this._forgetMemorizedElements.shift()) {
        clearElementCache(this.getWindow, el);
        FocusedElementState.forgetMemorized(this.focusedElement, el);
      }
    }, 0);
    cleanupFakeWeakRefs(this.getWindow, true);
  }
  queueInit(callback) {
    var _a;
    if (!this._win) {
      return;
    }
    this._initQueue.push(callback);
    if (!this._initTimer) {
      this._initTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.setTimeout(() => {
        delete this._initTimer;
        this.drainInitQueue();
      }, 0);
    }
  }
  drainInitQueue() {
    if (!this._win) {
      return;
    }
    const queue = this._initQueue;
    this._initQueue = [];
    queue.forEach((callback) => callback());
  }
};
function createTabster(win, props) {
  let tabster = getCurrentTabster(win);
  if (tabster) {
    return tabster.createTabster(false, props);
  }
  tabster = new TabsterCore(win, props);
  win.__tabsterInstance = tabster;
  return tabster.createTabster();
}
function getGroupper(tabster) {
  const tabsterCore = tabster.core;
  if (!tabsterCore.groupper) {
    tabsterCore.groupper = new GroupperAPI(tabsterCore, tabsterCore.getWindow);
  }
  return tabsterCore.groupper;
}
function getMover(tabster) {
  const tabsterCore = tabster.core;
  if (!tabsterCore.mover) {
    tabsterCore.mover = new MoverAPI(tabsterCore, tabsterCore.getWindow);
  }
  return tabsterCore.mover;
}
function getModalizer(tabster, alwaysAccessibleSelector, accessibleCheck) {
  const tabsterCore = tabster.core;
  if (!tabsterCore.modalizer) {
    tabsterCore.modalizer = new ModalizerAPI(tabsterCore, alwaysAccessibleSelector, accessibleCheck);
  }
  return tabsterCore.modalizer;
}
function getObservedElement(tabster) {
  const tabsterCore = tabster.core;
  if (!tabsterCore.observedElement) {
    tabsterCore.observedElement = new ObservedElementAPI(tabsterCore);
  }
  return tabsterCore.observedElement;
}
function getRestorer(tabster) {
  const tabsterCore = tabster.core;
  if (!tabsterCore.restorer) {
    tabsterCore.restorer = new RestorerAPI(tabsterCore);
  }
  return tabsterCore.restorer;
}
function disposeTabster(tabster, allInstances) {
  tabster.core.disposeTabster(tabster, allInstances);
}
function getCurrentTabster(win) {
  return win.__tabsterInstance;
}

// node_modules/@fluentui/react-tabster/lib/hooks/useTabster.js
var React49 = __toESM(require_react());
var useTabster = () => {
  const { targetDocument } = useFluent();
  const defaultView = (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) || void 0;
  const tabster = React49.useMemo(() => {
    if (!defaultView) {
      return null;
    }
    return createTabster(defaultView, {
      autoRoot: {},
      controlTab: false,
      getParent,
      checkUncontrolledTrappingFocus: (element) => {
        var _element_firstElementChild;
        return !!((_element_firstElementChild = element.firstElementChild) === null || _element_firstElementChild === void 0 ? void 0 : _element_firstElementChild.hasAttribute("data-is-focus-trap-zone-bumper"));
      }
    });
  }, [
    defaultView
  ]);
  useIsomorphicLayoutEffect(() => {
    return () => {
      if (tabster) {
        disposeTabster(tabster);
      }
    };
  }, [
    tabster
  ]);
  return tabster;
};

// node_modules/@fluentui/react-tabster/lib/hooks/useTabsterAttributes.js
var useTabsterAttributes = (props) => {
  useTabster();
  return getTabsterAttribute(props);
};

// node_modules/@fluentui/react-tabster/lib/hooks/useArrowNavigationGroup.js
var useArrowNavigationGroup = (options = {}) => {
  const {
    circular,
    axis,
    memorizeCurrent,
    tabbable,
    ignoreDefaultKeydown,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    unstable_hasDefault
  } = options;
  const tabster = useTabster();
  if (tabster) {
    getMover(tabster);
  }
  return useTabsterAttributes({
    mover: {
      cyclic: !!circular,
      direction: axisToMoverDirection(axis !== null && axis !== void 0 ? axis : "vertical"),
      memorizeCurrent,
      tabbable,
      hasDefault: unstable_hasDefault
    },
    ...ignoreDefaultKeydown && {
      focusable: {
        ignoreKeydown: ignoreDefaultKeydown
      }
    }
  });
};
function axisToMoverDirection(axis) {
  switch (axis) {
    case "horizontal":
      return Types.MoverDirections.Horizontal;
    case "grid":
      return Types.MoverDirections.Grid;
    case "grid-linear":
      return Types.MoverDirections.GridLinear;
    case "both":
      return Types.MoverDirections.Both;
    case "vertical":
    default:
      return Types.MoverDirections.Vertical;
  }
}

// node_modules/@fluentui/react-tabster/lib/hooks/useFocusableGroup.js
var useFocusableGroup = (options) => {
  const tabster = useTabster();
  if (tabster) {
    getGroupper(tabster);
  }
  return useTabsterAttributes({
    groupper: {
      tabbability: getTabbability(options === null || options === void 0 ? void 0 : options.tabBehavior)
    },
    focusable: {
      ignoreKeydown: options === null || options === void 0 ? void 0 : options.ignoreDefaultKeydown
    }
  });
};
var getTabbability = (tabBehavior) => {
  switch (tabBehavior) {
    case "unlimited":
      return Types.GroupperTabbabilities.Unlimited;
    case "limited":
      return Types.GroupperTabbabilities.Limited;
    case "limited-trap-focus":
      return Types.GroupperTabbabilities.LimitedTrapFocus;
    default:
      return void 0;
  }
};

// node_modules/@fluentui/react-tabster/lib/hooks/useFocusFinders.js
var React50 = __toESM(require_react());
var useFocusFinders = () => {
  const tabster = useTabster();
  const { targetDocument } = useFluent();
  const findAllFocusable = React50.useCallback((container, acceptCondition) => (tabster === null || tabster === void 0 ? void 0 : tabster.focusable.findAll({
    container,
    acceptCondition
  })) || [], [
    tabster
  ]);
  const findFirstFocusable = React50.useCallback((container) => tabster === null || tabster === void 0 ? void 0 : tabster.focusable.findFirst({
    container
  }), [
    tabster
  ]);
  const findLastFocusable = React50.useCallback((container) => tabster === null || tabster === void 0 ? void 0 : tabster.focusable.findLast({
    container
  }), [
    tabster
  ]);
  const findNextFocusable = React50.useCallback((currentElement, options = {}) => {
    if (!tabster || !targetDocument) {
      return null;
    }
    const { container = targetDocument.body } = options;
    return tabster.focusable.findNext({
      currentElement,
      container
    });
  }, [
    tabster,
    targetDocument
  ]);
  const findPrevFocusable = React50.useCallback((currentElement, options = {}) => {
    if (!tabster || !targetDocument) {
      return null;
    }
    const { container = targetDocument.body } = options;
    return tabster.focusable.findPrev({
      currentElement,
      container
    });
  }, [
    tabster,
    targetDocument
  ]);
  return {
    findAllFocusable,
    findFirstFocusable,
    findLastFocusable,
    findNextFocusable,
    findPrevFocusable
  };
};

// node_modules/@fluentui/react-tabster/lib/hooks/useFocusVisible.js
var React51 = __toESM(require_react());

// node_modules/@fluentui/react-tabster/lib/focus/constants.js
var KEYBOARD_NAV_ATTRIBUTE = "data-keyboard-nav";
var KEYBOARD_NAV_SELECTOR = `:global([${KEYBOARD_NAV_ATTRIBUTE}])`;
var FOCUS_VISIBLE_ATTR = "data-fui-focus-visible";
var FOCUS_WITHIN_ATTR = "data-fui-focus-within";
var defaultOptions = {
  style: {},
  selector: "focus",
  customizeSelector: (selector) => selector
};

// node_modules/@fluentui/react-tabster/lib/focus/focusVisiblePolyfill.js
function applyFocusVisiblePolyfill(scope, targetWindow) {
  if (alreadyInScope(scope)) {
    return () => void 0;
  }
  const state = {
    current: void 0
  };
  const keyborg = createKeyborg(targetWindow);
  function registerElementIfNavigating(el) {
    if (keyborg.isNavigatingWithKeyboard() && isHTMLElement(el)) {
      state.current = el;
      el.setAttribute(FOCUS_VISIBLE_ATTR, "");
    }
  }
  function disposeCurrentElement() {
    if (state.current) {
      state.current.removeAttribute(FOCUS_VISIBLE_ATTR);
      state.current = void 0;
    }
  }
  keyborg.subscribe((isNavigatingWithKeyboard) => {
    if (!isNavigatingWithKeyboard) {
      disposeCurrentElement();
    }
  });
  const keyborgListener = (e2) => {
    disposeCurrentElement();
    registerElementIfNavigating(e2.target);
  };
  const blurListener = (e2) => {
    if (!e2.relatedTarget || isHTMLElement(e2.relatedTarget) && !scope.contains(e2.relatedTarget)) {
      disposeCurrentElement();
    }
  };
  scope.addEventListener(KEYBORG_FOCUSIN, keyborgListener);
  scope.addEventListener("focusout", blurListener);
  scope.focusVisible = true;
  registerElementIfNavigating(targetWindow.document.activeElement);
  return () => {
    disposeCurrentElement();
    scope.removeEventListener(KEYBORG_FOCUSIN, keyborgListener);
    scope.removeEventListener("focusout", blurListener);
    delete scope.focusVisible;
    disposeKeyborg(keyborg);
  };
}
function alreadyInScope(el) {
  if (!el) {
    return false;
  }
  if (el.focusVisible) {
    return true;
  }
  return alreadyInScope(el === null || el === void 0 ? void 0 : el.parentElement);
}

// node_modules/@fluentui/react-tabster/lib/hooks/useFocusVisible.js
function useFocusVisible(options = {}) {
  const contextValue = useFluent();
  const scopeRef = React51.useRef(null);
  var _options_targetDocument;
  const targetDocument = (_options_targetDocument = options.targetDocument) !== null && _options_targetDocument !== void 0 ? _options_targetDocument : contextValue.targetDocument;
  React51.useEffect(() => {
    if ((targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) && scopeRef.current) {
      return applyFocusVisiblePolyfill(scopeRef.current, targetDocument.defaultView);
    }
  }, [
    scopeRef,
    targetDocument
  ]);
  return scopeRef;
}

// node_modules/@fluentui/react-tabster/lib/hooks/useFocusWithin.js
var React52 = __toESM(require_react());

// node_modules/@fluentui/react-tabster/lib/focus/focusWithinPolyfill.js
function applyFocusWithinPolyfill(element, win) {
  const keyborg = createKeyborg(win);
  keyborg.subscribe((isNavigatingWithKeyboard) => {
    if (!isNavigatingWithKeyboard) {
      removeFocusWithinClass(element);
    }
  });
  const keyborgListener = (e2) => {
    if (keyborg.isNavigatingWithKeyboard() && isHTMLElement2(e2.target)) {
      applyFocusWithinClass(element);
    }
  };
  const blurListener = (e2) => {
    if (!e2.relatedTarget || isHTMLElement2(e2.relatedTarget) && !element.contains(e2.relatedTarget)) {
      removeFocusWithinClass(element);
    }
  };
  element.addEventListener(KEYBORG_FOCUSIN, keyborgListener);
  element.addEventListener("focusout", blurListener);
  return () => {
    element.removeEventListener(KEYBORG_FOCUSIN, keyborgListener);
    element.removeEventListener("focusout", blurListener);
    disposeKeyborg(keyborg);
  };
}
function applyFocusWithinClass(el) {
  el.setAttribute(FOCUS_WITHIN_ATTR, "");
}
function removeFocusWithinClass(el) {
  el.removeAttribute(FOCUS_WITHIN_ATTR);
}
function isHTMLElement2(target) {
  if (!target) {
    return false;
  }
  return Boolean(target && typeof target === "object" && "classList" in target && "contains" in target);
}

// node_modules/@fluentui/react-tabster/lib/hooks/useFocusWithin.js
function useFocusWithin() {
  const { targetDocument } = useFluent();
  const elementRef = React52.useRef(null);
  React52.useEffect(() => {
    if ((targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) && elementRef.current) {
      return applyFocusWithinPolyfill(elementRef.current, targetDocument.defaultView);
    }
  }, [
    elementRef,
    targetDocument
  ]);
  return elementRef;
}

// node_modules/@fluentui/react-tabster/lib/hooks/useKeyboardNavAttribute.js
var import_react5 = __toESM(require_react());
function useKeyboardNavAttribute() {
  const { targetDocument } = useFluent();
  const keyborg = (0, import_react5.useMemo)(() => targetDocument && createKeyborg(targetDocument.defaultView), [
    targetDocument
  ]);
  const ref = (0, import_react5.useRef)(null);
  (0, import_react5.useEffect)(() => {
    if (keyborg) {
      setBooleanAttribute(ref, KEYBOARD_NAV_ATTRIBUTE, keyborg.isNavigatingWithKeyboard());
      const cb = (next) => {
        setBooleanAttribute(ref, KEYBOARD_NAV_ATTRIBUTE, next);
      };
      keyborg.subscribe(cb);
      return () => keyborg.unsubscribe(cb);
    }
  }, [
    keyborg
  ]);
  return ref;
}
function setBooleanAttribute(elementRef, attribute, value) {
  if (!elementRef.current) {
    return;
  }
  if (value) {
    elementRef.current.setAttribute(attribute, "");
  } else {
    elementRef.current.removeAttribute(attribute);
  }
}

// node_modules/@fluentui/react-tabster/lib/hooks/useModalAttributes.js
var useModalAttributes = (options = {}) => {
  const { trapFocus, alwaysFocusable, legacyTrapFocus } = options;
  const tabster = useTabster();
  if (tabster) {
    getModalizer(tabster);
    getRestorer(tabster);
  }
  const id = useId2("modal-", options.id);
  const modalAttributes = useTabsterAttributes({
    restorer: {
      type: Types.RestorerTypes.Source
    },
    ...trapFocus && {
      modalizer: {
        id,
        isOthersAccessible: !trapFocus,
        isAlwaysAccessible: alwaysFocusable,
        isTrapped: legacyTrapFocus && trapFocus
      }
    }
  });
  const triggerAttributes = useTabsterAttributes({
    restorer: {
      type: Types.RestorerTypes.Target
    }
  });
  return {
    modalAttributes,
    triggerAttributes
  };
};

// node_modules/@fluentui/react-tabster/lib/hooks/useObservedElement.js
function useObservedElement(name) {
  const tabster = useTabster();
  if (tabster) {
    getObservedElement(tabster);
  }
  return useTabsterAttributes({
    observed: {
      names: Array.isArray(name) ? name : [
        name
      ]
    }
  });
}

// node_modules/@fluentui/react-tabster/lib/hooks/useMergeTabsterAttributes.js
var React53 = __toESM(require_react());
var useMergedTabsterAttributes_unstable = (...attributes) => {
  const stringAttributes = attributes.map((attribute) => attribute[Types.TabsterAttributeName]).filter(Boolean);
  const mergedStrigAttribute = React53.useMemo(() => {
    let attribute = stringAttributes[0];
    attributes.shift();
    for (const attr of stringAttributes) {
      attribute = mergeAttributes(attribute, attr);
    }
    return attribute;
  }, stringAttributes);
  return {
    [Types.TabsterAttributeName]: mergedStrigAttribute
  };
};
function mergeAttributes(a3, b2) {
  if (!b2) {
    return a3;
  }
  let aParsed = {};
  let bParsed = {};
  if (a3) {
    try {
      aParsed = JSON.parse(a3);
    } catch {
    }
  }
  if (b2) {
    try {
      bParsed = JSON.parse(b2);
    } catch {
    }
  }
  return JSON.stringify({
    ...aParsed,
    ...bParsed
  });
}

// node_modules/@fluentui/react-tabster/lib/hooks/useFocusObserved.js
var React54 = __toESM(require_react());
function useFocusObserved(name, options = {}) {
  const { timeout = 1e3 } = options;
  const tabster = useTabster();
  const observedAPI = tabster ? getObservedElement(tabster) : null;
  return React54.useCallback(() => {
    if (observedAPI) {
      return observedAPI.requestFocus(name, timeout);
    }
    return {
      result: Promise.resolve(false),
      cancel: () => null
    };
  }, [
    observedAPI,
    name,
    timeout
  ]);
}

// node_modules/@fluentui/react-tabster/lib/hooks/useRestoreFocus.js
function useRestoreFocusTarget() {
  const tabster = useTabster();
  if (tabster) {
    getRestorer(tabster);
  }
  return getTabsterAttribute({
    restorer: {
      type: Types.RestorerTypes.Target
    }
  });
}
function useRestoreFocusSource() {
  const tabster = useTabster();
  if (tabster) {
    getRestorer(tabster);
  }
  return getTabsterAttribute({
    restorer: {
      type: Types.RestorerTypes.Source
    }
  });
}

// node_modules/@fluentui/react-tabster/lib/focus/createCustomFocusIndicatorStyle.js
function createCustomFocusIndicatorStyle(style, { selector: selectorType = defaultOptions.selector, customizeSelector = defaultOptions.customizeSelector } = defaultOptions) {
  return {
    [customizeSelector(createBaseSelector(selectorType))]: style
  };
}
function createBaseSelector(selectorType) {
  switch (selectorType) {
    case "focus":
      return `&[${FOCUS_VISIBLE_ATTR}]`;
    case "focus-within":
      return `&[${FOCUS_WITHIN_ATTR}]:focus-within`;
  }
}

// node_modules/@fluentui/react-tabster/lib/focus/createFocusOutlineStyle.js
function getOutlinePosition({ outlineWidth, outlineOffset }, position) {
  const offsetValue = (outlineOffset === null || outlineOffset === void 0 ? void 0 : outlineOffset[position]) || outlineOffset;
  if (!outlineOffset) {
    return `calc(${outlineWidth} * -1)`;
  }
  return `calc(0px - ${outlineWidth} - ${offsetValue})`;
}
var getFocusOutlineStyles = (options) => {
  const { outlineRadius, outlineColor, outlineWidth } = options;
  return {
    ...shorthands.borderColor("transparent"),
    "::after": {
      content: '""',
      position: "absolute",
      pointerEvents: "none",
      zIndex: 1,
      ...shorthands.borderStyle("solid"),
      ...shorthands.borderWidth(outlineWidth),
      ...shorthands.borderRadius(outlineRadius),
      ...shorthands.borderColor(outlineColor),
      top: getOutlinePosition(options, "top"),
      right: getOutlinePosition(options, "right"),
      bottom: getOutlinePosition(options, "bottom"),
      left: getOutlinePosition(options, "left")
    }
  };
};
var createFocusOutlineStyle = ({ enableOutline = false, selector = defaultOptions.selector, customizeSelector, style = defaultOptions.style } = defaultOptions) => ({
  ":focus": {
    outlineStyle: enableOutline ? void 0 : "none"
  },
  ":focus-visible": {
    outlineStyle: enableOutline ? void 0 : "none"
  },
  ...createCustomFocusIndicatorStyle(getFocusOutlineStyles({
    outlineColor: tokens.colorStrokeFocus2,
    outlineRadius: tokens.borderRadiusMedium,
    // FIXME: tokens.strokeWidthThick causes some weird bugs
    outlineWidth: "2px",
    ...style
  }), {
    selector,
    customizeSelector
  })
});

// node_modules/@fluentui/react-table/lib/hooks/useKeyboardResizing.js
var STEP = 20;
var PRECISION_MODIFIER = Shift2;
var PRECISION_FACTOR = 1 / 4;
function useKeyboardResizing(columnResizeState) {
  const [columnId, setColumnId] = React55.useState();
  const onChangeRef = React55.useRef();
  const { findPrevFocusable } = useFocusFinders();
  const columnResizeStateRef = React55.useRef(columnResizeState);
  React55.useEffect(() => {
    columnResizeStateRef.current = columnResizeState;
  }, [
    columnResizeState
  ]);
  const [resizeHandleRefs] = React55.useState(() => /* @__PURE__ */ new Map());
  const keyboardHandler = useEventCallback((event) => {
    if (!columnId) {
      return;
    }
    const width = columnResizeStateRef.current.getColumnWidth(columnId);
    const precisionModifier = event.getModifierState(PRECISION_MODIFIER);
    const stopEvent = () => {
      event.preventDefault();
      event.stopPropagation();
    };
    switch (event.key) {
      case ArrowLeft2:
        stopEvent();
        columnResizeStateRef.current.setColumnWidth(event.nativeEvent, {
          columnId,
          width: width - (precisionModifier ? STEP * PRECISION_FACTOR : STEP)
        });
        return;
      case ArrowRight2:
        stopEvent();
        columnResizeStateRef.current.setColumnWidth(event.nativeEvent, {
          columnId,
          width: width + (precisionModifier ? STEP * PRECISION_FACTOR : STEP)
        });
        return;
      case Space2:
      case Enter2:
      case Escape2:
        var _resizeHandleRefs_get_current, _resizeHandleRefs_get;
        stopEvent();
        (_resizeHandleRefs_get = resizeHandleRefs.get(columnId)) === null || _resizeHandleRefs_get === void 0 ? void 0 : (_resizeHandleRefs_get_current = _resizeHandleRefs_get.current) === null || _resizeHandleRefs_get_current === void 0 ? void 0 : _resizeHandleRefs_get_current.blur();
        break;
    }
  });
  const enableInteractiveMode = React55.useCallback((colId) => {
    var _onChangeRef_current, _resizeHandleRefs_get;
    setColumnId(colId);
    (_onChangeRef_current = onChangeRef.current) === null || _onChangeRef_current === void 0 ? void 0 : _onChangeRef_current.call(onChangeRef, colId, true);
    const handle = (_resizeHandleRefs_get = resizeHandleRefs.get(colId)) === null || _resizeHandleRefs_get === void 0 ? void 0 : _resizeHandleRefs_get.current;
    if (handle) {
      handle.setAttribute("tabindex", "-1");
      handle.tabIndex = -1;
      handle.focus();
    }
  }, [
    resizeHandleRefs
  ]);
  const disableInteractiveMode = React55.useCallback(() => {
    var _onChangeRef_current, _resizeHandleRefs_get;
    if (!columnId) {
      return;
    }
    (_onChangeRef_current = onChangeRef.current) === null || _onChangeRef_current === void 0 ? void 0 : _onChangeRef_current.call(onChangeRef, columnId, false);
    const el = (_resizeHandleRefs_get = resizeHandleRefs.get(columnId)) === null || _resizeHandleRefs_get === void 0 ? void 0 : _resizeHandleRefs_get.current;
    if (el) {
      var _findPrevFocusable;
      (_findPrevFocusable = findPrevFocusable(el)) === null || _findPrevFocusable === void 0 ? void 0 : _findPrevFocusable.focus();
      el.removeAttribute("tabindex");
    }
    setColumnId(void 0);
  }, [
    columnId,
    findPrevFocusable,
    resizeHandleRefs
  ]);
  const toggleInteractiveMode = (colId, onChange) => {
    onChangeRef.current = onChange;
    if (!columnId) {
      enableInteractiveMode(colId);
    } else if (colId && columnId !== colId) {
      enableInteractiveMode(colId);
      setColumnId(colId);
    } else {
      disableInteractiveMode();
    }
  };
  const getKeyboardResizingRef = React55.useCallback((colId) => {
    const ref = resizeHandleRefs.get(colId) || React55.createRef();
    resizeHandleRefs.set(colId, ref);
    return ref;
  }, [
    resizeHandleRefs
  ]);
  const tabsterAttrs = useTabsterAttributes({
    focusable: {
      ignoreKeydown: {
        ArrowLeft: true,
        ArrowRight: true
      }
    }
  });
  return {
    toggleInteractiveMode,
    columnId,
    getKeyboardResizingProps: (colId, currentWidth) => ({
      onKeyDown: keyboardHandler,
      onBlur: disableInteractiveMode,
      ref: getKeyboardResizingRef(colId),
      role: "separator",
      "aria-label": "Resize column",
      "aria-valuetext": `${currentWidth} pixels`,
      "aria-hidden": colId === columnId ? false : true,
      tabIndex: colId === columnId ? 0 : void 0,
      ...tabsterAttrs
    })
  };
}

// node_modules/@fluentui/react-table/lib/hooks/useTableColumnSizing.js
var defaultColumnSizingState = {
  getColumnWidths: () => [],
  getOnMouseDown: () => () => null,
  setColumnWidth: () => null,
  getTableProps: () => ({}),
  getTableHeaderCellProps: () => ({
    style: {},
    columnId: ""
  }),
  getTableCellProps: () => ({
    style: {},
    columnId: ""
  }),
  enableKeyboardMode: () => () => null
};
function useTableColumnSizing_unstable(params) {
  return (tableState) => useTableColumnSizingState(tableState, params);
}
function getColumnStyles(column) {
  const width = column.width;
  return {
    // native styles
    width,
    // non-native element styles (flex layout)
    minWidth: width,
    maxWidth: width
  };
}
function useTableColumnSizingState(tableState, params) {
  const { columns } = tableState;
  const { width, measureElementRef } = useMeasureElement();
  const columnResizeState = useTableColumnResizeState(columns, width + ((params === null || params === void 0 ? void 0 : params.containerWidthOffset) || 0), params);
  const mouseHandler = useTableColumnResizeMouseHandler(columnResizeState);
  const { toggleInteractiveMode, getKeyboardResizingProps } = useKeyboardResizing(columnResizeState);
  const enableKeyboardMode = React56.useCallback((columnId, onChange) => (e2) => {
    e2.preventDefault();
    e2.nativeEvent.stopPropagation();
    toggleInteractiveMode(columnId, onChange);
  }, [
    toggleInteractiveMode
  ]);
  return {
    ...tableState,
    tableRef: measureElementRef,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    columnSizing_unstable: {
      getOnMouseDown: mouseHandler.getOnMouseDown,
      setColumnWidth: (columnId, w3) => columnResizeState.setColumnWidth(void 0, {
        columnId,
        width: w3
      }),
      getColumnWidths: columnResizeState.getColumns,
      getTableProps: (props = {}) => {
        return {
          ...props,
          style: {
            minWidth: "fit-content",
            ...props.style || {}
          }
        };
      },
      getTableHeaderCellProps: (columnId) => {
        var _columns_;
        const col = columnResizeState.getColumnById(columnId);
        const isLastColumn = ((_columns_ = columns[columns.length - 1]) === null || _columns_ === void 0 ? void 0 : _columns_.columnId) === columnId;
        const aside = isLastColumn ? null : React56.createElement(TableResizeHandle, {
          onMouseDown: mouseHandler.getOnMouseDown(columnId),
          onTouchStart: mouseHandler.getOnMouseDown(columnId),
          ...getKeyboardResizingProps(columnId, (col === null || col === void 0 ? void 0 : col.width) || 0)
        });
        return col ? {
          style: getColumnStyles(col),
          aside
        } : {};
      },
      getTableCellProps: (columnId) => {
        const col = columnResizeState.getColumnById(columnId);
        return col ? {
          style: getColumnStyles(col)
        } : {};
      },
      enableKeyboardMode
    }
  };
}

// node_modules/@fluentui/react-table/lib/hooks/useTableFeatures.js
var defaultRowEnhancer = (row) => row;
var defaultTableState = {
  selection: defaultTableSelectionState,
  sort: defaultTableSortState,
  getRows: () => [],
  getRowId: () => "",
  items: [],
  columns: [],
  // eslint-disable-next-line @typescript-eslint/naming-convention
  columnSizing_unstable: defaultColumnSizingState,
  tableRef: React57.createRef()
};
function useTableFeatures(options, plugins = []) {
  const { items, getRowId, columns } = options;
  const getRows = (rowEnhancer = defaultRowEnhancer) => items.map((item, i3) => {
    var _getRowId;
    return rowEnhancer({
      item,
      rowId: (_getRowId = getRowId === null || getRowId === void 0 ? void 0 : getRowId(item)) !== null && _getRowId !== void 0 ? _getRowId : i3
    });
  });
  const initialState = {
    getRowId,
    items,
    columns,
    getRows,
    selection: defaultTableSelectionState,
    sort: defaultTableSortState,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    columnSizing_unstable: defaultColumnSizingState,
    tableRef: React57.createRef()
  };
  return plugins.reduce((state, plugin) => plugin(state), initialState);
}

// node_modules/@fluentui/react-table/lib/hooks/createColumn.js
var defaultCompare = () => 0;
var defaultRenderCell = () => {
  if (true) {
    console.warn("@fluentui/react-table: You are using the default column renderCell function that renders null");
  }
  return null;
};
var defaultRenderHeaderCell = () => {
  if (true) {
    console.warn("@fluentui/react-table: You are using the default column renderHeaderCell function that renders null");
  }
  return null;
};
function createTableColumn(options) {
  const { columnId, renderCell = defaultRenderCell, renderHeaderCell = defaultRenderHeaderCell, compare = defaultCompare } = options;
  return {
    columnId,
    renderCell,
    renderHeaderCell,
    compare
  };
}

// node_modules/@fluentui/react-table/lib/hooks/useTableCompositeNavigation.js
var React58 = __toESM(require_react());
function useTableCompositeNavigation() {
  const horizontalAttr = useArrowNavigationGroup({
    axis: "horizontal"
  });
  const gridAttr = useArrowNavigationGroup({
    axis: "grid"
  });
  const groupperAttr = useFocusableGroup({
    tabBehavior: "limited-trap-focus"
  });
  const { findFirstFocusable } = useFocusFinders();
  const { targetDocument } = useFluent();
  const rowAttr = useMergedTabsterAttributes_unstable(horizontalAttr, groupperAttr);
  const onKeyDown = React58.useCallback((e2) => {
    if (!targetDocument) {
      return;
    }
    const activeElement = targetDocument.activeElement;
    if (!activeElement || !e2.currentTarget.contains(activeElement)) {
      return;
    }
    const activeElementRole = activeElement.getAttribute("role");
    if (e2.key === ArrowRight2 && activeElementRole === "row" && isHTMLElement(activeElement)) {
      var _findFirstFocusable;
      (_findFirstFocusable = findFirstFocusable(activeElement)) === null || _findFirstFocusable === void 0 ? void 0 : _findFirstFocusable.focus();
    }
    if (activeElementRole === "row") {
      return;
    }
    const isInCell = (() => {
      let cur = isHTMLElement(activeElement) ? activeElement : null;
      while (cur) {
        const curRole = cur.getAttribute("role");
        if (curRole === "cell" || curRole === "gridcell") {
          return true;
        }
        cur = cur.parentElement;
      }
      return false;
    })();
    if ((e2.key === ArrowDown2 || e2.key === ArrowUp2) && isInCell) {
      activeElement.dispatchEvent(new KeyboardEvent("keydown", {
        key: Escape2,
        keyCode: keyCodes_exports.Escape
      }));
      activeElement.dispatchEvent(new KeyboardEvent("keydown", {
        key: e2.key,
        keyCode: e2.keyCode
      }));
    }
  }, [
    targetDocument,
    findFirstFocusable
  ]);
  return {
    onTableKeyDown: onKeyDown,
    tableTabsterAttribute: gridAttr,
    tableRowTabsterAttribute: rowAttr
  };
}

// node_modules/@fluentui/react-table/lib/components/TableCell/TableCell.js
var React61 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableCell/useTableCell.js
var React60 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/contexts/tableContext.js
var React59 = __toESM(require_react());
var tableContext = React59.createContext(void 0);
var tableContextDefaultValue = {
  size: "medium",
  noNativeElements: false,
  sortable: false
};
var TableContextProvider = tableContext.Provider;
var useTableContext = () => {
  var _React_useContext;
  return (_React_useContext = React59.useContext(tableContext)) !== null && _React_useContext !== void 0 ? _React_useContext : tableContextDefaultValue;
};

// node_modules/@fluentui/react-table/lib/components/TableCell/useTableCell.js
var useTableCell_unstable = (props, ref) => {
  const { noNativeElements, size: size2 } = useTableContext();
  var _props_as;
  const rootComponent = ((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : noNativeElements) ? "div" : "td";
  return {
    components: {
      root: rootComponent
    },
    root: slot_exports.always(getIntrinsicElementProps(rootComponent, {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      role: rootComponent === "div" ? "cell" : void 0,
      ...props
    }), {
      elementType: rootComponent
    }),
    noNativeElements,
    size: size2
  };
};

// node_modules/@fluentui/react-table/lib/components/TableCell/renderTableCell.js
var renderTableCell_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-table/lib/components/TableCell/useTableCellStyles.styles.js
var tableCellClassName = "fui-TableCell";
var tableCellClassNames = {
  root: tableCellClassName
};
var useTableLayoutStyles = __styles({
  root: {
    mc9l5x: "f15pt5es",
    ha4doy: "fmrv4ls"
  },
  medium: {
    Bqenvij: "f1ft4266"
  },
  small: {
    Bqenvij: "fbsu25e"
  },
  "extra-small": {
    Bqenvij: "frvgh55"
  }
}, {
  d: [".f15pt5es{display:table-cell;}", ".fmrv4ls{vertical-align:middle;}", ".f1ft4266{height:44px;}", ".fbsu25e{height:34px;}", ".frvgh55{height:24px;}"]
});
var useFlexLayoutStyles = __styles({
  root: {
    mc9l5x: "f22iagw",
    Bf4jedk: "f10tiqix",
    Bt984gj: "f122n59",
    Bh6795r: "fqerorx",
    Bnnss6s: "f1neuvcm",
    xawz: "fkjuxzh"
  },
  medium: {
    sshi5w: "f5pgtk9"
  },
  small: {
    sshi5w: "fcep9tg"
  },
  "extra-small": {
    sshi5w: "f1pha7fy"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f10tiqix{min-width:0px;}", ".f122n59{align-items:center;}", ".fqerorx{flex-grow:1;}", ".f1neuvcm{flex-shrink:1;}", ".fkjuxzh{flex-basis:0px;}", ".f5pgtk9{min-height:44px;}", ".fcep9tg{min-height:34px;}", ".f1pha7fy{min-height:24px;}"]
});
var useStyles2 = __styles({
  root: {
    qhf8xq: "f10pi13n",
    z8tnut: "f1nbblvp",
    z189sj: ["f1vdfbxk", "f1f5gg8d"],
    Byoj8tv: "f1ov4xf1",
    uwmqm3: ["f1f5gg8d", "f1vdfbxk"],
    Bn4voq9: "fz36nt7",
    g9k6zt: "f9znhxp",
    Bfpq7zp: "fqrak0z",
    kdpuga: ["f1o2ludy", "f1kjnpwc"],
    Bw81rd7: ["f1kjnpwc", "f1o2ludy"],
    B6xbmo0: ["fxmnebo", "f1witrsb"],
    dm238s: ["f1witrsb", "fxmnebo"]
  }
}, {
  d: [".f10pi13n{position:relative;}", ".f1nbblvp{padding-top:0px;}", ".f1vdfbxk{padding-right:var(--spacingHorizontalS);}", ".f1f5gg8d{padding-left:var(--spacingHorizontalS);}", ".f1ov4xf1{padding-bottom:0px;}", ".fz36nt7[data-fui-focus-visible]{outline-width:2px;}", ".f9znhxp[data-fui-focus-visible]{outline-style:solid;}", ".fqrak0z[data-fui-focus-visible]{outline-color:var(--colorStrokeFocus2);}", ".f1o2ludy[data-fui-focus-visible]{border-bottom-right-radius:var(--borderRadiusMedium);}", ".f1kjnpwc[data-fui-focus-visible]{border-bottom-left-radius:var(--borderRadiusMedium);}", ".fxmnebo[data-fui-focus-visible]{border-top-right-radius:var(--borderRadiusMedium);}", ".f1witrsb[data-fui-focus-visible]{border-top-left-radius:var(--borderRadiusMedium);}"]
});
var useTableCellStyles_unstable = (state) => {
  const styles = useStyles2();
  const layoutStyles = {
    table: useTableLayoutStyles(),
    flex: useFlexLayoutStyles()
  };
  state.root.className = mergeClasses(tableCellClassNames.root, styles.root, state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, state.noNativeElements ? layoutStyles.flex[state.size] : layoutStyles.table[state.size], state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/TableCell/TableCell.js
var TableCell = React61.forwardRef((props, ref) => {
  const state = useTableCell_unstable(props, ref);
  useTableCellStyles_unstable(state);
  useCustomStyleHook("useTableCellStyles_unstable")(state);
  return renderTableCell_unstable(state);
});
TableCell.displayName = "TableCell";

// node_modules/@fluentui/react-table/lib/components/TableRow/TableRow.js
var React64 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableRow/useTableRow.js
var React63 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/contexts/tableHeaderContext.js
var React62 = __toESM(require_react());
var tableHeaderContext = React62.createContext(void 0);
var tableHeaderContextDefaultValue = "";
var TableHeaderContextProvider = tableHeaderContext.Provider;
var useIsInTableHeader = () => React62.useContext(tableHeaderContext) === tableHeaderContextDefaultValue;

// node_modules/@fluentui/react-table/lib/components/TableRow/useTableRow.js
var useTableRow_unstable = (props, ref) => {
  const { noNativeElements, size: size2 } = useTableContext();
  var _props_as;
  const rootComponent = ((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : noNativeElements) ? "div" : "tr";
  const focusVisibleRef = useFocusVisible();
  const focusWithinRef = useFocusWithin();
  const isHeaderRow = useIsInTableHeader();
  var _props_appearance;
  return {
    components: {
      root: rootComponent
    },
    root: slot_exports.always(getIntrinsicElementProps(rootComponent, {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, focusVisibleRef, focusWithinRef),
      role: rootComponent === "div" ? "row" : void 0,
      ...props
    }), {
      elementType: rootComponent
    }),
    size: size2,
    noNativeElements,
    appearance: (_props_appearance = props.appearance) !== null && _props_appearance !== void 0 ? _props_appearance : "none",
    isHeaderRow
  };
};

// node_modules/@fluentui/react-table/lib/components/TableRow/renderTableRow.js
var renderTableRow_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-table/lib/components/TableCellActions/useTableCellActionsStyles.styles.js
var tableCellActionsClassNames = {
  root: "fui-TableCellActions"
};
var useStyles3 = __styles({
  root: {
    De3pzq: "f1u2r49w",
    qhf8xq: "f1euv43f",
    j35jbq: ["f10k790i", "f1xynx9j"],
    Bhzewxz: "f1i1t8d1",
    Bz10aip: "f188r07x",
    abs64n: "fk73vx1",
    Frg6f3: ["fcgxt0o", "f1ujusj6"]
  },
  visible: {
    abs64n: "f5p0z4x"
  }
}, {
  d: [".f1u2r49w{background-color:inherit;}", ".f1euv43f{position:absolute;}", ".f10k790i{right:0px;}", ".f1xynx9j{left:0px;}", ".f1i1t8d1{top:50%;}", ".f188r07x{transform:translateY(-50%);}", ".fk73vx1{opacity:0;}", ".fcgxt0o{margin-left:auto;}", ".f1ujusj6{margin-right:auto;}", ".f5p0z4x{opacity:1;}"]
});
var useTableCellActionsStyles_unstable = (state) => {
  const styles = useStyles3();
  state.root.className = mergeClasses(tableCellActionsClassNames.root, styles.root, state.visible && styles.visible, state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/TableSelectionCell/useTableSelectionCellStyles.styles.js
var CELL_WIDTH = 44;
var tableSelectionCellClassNames = {
  root: "fui-TableSelectionCell",
  checkboxIndicator: "fui-TableSelectionCell__checkboxIndicator",
  radioIndicator: "fui-TableSelectionCell__radioIndicator"
};
var useTableLayoutStyles2 = __styles({
  root: {
    mc9l5x: "f15pt5es",
    a9b677: "fksc0bp"
  }
}, {
  d: [".f15pt5es{display:table-cell;}", ".fksc0bp{width:44px;}"]
});
var useFlexLayoutStyles2 = __styles({
  root: {
    mc9l5x: "f22iagw",
    Bh6795r: "fqerorx",
    Bnnss6s: "f1neuvcm",
    xawz: "fkjuxzh",
    Bf4jedk: "fvrlu0f",
    B2u0y6b: "f1c71y05",
    Brf1p80: "f4d9j23"
  }
}, {
  d: [".f22iagw{display:flex;}", ".fqerorx{flex-grow:1;}", ".f1neuvcm{flex-shrink:1;}", ".fkjuxzh{flex-basis:0px;}", ".fvrlu0f{min-width:44px;}", ".f1c71y05{max-width:44px;}", ".f4d9j23{justify-content:center;}"]
});
var useStyles4 = __styles({
  root: {
    fsow6f: "f17mccla",
    Huce71: "fz5stix",
    z8tnut: "f1g0x7ka",
    z189sj: ["fhxju0i", "f1cnd47f"],
    Byoj8tv: "f1qch9an",
    uwmqm3: ["f1cnd47f", "fhxju0i"],
    Bn4voq9: "fz36nt7",
    g9k6zt: "f9znhxp",
    Bfpq7zp: "fqrak0z",
    kdpuga: ["f1o2ludy", "f1kjnpwc"],
    Bw81rd7: ["f1kjnpwc", "f1o2ludy"],
    B6xbmo0: ["fxmnebo", "f1witrsb"],
    dm238s: ["f1witrsb", "fxmnebo"]
  },
  radioIndicator: {
    mc9l5x: "f22iagw",
    Bh6795r: "fqerorx",
    Bt984gj: "f122n59",
    Brf1p80: "f4d9j23"
  },
  subtle: {
    abs64n: "fk73vx1",
    B8a84jv: "f1y7ij6c"
  },
  hidden: {
    Bcdw1i0: "fd7fpy0"
  }
}, {
  d: [".f17mccla{text-align:center;}", ".fz5stix{white-space:nowrap;}", ".f1g0x7ka{padding-top:0;}", ".fhxju0i{padding-right:0;}", ".f1cnd47f{padding-left:0;}", ".f1qch9an{padding-bottom:0;}", ".fz36nt7[data-fui-focus-visible]{outline-width:2px;}", ".f9znhxp[data-fui-focus-visible]{outline-style:solid;}", ".fqrak0z[data-fui-focus-visible]{outline-color:var(--colorStrokeFocus2);}", ".f1o2ludy[data-fui-focus-visible]{border-bottom-right-radius:var(--borderRadiusMedium);}", ".f1kjnpwc[data-fui-focus-visible]{border-bottom-left-radius:var(--borderRadiusMedium);}", ".fxmnebo[data-fui-focus-visible]{border-top-right-radius:var(--borderRadiusMedium);}", ".f1witrsb[data-fui-focus-visible]{border-top-left-radius:var(--borderRadiusMedium);}", ".f22iagw{display:flex;}", ".fqerorx{flex-grow:1;}", ".f122n59{align-items:center;}", ".f4d9j23{justify-content:center;}", ".fk73vx1{opacity:0;}", ".f1y7ij6c[data-fui-focus-within]:focus-within{opacity:1;}", ".fd7fpy0{visibility:hidden;}"]
});
var useTableSelectionCellStyles_unstable = (state) => {
  const styles = useStyles4();
  const layoutStyles = {
    table: useTableLayoutStyles2(),
    flex: useFlexLayoutStyles2()
  };
  state.root.className = mergeClasses(tableSelectionCellClassNames.root, styles.root, state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, state.subtle && state.checked === false && styles.subtle, state.hidden && styles.hidden, state.root.className);
  if (state.checkboxIndicator) {
    state.checkboxIndicator.className = mergeClasses(tableSelectionCellClassNames.checkboxIndicator, state.checkboxIndicator.className);
  }
  if (state.radioIndicator) {
    state.radioIndicator.className = mergeClasses(tableSelectionCellClassNames.radioIndicator, styles.radioIndicator, state.radioIndicator.className);
  }
  return state;
};

// node_modules/@fluentui/react-table/lib/components/TableRow/useTableRowStyles.styles.js
var tableRowClassName = "fui-TableRow";
var tableRowClassNames = {
  root: tableRowClassName
};
var useTableLayoutStyles3 = __styles({
  root: {
    mc9l5x: "f1u0rzck"
  }
}, {
  d: [".f1u0rzck{display:table-row;}"]
});
var useFlexLayoutStyles3 = __styles({
  root: {
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f122n59{align-items:center;}"]
});
var useStyles5 = __styles({
  root: {
    sj55zd: "f19n0e5",
    B7ck84d: "f1ewtqcl",
    Bconypa: "f1jazu75",
    B6guboy: "f1xeqee6",
    Bn4voq9: "fz36nt7",
    g9k6zt: "f9znhxp",
    Bfpq7zp: "fqrak0z",
    kdpuga: ["f1o2ludy", "f1kjnpwc"],
    Bw81rd7: ["f1kjnpwc", "f1o2ludy"],
    B6xbmo0: ["fxmnebo", "f1witrsb"],
    dm238s: ["f1witrsb", "fxmnebo"]
  },
  rootInteractive: {
    ecr2s2: "f1wfn5kd",
    lj723h: "f1g4hkjv",
    B43xm9u: "f15ngxrw",
    i921ia: "fjbbrdp",
    Jwef8y: "f1t94bn6",
    Bi91k9c: "feu1g3u",
    Bpt6rm4: "f1uorfem",
    ff6mpl: "fw60kww"
  },
  medium: {
    Bn0qgzm: "f1vxd6vx",
    oivjwe: "fg706s2",
    B9xav0g: "frpde29"
  },
  small: {
    Bn0qgzm: "f1vxd6vx",
    oivjwe: "fg706s2",
    B9xav0g: "frpde29"
  },
  "extra-small": {
    Be2twd7: "fy9rknc"
  },
  brand: {
    De3pzq: "f16xkysk",
    g2u3we: "f1bh3yvw",
    h3c5rm: ["fmi79ni", "f11fozsx"],
    B9xav0g: "fnzw4c6",
    zhjwy3: ["f11fozsx", "fmi79ni"],
    ecr2s2: "ftepret",
    gwxt9v: "fqlf3fd",
    v3aym: ["f9dpb3h", "fw2muls"],
    Bc736ss: "f1yat0gj",
    Bk6ri7n: ["fw2muls", "f9dpb3h"],
    Bk5ld8o: "f7nae3y",
    c4eypz: ["fkbere7", "fa97sf3"],
    felo30: "fmtyzcc",
    Eshu5l: ["fa97sf3", "fkbere7"],
    Bjwas2f: "fb6zhgp",
    Bn1d65q: ["fyowp6c", "fz08sq8"],
    Bxeuatn: "f9dii88",
    n51gp8: ["fz08sq8", "fyowp6c"],
    Beo2b4z: ["f1afxoft", "flqq2yx"],
    h6lo6r: ["flqq2yx", "f1afxoft"],
    Btyw6ap: ["f1b5xrmd", "f1831rx6"],
    w1pwid: ["f1831rx6", "f1b5xrmd"],
    Brwvgy3: "fd94n53",
    yadkgm: "f1e0wld5"
  },
  neutral: {
    gwxt9v: "fqlf3fd",
    v3aym: ["f9dpb3h", "fw2muls"],
    Bc736ss: "f1yat0gj",
    Bk6ri7n: ["fw2muls", "f9dpb3h"],
    Bk5ld8o: "f7nae3y",
    c4eypz: ["fkbere7", "fa97sf3"],
    felo30: "fmtyzcc",
    Eshu5l: ["fa97sf3", "fkbere7"],
    Bjwas2f: "fb6zhgp",
    Bn1d65q: ["fyowp6c", "fz08sq8"],
    Bxeuatn: "f9dii88",
    n51gp8: ["fz08sq8", "fyowp6c"],
    Beo2b4z: ["f1afxoft", "flqq2yx"],
    h6lo6r: ["flqq2yx", "f1afxoft"],
    Btyw6ap: ["f1b5xrmd", "f1831rx6"],
    w1pwid: ["f1831rx6", "f1b5xrmd"],
    Brwvgy3: "fd94n53",
    yadkgm: "f1e0wld5",
    De3pzq: "fq5gl1p",
    sj55zd: "f1cgsbmv",
    Jwef8y: "f1uqaxdt",
    ecr2s2: "fa9o754",
    g2u3we: "frmsihh",
    h3c5rm: ["frttxa5", "f11o2r7f"],
    B9xav0g: "fem5et0",
    zhjwy3: ["f11o2r7f", "frttxa5"]
  },
  none: {}
}, {
  d: [".f19n0e5{color:var(--colorNeutralForeground1);}", ".f1ewtqcl{box-sizing:border-box;}", ".f1jazu75[data-fui-focus-within]:focus-within .fui-TableSelectionCell{opacity:1;}", ".f1xeqee6[data-fui-focus-within]:focus-within .fui-TableCellActions{opacity:1;}", ".fz36nt7[data-fui-focus-visible]{outline-width:2px;}", ".f9znhxp[data-fui-focus-visible]{outline-style:solid;}", ".fqrak0z[data-fui-focus-visible]{outline-color:var(--colorStrokeFocus2);}", ".f1o2ludy[data-fui-focus-visible]{border-bottom-right-radius:var(--borderRadiusMedium);}", ".f1kjnpwc[data-fui-focus-visible]{border-bottom-left-radius:var(--borderRadiusMedium);}", ".fxmnebo[data-fui-focus-visible]{border-top-right-radius:var(--borderRadiusMedium);}", ".f1witrsb[data-fui-focus-visible]{border-top-left-radius:var(--borderRadiusMedium);}", ".f1vxd6vx{border-bottom-width:var(--strokeWidthThin);}", ".fg706s2{border-bottom-style:solid;}", ".frpde29{border-bottom-color:var(--colorNeutralStroke2);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".f16xkysk{background-color:var(--colorBrandBackground2);}", ".f1bh3yvw{border-top-color:var(--colorTransparentStrokeInteractive);}", ".fmi79ni{border-right-color:var(--colorTransparentStrokeInteractive);}", ".f11fozsx{border-left-color:var(--colorTransparentStrokeInteractive);}", ".fnzw4c6{border-bottom-color:var(--colorTransparentStrokeInteractive);}", ".fq5gl1p{background-color:var(--colorSubtleBackgroundSelected);}", ".f1cgsbmv{color:var(--colorNeutralForeground1Hover);}", ".frmsihh{border-top-color:var(--colorNeutralStrokeOnBrand);}", ".frttxa5{border-right-color:var(--colorNeutralStrokeOnBrand);}", ".f11o2r7f{border-left-color:var(--colorNeutralStrokeOnBrand);}", ".fem5et0{border-bottom-color:var(--colorNeutralStrokeOnBrand);}"],
  a: [".f1wfn5kd:active{background-color:var(--colorSubtleBackgroundPressed);}", ".f1g4hkjv:active{color:var(--colorNeutralForeground1Pressed);}", ".f15ngxrw:active .fui-TableCellActions{opacity:1;}", ".fjbbrdp:active .fui-TableSelectionCell{opacity:1;}", ".ftepret:active{background-color:var(--colorBrandBackgroundInvertedSelected);}", ".fa9o754:active{background-color:var(--colorSubtleBackgroundSelected);}"],
  h: [".f1t94bn6:hover{background-color:var(--colorSubtleBackgroundHover);}", ".feu1g3u:hover{color:var(--colorNeutralForeground1Hover);}", ".f1uorfem:hover .fui-TableCellActions{opacity:1;}", ".fw60kww:hover .fui-TableSelectionCell{opacity:1;}", ".f1uqaxdt:hover{background-color:var(--colorSubtleBackgroundSelected);}"],
  m: [["@media (forced-colors: active){.fqlf3fd{border-top-width:2px;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f9dpb3h{border-right-width:2px;}.fw2muls{border-left-width:2px;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1yat0gj{border-bottom-width:2px;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f7nae3y{border-top-style:solid;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fa97sf3{border-left-style:solid;}.fkbere7{border-right-style:solid;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fmtyzcc{border-bottom-style:solid;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fb6zhgp{border-top-color:transparent;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fyowp6c{border-right-color:transparent;}.fz08sq8{border-left-color:transparent;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f9dii88{border-bottom-color:transparent;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1afxoft{border-bottom-right-radius:var(--borderRadiusMedium);}.flqq2yx{border-bottom-left-radius:var(--borderRadiusMedium);}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1831rx6{border-top-left-radius:var(--borderRadiusMedium);}.f1b5xrmd{border-top-right-radius:var(--borderRadiusMedium);}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fd94n53{box-sizing:border-box;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1e0wld5:focus-visible{outline-offset:-4px;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useTableRowStyles_unstable = (state) => {
  const styles = useStyles5();
  const layoutStyles = {
    table: useTableLayoutStyles3(),
    flex: useFlexLayoutStyles3()
  };
  state.root.className = mergeClasses(tableRowClassNames.root, styles.root, !state.isHeaderRow && styles.rootInteractive, styles[state.size], state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, styles[state.appearance], state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/TableRow/TableRow.js
var TableRow = React64.forwardRef((props, ref) => {
  const state = useTableRow_unstable(props, ref);
  useTableRowStyles_unstable(state);
  useCustomStyleHook("useTableRowStyles_unstable")(state);
  return renderTableRow_unstable(state);
});
TableRow.displayName = "TableRow";

// node_modules/@fluentui/react-table/lib/components/TableBody/TableBody.js
var React66 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableBody/useTableBody.js
var React65 = __toESM(require_react());
var useTableBody_unstable = (props, ref) => {
  const { noNativeElements } = useTableContext();
  var _props_as;
  const rootComponent = ((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : noNativeElements) ? "div" : "tbody";
  return {
    components: {
      root: rootComponent
    },
    root: slot_exports.always(getIntrinsicElementProps(rootComponent, {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      role: rootComponent === "div" ? "rowgroup" : void 0,
      ...props
    }), {
      elementType: rootComponent
    }),
    noNativeElements
  };
};

// node_modules/@fluentui/react-table/lib/components/TableBody/renderTableBody.js
var renderTableBody_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-table/lib/components/TableBody/useTableBodyStyles.styles.js
var useTableLayoutStyles4 = __styles({
  root: {
    mc9l5x: "f1tp1avn"
  }
}, {
  d: [".f1tp1avn{display:table-row-group;}"]
});
var useFlexLayoutStyles4 = __styles({
  root: {
    mc9l5x: "ftgm304"
  }
}, {
  d: [".ftgm304{display:block;}"]
});
var tableBodyClassName = "fui-TableBody";
var tableBodyClassNames = {
  root: "fui-TableBody"
};
var useTableBodyStyles_unstable = (state) => {
  const layoutStyles = {
    table: useTableLayoutStyles4(),
    flex: useFlexLayoutStyles4()
  };
  state.root.className = mergeClasses(tableBodyClassName, state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/TableBody/TableBody.js
var TableBody = React66.forwardRef((props, ref) => {
  const state = useTableBody_unstable(props, ref);
  useTableBodyStyles_unstable(state);
  useCustomStyleHook("useTableBodyStyles_unstable")(state);
  return renderTableBody_unstable(state);
});
TableBody.displayName = "TableBody";

// node_modules/@fluentui/react-table/lib/components/Table/Table.js
var React69 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/Table/useTable.js
var React67 = __toESM(require_react());
var useTable_unstable = (props, ref) => {
  var _props_as;
  const rootComponent = ((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : props.noNativeElements) ? "div" : "table";
  var _props_size, _props_noNativeElements, _props_sortable;
  return {
    components: {
      root: rootComponent
    },
    root: slot_exports.always(getIntrinsicElementProps(rootComponent, {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      role: rootComponent === "div" ? "table" : void 0,
      ...props
    }), {
      elementType: rootComponent
    }),
    size: (_props_size = props.size) !== null && _props_size !== void 0 ? _props_size : "medium",
    noNativeElements: (_props_noNativeElements = props.noNativeElements) !== null && _props_noNativeElements !== void 0 ? _props_noNativeElements : false,
    sortable: (_props_sortable = props.sortable) !== null && _props_sortable !== void 0 ? _props_sortable : false
  };
};

// node_modules/@fluentui/react-table/lib/components/Table/renderTable.js
var renderTable_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(TableContextProvider, {
    value: contextValues.table,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-table/lib/components/Table/useTableStyles.styles.js
var tableClassName = "fui-Table";
var tableClassNames = {
  root: "fui-Table"
};
var useTableLayoutStyles5 = __styles({
  root: {
    mc9l5x: "f1w4nmp0",
    ha4doy: "fmrv4ls",
    a9b677: "fly5x3f",
    B73mfa3: "f14m3nip"
  }
}, {
  d: [".f1w4nmp0{display:table;}", ".fmrv4ls{vertical-align:middle;}", ".fly5x3f{width:100%;}", ".f14m3nip{table-layout:fixed;}"]
});
var useFlexLayoutStyles5 = __styles({
  root: {
    mc9l5x: "ftgm304"
  }
}, {
  d: [".ftgm304{display:block;}"]
});
var useStyles6 = __styles({
  root: {
    po53p8: "fgkb47j",
    De3pzq: "fhovq9v"
  }
}, {
  d: [".fgkb47j{border-collapse:collapse;}", ".fhovq9v{background-color:var(--colorSubtleBackground);}"]
});
var useTableStyles_unstable = (state) => {
  const styles = useStyles6();
  const layoutStyles = {
    table: useTableLayoutStyles5(),
    flex: useFlexLayoutStyles5()
  };
  state.root.className = mergeClasses(tableClassName, styles.root, state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/Table/useTableContextValues.js
var React68 = __toESM(require_react());
function useTableContextValues_unstable(state) {
  const { size: size2, noNativeElements, sortable } = state;
  const tableContext2 = React68.useMemo(() => ({
    noNativeElements,
    size: size2,
    sortable
  }), [
    noNativeElements,
    size2,
    sortable
  ]);
  return {
    table: tableContext2
  };
}

// node_modules/@fluentui/react-table/lib/components/Table/Table.js
var Table = React69.forwardRef((props, ref) => {
  const state = useTable_unstable(props, ref);
  useTableStyles_unstable(state);
  useCustomStyleHook("useTableStyles_unstable")(state);
  return renderTable_unstable(state, useTableContextValues_unstable(state));
});
Table.displayName = "Table";

// node_modules/@fluentui/react-table/lib/components/TableHeader/TableHeader.js
var React71 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableHeader/useTableHeader.js
var React70 = __toESM(require_react());
var useTableHeader_unstable = (props, ref) => {
  const { noNativeElements } = useTableContext();
  var _props_as;
  const rootComponent = ((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : noNativeElements) ? "div" : "thead";
  return {
    components: {
      root: rootComponent
    },
    root: slot_exports.always(getIntrinsicElementProps(rootComponent, {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      role: rootComponent === "div" ? "rowgroup" : void 0,
      ...props
    }), {
      elementType: rootComponent
    }),
    noNativeElements
  };
};

// node_modules/@fluentui/react-table/lib/components/TableHeader/renderTableHeader.js
var renderTableHeader_unstable = (state) => {
  assertSlots(state);
  return jsx(TableHeaderContextProvider, {
    value: "",
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-table/lib/components/TableHeader/useTableHeaderStyles.styles.js
var tableHeaderClassName = "fui-TableHeader";
var tableHeaderClassNames = {
  root: "fui-TableHeader"
};
var useFlexLayoutStyles6 = __styles({
  root: {
    mc9l5x: "ftgm304"
  }
}, {
  d: [".ftgm304{display:block;}"]
});
var useTableLayoutStyles6 = __styles({
  root: {
    mc9l5x: "f1tp1avn"
  }
}, {
  d: [".f1tp1avn{display:table-row-group;}"]
});
var useTableHeaderStyles_unstable = (state) => {
  const layoutStyles = {
    table: useTableLayoutStyles6(),
    flex: useFlexLayoutStyles6()
  };
  state.root.className = mergeClasses(tableHeaderClassName, state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/TableHeader/TableHeader.js
var TableHeader = React71.forwardRef((props, ref) => {
  const state = useTableHeader_unstable(props, ref);
  useTableHeaderStyles_unstable(state);
  useCustomStyleHook("useTableHeaderStyles_unstable")(state);
  return renderTableHeader_unstable(state);
});
TableHeader.displayName = "TableHeader";

// node_modules/@fluentui/react-table/lib/components/TableHeaderCell/TableHeaderCell.js
var React78 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableHeaderCell/useTableHeaderCell.js
var React77 = __toESM(require_react());

// node_modules/@fluentui/react-aria/lib/button/useARIAButtonProps.js
var React72 = __toESM(require_react());
function useARIAButtonProps(type, props) {
  const { disabled, disabledFocusable = false, ["aria-disabled"]: ariaDisabled, onClick, onKeyDown, onKeyUp, ...rest } = props !== null && props !== void 0 ? props : {};
  const normalizedARIADisabled = typeof ariaDisabled === "string" ? ariaDisabled === "true" : ariaDisabled;
  const isDisabled = disabled || disabledFocusable || normalizedARIADisabled;
  const handleClick = useEventCallback((ev) => {
    if (isDisabled) {
      ev.preventDefault();
      ev.stopPropagation();
    } else {
      onClick === null || onClick === void 0 ? void 0 : onClick(ev);
    }
  });
  const handleKeyDown = useEventCallback((ev) => {
    onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(ev);
    if (ev.isDefaultPrevented()) {
      return;
    }
    const key = ev.key;
    if (isDisabled && (key === Enter2 || key === Space2)) {
      ev.preventDefault();
      ev.stopPropagation();
      return;
    }
    if (key === Space2) {
      ev.preventDefault();
      return;
    } else if (key === Enter2) {
      ev.preventDefault();
      ev.currentTarget.click();
    }
  });
  const handleKeyUp = useEventCallback((ev) => {
    onKeyUp === null || onKeyUp === void 0 ? void 0 : onKeyUp(ev);
    if (ev.isDefaultPrevented()) {
      return;
    }
    const key = ev.key;
    if (isDisabled && (key === Enter2 || key === Space2)) {
      ev.preventDefault();
      ev.stopPropagation();
      return;
    }
    if (key === Space2) {
      ev.preventDefault();
      ev.currentTarget.click();
    }
  });
  if (type === "button" || type === void 0) {
    return {
      ...rest,
      disabled: disabled && !disabledFocusable,
      "aria-disabled": disabledFocusable ? true : normalizedARIADisabled,
      // onclick should still use internal handler to ensure prevention if disabled
      // if disabledFocusable then there's no requirement for handlers as those events should not be propagated
      onClick: disabledFocusable ? void 0 : handleClick,
      onKeyUp: disabledFocusable ? void 0 : onKeyUp,
      onKeyDown: disabledFocusable ? void 0 : onKeyDown
    };
  } else {
    const resultProps = {
      role: "button",
      tabIndex: disabled && !disabledFocusable ? void 0 : 0,
      ...rest,
      // If it's not a <button> than listeners are required even with disabledFocusable
      // Since you cannot assure the default behavior of the element
      // E.g: <a> will redirect on click
      onClick: handleClick,
      onKeyUp: handleKeyUp,
      onKeyDown: handleKeyDown,
      "aria-disabled": disabled || disabledFocusable || normalizedARIADisabled
    };
    if (type === "a" && isDisabled) {
      resultProps.href = void 0;
    }
    return resultProps;
  }
}

// node_modules/@fluentui/react-aria/lib/button/useARIAButtonShorthand.js
var useARIAButtonShorthand = (value, options) => {
  const shorthand = resolveShorthand2(value, options);
  var _shorthand_as;
  const shorthandARIAButton = useARIAButtonProps((_shorthand_as = shorthand === null || shorthand === void 0 ? void 0 : shorthand.as) !== null && _shorthand_as !== void 0 ? _shorthand_as : "button", shorthand);
  return shorthand && shorthandARIAButton;
};

// node_modules/@fluentui/react-aria/lib/button/types.js
var React73 = __toESM(require_react());

// node_modules/@fluentui/react-aria/lib/activedescendant/useActiveDescendant.js
var React75 = __toESM(require_react());

// node_modules/@fluentui/react-aria/lib/activedescendant/useOptionWalker.js
var React74 = __toESM(require_react());

// node_modules/@fluentui/react-aria/lib/activedescendant/types.js
var React76 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableHeaderCell/useTableHeaderCell.js
var sortIcons = {
  ascending: React77.createElement(ArrowUpRegular, {
    fontSize: 12
  }),
  descending: React77.createElement(ArrowDownRegular, {
    fontSize: 12
  })
};
var useTableHeaderCell_unstable = (props, ref) => {
  const { noNativeElements, sortable: contextSortable } = useTableContext();
  const { sortable = contextSortable } = props;
  var _props_as;
  const rootComponent = ((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : noNativeElements) ? "div" : "th";
  var _props_sortDirection;
  return {
    components: {
      root: rootComponent,
      button: "div",
      sortIcon: "span",
      aside: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps(rootComponent, {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, useFocusWithin()),
      role: rootComponent === "div" ? "columnheader" : void 0,
      "aria-sort": sortable ? (_props_sortDirection = props.sortDirection) !== null && _props_sortDirection !== void 0 ? _props_sortDirection : "none" : void 0,
      ...props
    }), {
      elementType: rootComponent
    }),
    aside: slot_exports.optional(props.aside, {
      elementType: "span"
    }),
    sortIcon: slot_exports.optional(props.sortIcon, {
      renderByDefault: !!props.sortDirection,
      defaultProps: {
        children: props.sortDirection ? sortIcons[props.sortDirection] : void 0
      },
      elementType: "span"
    }),
    button: slot_exports.always(useARIAButtonShorthand(props.button, {
      required: true,
      defaultProps: {
        as: "div",
        ...!sortable && {
          role: "presentation",
          tabIndex: void 0
        }
      }
    }), {
      elementType: "div"
    }),
    sortable,
    noNativeElements
  };
};

// node_modules/@fluentui/react-table/lib/components/TableHeaderCell/renderTableHeaderCell.js
var renderTableHeaderCell_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      jsxs(state.button, {
        children: [
          state.root.children,
          state.sortIcon && jsx(state.sortIcon, {})
        ]
      }),
      state.aside && jsx(state.aside, {})
    ]
  });
};

// node_modules/@fluentui/react-table/lib/components/TableHeaderCell/useTableHeaderCellStyles.styles.js
var tableHeaderCellClassName = "fui-TableHeaderCell";
var tableHeaderCellClassNames = {
  root: "fui-TableHeaderCell",
  button: "fui-TableHeaderCell__button",
  sortIcon: "fui-TableHeaderCell__sortIcon",
  aside: "fui-TableHeaderCell__aside"
};
var useTableLayoutStyles7 = __styles({
  root: {
    mc9l5x: "f15pt5es",
    ha4doy: "fmrv4ls"
  }
}, {
  d: [".f15pt5es{display:table-cell;}", ".fmrv4ls{vertical-align:middle;}"]
});
var useFlexLayoutStyles7 = __styles({
  root: {
    mc9l5x: "f22iagw",
    Bh6795r: "fqerorx",
    Bnnss6s: "f1neuvcm",
    xawz: "fkjuxzh",
    Bf4jedk: "f10tiqix"
  }
}, {
  d: [".f22iagw{display:flex;}", ".fqerorx{flex-grow:1;}", ".f1neuvcm{flex-shrink:1;}", ".fkjuxzh{flex-basis:0px;}", ".f10tiqix{min-width:0px;}"]
});
var useStyles7 = __styles({
  root: {
    Bhrd7zp: "figsok6",
    z8tnut: "f1nbblvp",
    z189sj: ["f1vdfbxk", "f1f5gg8d"],
    Byoj8tv: "f1ov4xf1",
    uwmqm3: ["f1f5gg8d", "f1vdfbxk"],
    B3nxjsc: "fhix6mv",
    Bmvh20x: "fha7anx",
    robkg1: "f1fmzww4",
    pehzd3: ["fs9qmxf", "f187m4uq"],
    B8osjzx: ["f187m4uq", "fs9qmxf"],
    u7xebq: ["f145mzao", "f1uha7eq"],
    Blsv9te: ["f1uha7eq", "f145mzao"],
    qhf8xq: "f10pi13n"
  },
  rootInteractive: {
    Jwef8y: "f1t94bn6",
    ecr2s2: "f1wfn5kd"
  },
  resetButton: {
    B3rzk8w: "fq6nmtn",
    B7ck84d: "f1e4lqlz",
    De3pzq: "f1u2r49w",
    sj55zd: "f1ym3bx4",
    Bahqtrf: "f1mo0ibp",
    Be2twd7: "fjoy568",
    Bg96gwp: "fytdu2e",
    B68tc82: "f1mtd64y",
    Bmxbyg5: "f1y7q3j9",
    z8tnut: "f1g0x7ka",
    z189sj: ["fhxju0i", "f1cnd47f"],
    Byoj8tv: "f1qch9an",
    uwmqm3: ["f1cnd47f", "fhxju0i"],
    icvyot: "f1ern45e",
    vrafjx: ["f1n71otn", "f1deefiw"],
    oivjwe: "f1h8hb77",
    wvpqe5: ["f1deefiw", "f1n71otn"],
    fsow6f: "fgusgyc"
  },
  button: {
    qhf8xq: "f10pi13n",
    a9b677: "fly5x3f",
    mc9l5x: "f22iagw",
    Bh6795r: "fqerorx",
    Bqenvij: "f1l02sjl",
    Bt984gj: "f122n59",
    i8kkvl: "f1ufnopg",
    Belr9w4: "f14sijuj",
    sshi5w: "f1nxs5xn",
    Bnnss6s: "f1neuvcm",
    xawz: "fkjuxzh",
    oeaueh: "f1s6fcnf"
  },
  sortable: {
    Bceei9c: "f1k6fduh"
  },
  sortIcon: {
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59",
    z8tnut: "fclwglc"
  },
  resizeHandle: {}
}, {
  d: [".figsok6{font-weight:var(--fontWeightRegular);}", ".f1nbblvp{padding-top:0px;}", ".f1vdfbxk{padding-right:var(--spacingHorizontalS);}", ".f1f5gg8d{padding-left:var(--spacingHorizontalS);}", ".f1ov4xf1{padding-bottom:0px;}", ".fhix6mv[data-fui-focus-within]:focus-within{outline-width:2px;}", ".fha7anx[data-fui-focus-within]:focus-within{outline-style:solid;}", ".f1fmzww4[data-fui-focus-within]:focus-within{outline-color:var(--colorStrokeFocus2);}", ".fs9qmxf[data-fui-focus-within]:focus-within{border-bottom-right-radius:var(--borderRadiusMedium);}", ".f187m4uq[data-fui-focus-within]:focus-within{border-bottom-left-radius:var(--borderRadiusMedium);}", ".f145mzao[data-fui-focus-within]:focus-within{border-top-right-radius:var(--borderRadiusMedium);}", ".f1uha7eq[data-fui-focus-within]:focus-within{border-top-left-radius:var(--borderRadiusMedium);}", ".f10pi13n{position:relative;}", ".fq6nmtn{resize:horizontal;}", ".f1e4lqlz{box-sizing:content-box;}", ".f1u2r49w{background-color:inherit;}", ".f1ym3bx4{color:inherit;}", ".f1mo0ibp{font-family:inherit;}", ".fjoy568{font-size:inherit;}", ".fytdu2e{line-height:normal;}", ".f1mtd64y{overflow-x:visible;}", ".f1y7q3j9{overflow-y:visible;}", ".f1g0x7ka{padding-top:0;}", ".fhxju0i{padding-right:0;}", ".f1cnd47f{padding-left:0;}", ".f1qch9an{padding-bottom:0;}", ".f1ern45e{border-top-style:none;}", ".f1n71otn{border-right-style:none;}", ".f1deefiw{border-left-style:none;}", ".f1h8hb77{border-bottom-style:none;}", ".fgusgyc{text-align:unset;}", ".fly5x3f{width:100%;}", ".f22iagw{display:flex;}", ".fqerorx{flex-grow:1;}", ".f1l02sjl{height:100%;}", ".f122n59{align-items:center;}", ".f1ufnopg{column-gap:var(--spacingHorizontalXS);}", ".f14sijuj{row-gap:var(--spacingHorizontalXS);}", ".f1nxs5xn{min-height:32px;}", ".f1neuvcm{flex-shrink:1;}", ".fkjuxzh{flex-basis:0px;}", ".f1s6fcnf{outline-style:none;}", ".f1k6fduh{cursor:pointer;}", ".fclwglc{padding-top:var(--spacingVerticalXXS);}"],
  h: [".f1t94bn6:hover{background-color:var(--colorSubtleBackgroundHover);}"],
  a: [".f1wfn5kd:active{background-color:var(--colorSubtleBackgroundPressed);}"]
});
var useTableHeaderCellStyles_unstable = (state) => {
  const styles = useStyles7();
  const layoutStyles = {
    table: useTableLayoutStyles7(),
    flex: useFlexLayoutStyles7()
  };
  state.root.className = mergeClasses(tableHeaderCellClassNames.root, styles.root, state.sortable && styles.rootInteractive, state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, state.root.className);
  state.button.className = mergeClasses(tableHeaderCellClassNames.button, styles.resetButton, styles.button, state.sortable && styles.sortable, state.button.className);
  if (state.sortIcon) {
    state.sortIcon.className = mergeClasses(tableHeaderCellClassNames.sortIcon, styles.sortIcon, state.sortIcon.className);
  }
  if (state.aside) {
    state.aside.className = mergeClasses(tableHeaderCellClassNames.aside, styles.resizeHandle, state.aside.className);
  }
  return state;
};

// node_modules/@fluentui/react-table/lib/components/TableHeaderCell/TableHeaderCell.js
var TableHeaderCell = React78.forwardRef((props, ref) => {
  const state = useTableHeaderCell_unstable(props, ref);
  useTableHeaderCellStyles_unstable(state);
  useCustomStyleHook("useTableHeaderCellStyles_unstable")(state);
  return renderTableHeaderCell_unstable(state);
});
TableHeaderCell.displayName = "TableHeaderCell";

// node_modules/@fluentui/react-table/lib/contexts/columnIdContext.js
var React79 = __toESM(require_react());
var columnIdContext = React79.createContext(void 0);
var columnIdContextDefaultValue = "";
var useColumnIdContext = () => {
  var _React_useContext;
  return (_React_useContext = React79.useContext(columnIdContext)) !== null && _React_useContext !== void 0 ? _React_useContext : columnIdContextDefaultValue;
};
var ColumnIdContextProvider = columnIdContext.Provider;

// node_modules/@fluentui/react-table/lib/contexts/rowIdContext.js
var React80 = __toESM(require_react());
var rowIdContext = React80.createContext(void 0);
var tableRowIdContextDefaultValue = "";
var useTableRowIdContext = () => {
  var _React_useContext;
  return (_React_useContext = React80.useContext(rowIdContext)) !== null && _React_useContext !== void 0 ? _React_useContext : tableRowIdContextDefaultValue;
};
var TableRowIdContextProvider = rowIdContext.Provider;

// node_modules/@fluentui/react-table/lib/components/TableSelectionCell/TableSelectionCell.js
var React100 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableSelectionCell/useTableSelectionCell.js
var React99 = __toESM(require_react());

// node_modules/@fluentui/react-checkbox/lib/components/Checkbox/Checkbox.js
var React89 = __toESM(require_react());

// node_modules/@fluentui/react-checkbox/lib/components/Checkbox/useCheckbox.js
var React88 = __toESM(require_react());

// node_modules/@fluentui/react-field/lib/components/Field/Field.types.js
var React81 = __toESM(require_react());

// node_modules/@fluentui/react-field/lib/components/Field/Field.js
var React87 = __toESM(require_react());

// node_modules/@fluentui/react-field/lib/contexts/FieldContext.js
var React82 = __toESM(require_react());
var FieldContext = React82.createContext(void 0);
var FieldContextProvider = FieldContext.Provider;
var useFieldContext_unstable = () => React82.useContext(FieldContext);

// node_modules/@fluentui/react-field/lib/contexts/useFieldContextValues.js
var React83 = __toESM(require_react());
var useFieldContextValues_unstable = (state) => {
  var _state_label, _state_label1, _state_validationMessage, _state_hint;
  const { generatedControlId, orientation, required, size: size2, validationState } = state;
  const labelFor = (_state_label = state.label) === null || _state_label === void 0 ? void 0 : _state_label.htmlFor;
  const labelId = (_state_label1 = state.label) === null || _state_label1 === void 0 ? void 0 : _state_label1.id;
  const validationMessageId = (_state_validationMessage = state.validationMessage) === null || _state_validationMessage === void 0 ? void 0 : _state_validationMessage.id;
  const hintId = (_state_hint = state.hint) === null || _state_hint === void 0 ? void 0 : _state_hint.id;
  const field = React83.useMemo(() => ({
    generatedControlId,
    hintId,
    labelFor,
    labelId,
    orientation,
    required,
    size: size2,
    validationMessageId,
    validationState
  }), [
    generatedControlId,
    hintId,
    labelFor,
    labelId,
    orientation,
    required,
    size2,
    validationMessageId,
    validationState
  ]);
  return {
    field
  };
};

// node_modules/@fluentui/react-field/lib/contexts/useFieldControlProps.js
function useFieldControlProps_unstable(props, options) {
  return getFieldControlProps(useFieldContext_unstable(), props, options);
}
function getFieldControlProps(context, props, options) {
  if (!context) {
    return props;
  }
  props = {
    ...props
  };
  const { generatedControlId, hintId, labelFor, labelId, required, validationMessageId, validationState } = context;
  if (generatedControlId) {
    var _props;
    var _id;
    (_id = (_props = props).id) !== null && _id !== void 0 ? _id : _props.id = generatedControlId;
  }
  if (labelId && (!(options === null || options === void 0 ? void 0 : options.supportsLabelFor) || labelFor !== props.id)) {
    var _props1, _arialabelledby;
    var _2;
    (_2 = (_props1 = props)[_arialabelledby = "aria-labelledby"]) !== null && _2 !== void 0 ? _2 : _props1[_arialabelledby] = labelId;
  }
  if (validationMessageId || hintId) {
    props["aria-describedby"] = [
      validationMessageId,
      hintId,
      props === null || props === void 0 ? void 0 : props["aria-describedby"]
    ].filter(Boolean).join(" ");
  }
  if (validationState === "error") {
    var _props2, _ariainvalid;
    var _1;
    (_1 = (_props2 = props)[_ariainvalid = "aria-invalid"]) !== null && _1 !== void 0 ? _1 : _props2[_ariainvalid] = true;
  }
  if (required) {
    if (options === null || options === void 0 ? void 0 : options.supportsRequired) {
      var _props3;
      var _required;
      (_required = (_props3 = props).required) !== null && _required !== void 0 ? _required : _props3.required = true;
    } else {
      var _props4, _ariarequired;
      var _22;
      (_22 = (_props4 = props)[_ariarequired = "aria-required"]) !== null && _22 !== void 0 ? _22 : _props4[_ariarequired] = true;
    }
  }
  if (options === null || options === void 0 ? void 0 : options.supportsSize) {
    var _props5;
    var _size;
    (_size = (_props5 = props).size) !== null && _size !== void 0 ? _size : _props5.size = context.size;
  }
  return props;
}

// node_modules/@fluentui/react-field/lib/components/Field/renderField.js
var renderField_unstable = (state, contextValues) => {
  assertSlots(state);
  let { children } = state;
  if (typeof children === "function") {
    children = children(getFieldControlProps(contextValues.field) || {});
  }
  return jsx(FieldContextProvider, {
    value: contextValues === null || contextValues === void 0 ? void 0 : contextValues.field,
    children: jsxs(state.root, {
      children: [
        state.label && jsx(state.label, {}),
        children,
        state.validationMessage && jsxs(state.validationMessage, {
          children: [
            state.validationMessageIcon && jsx(state.validationMessageIcon, {}),
            state.validationMessage.children
          ]
        }),
        state.hint && jsx(state.hint, {})
      ]
    })
  });
};

// node_modules/@fluentui/react-field/lib/components/Field/useField.js
var React86 = __toESM(require_react());

// node_modules/@fluentui/react-label/lib/components/Label/Label.js
var React85 = __toESM(require_react());

// node_modules/@fluentui/react-label/lib/components/Label/useLabel.js
var React84 = __toESM(require_react());
var useLabel_unstable = (props, ref) => {
  const { disabled = false, required = false, weight = "regular", size: size2 = "medium" } = props;
  return {
    disabled,
    required: slot_exports.optional(required === true ? "*" : required || void 0, {
      defaultProps: {
        "aria-hidden": "true"
      },
      elementType: "span"
    }),
    weight,
    size: size2,
    components: {
      root: "label",
      required: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps("label", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLLabelElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "label"
    })
  };
};

// node_modules/@fluentui/react-label/lib/components/Label/renderLabel.js
var renderLabel_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.root.children,
      state.required && jsx(state.required, {})
    ]
  });
};

// node_modules/@fluentui/react-label/lib/components/Label/useLabelStyles.styles.js
var labelClassNames = {
  root: "fui-Label",
  required: "fui-Label__required"
};
var useStyles8 = __styles({
  root: {
    Bahqtrf: "fk6fouc",
    sj55zd: "f19n0e5"
  },
  disabled: {
    sj55zd: "f1s2aq7o"
  },
  required: {
    sj55zd: "f1whyuy6",
    uwmqm3: ["fycuoez", "f8wuabp"]
  },
  requiredDisabled: {
    sj55zd: "f1s2aq7o"
  },
  small: {
    Be2twd7: "fy9rknc",
    Bg96gwp: "fwrc4pm"
  },
  medium: {
    Be2twd7: "fkhj508",
    Bg96gwp: "f1i3iumi"
  },
  large: {
    Be2twd7: "fod5ikn",
    Bg96gwp: "faaz57k",
    Bhrd7zp: "fl43uef"
  },
  semibold: {
    Bhrd7zp: "fl43uef"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f1whyuy6{color:var(--colorPaletteRedForeground3);}", ".fycuoez{padding-left:4px;}", ".f8wuabp{padding-right:4px;}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}"]
});
var useLabelStyles_unstable = (state) => {
  const styles = useStyles8();
  state.root.className = mergeClasses(labelClassNames.root, styles.root, state.disabled && styles.disabled, styles[state.size], state.weight === "semibold" && styles.semibold, state.root.className);
  if (state.required) {
    state.required.className = mergeClasses(labelClassNames.required, styles.required, state.disabled && styles.requiredDisabled, state.required.className);
  }
  return state;
};

// node_modules/@fluentui/react-label/lib/components/Label/Label.js
var Label = React85.forwardRef((props, ref) => {
  const state = useLabel_unstable(props, ref);
  useLabelStyles_unstable(state);
  useCustomStyleHook("useLabelStyles_unstable")(state);
  return renderLabel_unstable(state);
});
Label.displayName = "Label";

// node_modules/@fluentui/react-field/lib/components/Field/useField.js
var validationMessageIcons = {
  error: React86.createElement(ErrorCircle12Filled, null),
  warning: React86.createElement(Warning12Filled, null),
  success: React86.createElement(CheckmarkCircle12Filled, null),
  none: void 0
};
var useField_unstable = (props, ref) => {
  const { children, orientation = "vertical", required = false, validationState = props.validationMessage ? "error" : "none", size: size2 = "medium" } = props;
  const baseId = useId2("field-");
  const generatedControlId = baseId + "__control";
  const root = slot_exports.always(getIntrinsicElementProps(
    "div",
    {
      ...props,
      ref
    },
    /*excludedPropNames:*/
    [
      "children"
    ]
  ), {
    elementType: "div"
  });
  const label = slot_exports.optional(props.label, {
    defaultProps: {
      htmlFor: generatedControlId,
      id: baseId + "__label",
      required,
      size: size2
    },
    elementType: Label
  });
  const validationMessage = slot_exports.optional(props.validationMessage, {
    defaultProps: {
      id: baseId + "__validationMessage",
      role: validationState === "error" ? "alert" : void 0
    },
    elementType: "div"
  });
  const hint = slot_exports.optional(props.hint, {
    defaultProps: {
      id: baseId + "__hint"
    },
    elementType: "div"
  });
  const defaultIcon = validationMessageIcons[validationState];
  const validationMessageIcon = slot_exports.optional(props.validationMessageIcon, {
    renderByDefault: !!defaultIcon,
    defaultProps: {
      children: defaultIcon
    },
    elementType: "span"
  });
  return {
    children,
    generatedControlId,
    orientation,
    required,
    size: size2,
    validationState,
    components: {
      root: "div",
      label: Label,
      validationMessage: "div",
      validationMessageIcon: "span",
      hint: "div"
    },
    root,
    label,
    validationMessageIcon,
    validationMessage,
    hint
  };
};

// node_modules/@fluentui/react-field/lib/components/Field/useFieldStyles.styles.js
var fieldClassNames = {
  root: `fui-Field`,
  label: `fui-Field__label`,
  validationMessage: `fui-Field__validationMessage`,
  validationMessageIcon: `fui-Field__validationMessageIcon`,
  hint: `fui-Field__hint`
};
var useRootStyles = __styles({
  base: {
    mc9l5x: "f13qh94s"
  },
  horizontal: {
    Budl1dq: "f2wwaib",
    wkccdc: "f1645dqt"
  },
  horizontalNoLabel: {
    uwmqm3: ["f15jqgz8", "fggqkej"],
    Budl1dq: "f1c2z91y"
  }
}, {
  d: [".f13qh94s{display:grid;}", ".f2wwaib{grid-template-columns:33% 1fr;}", ".f1645dqt{grid-template-rows:auto auto auto 1fr;}", ".f15jqgz8{padding-left:33%;}", ".fggqkej{padding-right:33%;}", ".f1c2z91y{grid-template-columns:1fr;}"]
});
var useLabelStyles = __styles({
  base: {
    z8tnut: "fclwglc",
    Byoj8tv: "fywfov9"
  },
  large: {
    z8tnut: "f1sl3k7w",
    Byoj8tv: "f1brlhvm"
  },
  vertical: {
    jrapky: "fyacil5"
  },
  verticalLarge: {
    jrapky: "f8l5zjj"
  },
  horizontal: {
    t21cq0: ["fkujibs", "f199hnxi"],
    Ijaq50: "f16hsg94",
    nk6f5a: "f1nzqi2z"
  }
}, {
  d: [".fclwglc{padding-top:var(--spacingVerticalXXS);}", ".fywfov9{padding-bottom:var(--spacingVerticalXXS);}", ".f1sl3k7w{padding-top:1px;}", ".f1brlhvm{padding-bottom:1px;}", ".fyacil5{margin-bottom:var(--spacingVerticalXXS);}", ".f8l5zjj{margin-bottom:var(--spacingVerticalXS);}", ".fkujibs{margin-right:var(--spacingHorizontalM);}", ".f199hnxi{margin-left:var(--spacingHorizontalM);}", ".f16hsg94{grid-row-start:1;}", ".f1nzqi2z{grid-row-end:-1;}"]
});
var useSecondaryTextBaseClassName = __resetStyles("r5c4z9l", null, [".r5c4z9l{margin-top:var(--spacingVerticalXXS);color:var(--colorNeutralForeground3);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase200);}"]);
var useSecondaryTextStyles = __styles({
  error: {
    sj55zd: "f1hcrxcs"
  },
  withIcon: {
    uwmqm3: ["frawy03", "fg4c52"]
  }
}, {
  d: [".f1hcrxcs{color:var(--colorPaletteRedForeground1);}", ".frawy03{padding-left:calc(12px + var(--spacingHorizontalXS));}", ".fg4c52{padding-right:calc(12px + var(--spacingHorizontalXS));}"]
});
var useValidationMessageIconBaseClassName = __resetStyles("ra7h1uk", "r1rh6bd7", [".ra7h1uk{display:inline-block;font-size:12px;margin-left:calc(-12px - var(--spacingHorizontalXS));margin-right:var(--spacingHorizontalXS);line-height:0;vertical-align:-1px;}", ".r1rh6bd7{display:inline-block;font-size:12px;margin-right:calc(-12px - var(--spacingHorizontalXS));margin-left:var(--spacingHorizontalXS);line-height:0;vertical-align:-1px;}"]);
var useValidationMessageIconStyles = __styles({
  error: {
    sj55zd: "f1hcrxcs"
  },
  warning: {
    sj55zd: "f1k5f75o"
  },
  success: {
    sj55zd: "ffmvakt"
  }
}, {
  d: [".f1hcrxcs{color:var(--colorPaletteRedForeground1);}", ".f1k5f75o{color:var(--colorPaletteDarkOrangeForeground1);}", ".ffmvakt{color:var(--colorPaletteGreenForeground1);}"]
});
var useFieldStyles_unstable = (state) => {
  const {
    validationState
  } = state;
  const horizontal = state.orientation === "horizontal";
  const rootStyles = useRootStyles();
  state.root.className = mergeClasses(fieldClassNames.root, rootStyles.base, horizontal && rootStyles.horizontal, horizontal && !state.label && rootStyles.horizontalNoLabel, state.root.className);
  const labelStyles = useLabelStyles();
  if (state.label) {
    state.label.className = mergeClasses(fieldClassNames.label, labelStyles.base, horizontal && labelStyles.horizontal, !horizontal && labelStyles.vertical, state.label.size === "large" && labelStyles.large, !horizontal && state.label.size === "large" && labelStyles.verticalLarge, state.label.className);
  }
  const validationMessageIconBaseClassName = useValidationMessageIconBaseClassName();
  const validationMessageIconStyles = useValidationMessageIconStyles();
  if (state.validationMessageIcon) {
    state.validationMessageIcon.className = mergeClasses(fieldClassNames.validationMessageIcon, validationMessageIconBaseClassName, validationState !== "none" && validationMessageIconStyles[validationState], state.validationMessageIcon.className);
  }
  const secondaryTextBaseClassName = useSecondaryTextBaseClassName();
  const secondaryTextStyles = useSecondaryTextStyles();
  if (state.validationMessage) {
    state.validationMessage.className = mergeClasses(fieldClassNames.validationMessage, secondaryTextBaseClassName, validationState === "error" && secondaryTextStyles.error, !!state.validationMessageIcon && secondaryTextStyles.withIcon, state.validationMessage.className);
  }
  if (state.hint) {
    state.hint.className = mergeClasses(fieldClassNames.hint, secondaryTextBaseClassName, state.hint.className);
  }
};

// node_modules/@fluentui/react-field/lib/components/Field/Field.js
var Field = React87.forwardRef((props, ref) => {
  const state = useField_unstable(props, ref);
  useFieldStyles_unstable(state);
  const context = useFieldContextValues_unstable(state);
  return renderField_unstable(state, context);
});
Field.displayName = "Field";

// node_modules/@fluentui/react-checkbox/lib/components/Checkbox/useCheckbox.js
var useCheckbox_unstable = (props, ref) => {
  props = useFieldControlProps_unstable(props, {
    supportsLabelFor: true,
    supportsRequired: true
  });
  const { disabled = false, required, shape = "square", size: size2 = "medium", labelPosition = "after", onChange } = props;
  const [checked, setChecked] = useControllableState({
    defaultState: props.defaultChecked,
    state: props.checked,
    initialState: false
  });
  const nativeProps = getPartitionedNativeProps({
    props,
    primarySlotTagName: "input",
    excludedPropNames: [
      "checked",
      "defaultChecked",
      "size",
      "onChange"
    ]
  });
  const mixed = checked === "mixed";
  const id = useId2("checkbox-", nativeProps.primary.id);
  let checkmarkIcon;
  if (mixed) {
    if (shape === "circular") {
      checkmarkIcon = React88.createElement(CircleFilled, null);
    } else {
      checkmarkIcon = size2 === "large" ? React88.createElement(Square16Filled, null) : React88.createElement(Square12Filled, null);
    }
  } else if (checked) {
    checkmarkIcon = size2 === "large" ? React88.createElement(Checkmark16Filled, null) : React88.createElement(Checkmark12Filled, null);
  }
  const state = {
    shape,
    checked,
    disabled,
    size: size2,
    labelPosition,
    components: {
      root: "span",
      input: "input",
      indicator: "div",
      label: Label
    },
    root: slot_exports.always(props.root, {
      defaultProps: {
        ref: useFocusWithin(),
        ...nativeProps.root
      },
      elementType: "span"
    }),
    input: slot_exports.always(props.input, {
      defaultProps: {
        type: "checkbox",
        id,
        ref,
        checked: checked === true,
        ...nativeProps.primary
      },
      elementType: "input"
    }),
    label: slot_exports.optional(props.label, {
      defaultProps: {
        htmlFor: id,
        disabled,
        required,
        size: "medium"
      },
      elementType: Label
    }),
    indicator: slot_exports.optional(props.indicator, {
      renderByDefault: true,
      defaultProps: {
        "aria-hidden": true,
        children: checkmarkIcon
      },
      elementType: "div"
    })
  };
  state.input.onChange = useEventCallback((ev) => {
    const val = ev.currentTarget.indeterminate ? "mixed" : ev.currentTarget.checked;
    onChange === null || onChange === void 0 ? void 0 : onChange(ev, {
      checked: val
    });
    setChecked(val);
  });
  const inputRef = useMergedRefs(state.input.ref);
  state.input.ref = inputRef;
  useIsomorphicLayoutEffect(() => {
    if (inputRef.current) {
      inputRef.current.indeterminate = mixed;
    }
  }, [
    inputRef,
    mixed
  ]);
  return state;
};

// node_modules/@fluentui/react-checkbox/lib/components/Checkbox/renderCheckbox.js
var renderCheckbox_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      jsx(state.input, {}),
      state.labelPosition === "before" && state.label && jsx(state.label, {}),
      jsx(state.indicator, {}),
      state.labelPosition === "after" && state.label && jsx(state.label, {})
    ]
  });
};

// node_modules/@fluentui/react-checkbox/lib/components/Checkbox/useCheckboxStyles.styles.js
var checkboxClassNames = {
  root: "fui-Checkbox",
  label: "fui-Checkbox__label",
  input: "fui-Checkbox__input",
  indicator: "fui-Checkbox__indicator"
};
var useRootBaseClassName = __resetStyles("r1qaeuiq", "rm0k3vm", [".r1qaeuiq{position:relative;display:inline-flex;cursor:pointer;vertical-align:middle;color:var(--colorNeutralForeground3);}", ".r1qaeuiq:focus{outline-style:none;}", ".r1qaeuiq:focus-visible{outline-style:none;}", ".r1qaeuiq[data-fui-focus-within]:focus-within{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}", '.r1qaeuiq[data-fui-focus-within]:focus-within::after{content:"";position:absolute;pointer-events:none;z-index:1;border-top-style:solid;border-right-style:solid;border-bottom-style:solid;border-left-style:solid;border-top-width:2px;border-right-width:2px;border-bottom-width:2px;border-left-width:2px;border-bottom-right-radius:var(--borderRadiusMedium);border-bottom-left-radius:var(--borderRadiusMedium);border-top-right-radius:var(--borderRadiusMedium);border-top-left-radius:var(--borderRadiusMedium);border-top-color:var(--colorStrokeFocus2);border-right-color:var(--colorStrokeFocus2);border-bottom-color:var(--colorStrokeFocus2);border-left-color:var(--colorStrokeFocus2);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}', ".rm0k3vm{position:relative;display:inline-flex;cursor:pointer;vertical-align:middle;color:var(--colorNeutralForeground3);}", ".rm0k3vm:focus{outline-style:none;}", ".rm0k3vm:focus-visible{outline-style:none;}", ".rm0k3vm[data-fui-focus-within]:focus-within{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}", '.rm0k3vm[data-fui-focus-within]:focus-within::after{content:"";position:absolute;pointer-events:none;z-index:1;border-top-style:solid;border-left-style:solid;border-bottom-style:solid;border-right-style:solid;border-top-width:2px;border-left-width:2px;border-bottom-width:2px;border-right-width:2px;border-bottom-left-radius:var(--borderRadiusMedium);border-bottom-right-radius:var(--borderRadiusMedium);border-top-left-radius:var(--borderRadiusMedium);border-top-right-radius:var(--borderRadiusMedium);border-top-color:var(--colorStrokeFocus2);border-left-color:var(--colorStrokeFocus2);border-bottom-color:var(--colorStrokeFocus2);border-right-color:var(--colorStrokeFocus2);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}']);
var useRootStyles2 = __styles({
  unchecked: {
    Bi91k9c: "f3p8bqa",
    ns3gzv: "ffqb913",
    n5iecx: ["f42z0vd", "f1j37kh1"],
    Bq2lx2j: "f10v6cc1",
    Bv7p3up: ["f1j37kh1", "f42z0vd"],
    lj723h: "f1r2dosr",
    B6u2zzw: "f1oarbgq",
    Be5wueo: ["fo8gord", "f18ci1af"],
    Cgwcxn: "fviagcr",
    Btnvhkj: ["f18ci1af", "fo8gord"]
  },
  checked: {
    sj55zd: "f19n0e5",
    Bvs3sgl: "f5opsb9",
    opw9sb: "fpaw01r",
    C5wppx: "f1gqj827",
    B32epof: ["fub94a2", "f13mj44e"],
    Bphahg7: "f1qq5vh1",
    Jctw66: ["f13mj44e", "fub94a2"],
    Bq0zqd5: "f5x9vvn",
    ns3gzv: "fub8hyy",
    n5iecx: ["fffzknn", "f172bh4s"],
    Bq2lx2j: "f6tipb1",
    Bv7p3up: ["f172bh4s", "fffzknn"],
    Bgesukf: "f8adco2",
    B6u2zzw: "f1lepnt8",
    Be5wueo: ["f80ygm0", "frrkusm"],
    Cgwcxn: "f1gg953z",
    Btnvhkj: ["frrkusm", "f80ygm0"]
  },
  mixed: {
    sj55zd: "f19n0e5",
    C5wppx: "f12fgbth",
    B32epof: ["f171e6fm", "fttsnhr"],
    Bphahg7: "f1fyk1ks",
    Jctw66: ["fttsnhr", "f171e6fm"],
    opw9sb: "fvvg2h8",
    ns3gzv: "f1nlwys0",
    n5iecx: ["f1bhstg2", "f6tsdgz"],
    Bq2lx2j: "fqxbw9v",
    Bv7p3up: ["f6tsdgz", "f1bhstg2"],
    cc1l3s: "f1r38qqt",
    B6u2zzw: "f12q3i2l",
    Be5wueo: ["f9g1hxu", "f1o4ic5t"],
    Cgwcxn: "f1c3thm1",
    Btnvhkj: ["f1o4ic5t", "f9g1hxu"],
    km5s60: "ffd07pq"
  },
  disabled: {
    Bceei9c: "f158kwzp",
    sj55zd: "f1s2aq7o",
    C5wppx: "fgiuqeu",
    B32epof: ["f1q4sfkt", "f71co73"],
    Bphahg7: "f1u7lsiy",
    Jctw66: ["f71co73", "f1q4sfkt"],
    opw9sb: "f3vxa14",
    Bbusuzp: "f1dcs8yz",
    B7bxudy: "f1lmtjkn"
  }
}, {
  h: [".f3p8bqa:hover{color:var(--colorNeutralForeground2);}", ".ffqb913:hover>.fui-Checkbox__indicator{border-top-color:var(--colorNeutralStrokeAccessibleHover);}", ".f42z0vd:hover>.fui-Checkbox__indicator{border-right-color:var(--colorNeutralStrokeAccessibleHover);}", ".f1j37kh1:hover>.fui-Checkbox__indicator{border-left-color:var(--colorNeutralStrokeAccessibleHover);}", ".f10v6cc1:hover>.fui-Checkbox__indicator{border-bottom-color:var(--colorNeutralStrokeAccessibleHover);}", ".f5x9vvn:hover>.fui-Checkbox__indicator{background-color:var(--colorCompoundBrandBackgroundHover);}", ".fub8hyy:hover>.fui-Checkbox__indicator{border-top-color:var(--colorCompoundBrandBackgroundHover);}", ".fffzknn:hover>.fui-Checkbox__indicator{border-right-color:var(--colorCompoundBrandBackgroundHover);}", ".f172bh4s:hover>.fui-Checkbox__indicator{border-left-color:var(--colorCompoundBrandBackgroundHover);}", ".f6tipb1:hover>.fui-Checkbox__indicator{border-bottom-color:var(--colorCompoundBrandBackgroundHover);}", ".f1nlwys0:hover>.fui-Checkbox__indicator{border-top-color:var(--colorCompoundBrandStrokeHover);}", ".f1bhstg2:hover>.fui-Checkbox__indicator{border-right-color:var(--colorCompoundBrandStrokeHover);}", ".f6tsdgz:hover>.fui-Checkbox__indicator{border-left-color:var(--colorCompoundBrandStrokeHover);}", ".fqxbw9v:hover>.fui-Checkbox__indicator{border-bottom-color:var(--colorCompoundBrandStrokeHover);}", ".f1r38qqt:hover>.fui-Checkbox__indicator{color:var(--colorCompoundBrandForeground1Hover);}"],
  a: [".f1r2dosr:active{color:var(--colorNeutralForeground1);}", ".f1oarbgq:active>.fui-Checkbox__indicator{border-top-color:var(--colorNeutralStrokeAccessiblePressed);}", ".fo8gord:active>.fui-Checkbox__indicator{border-right-color:var(--colorNeutralStrokeAccessiblePressed);}", ".f18ci1af:active>.fui-Checkbox__indicator{border-left-color:var(--colorNeutralStrokeAccessiblePressed);}", ".fviagcr:active>.fui-Checkbox__indicator{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}", ".f8adco2:active>.fui-Checkbox__indicator{background-color:var(--colorCompoundBrandBackgroundPressed);}", ".f1lepnt8:active>.fui-Checkbox__indicator{border-top-color:var(--colorCompoundBrandBackgroundPressed);}", ".f80ygm0:active>.fui-Checkbox__indicator{border-right-color:var(--colorCompoundBrandBackgroundPressed);}", ".frrkusm:active>.fui-Checkbox__indicator{border-left-color:var(--colorCompoundBrandBackgroundPressed);}", ".f1gg953z:active>.fui-Checkbox__indicator{border-bottom-color:var(--colorCompoundBrandBackgroundPressed);}", ".f12q3i2l:active>.fui-Checkbox__indicator{border-top-color:var(--colorCompoundBrandStrokePressed);}", ".f9g1hxu:active>.fui-Checkbox__indicator{border-right-color:var(--colorCompoundBrandStrokePressed);}", ".f1o4ic5t:active>.fui-Checkbox__indicator{border-left-color:var(--colorCompoundBrandStrokePressed);}", ".f1c3thm1:active>.fui-Checkbox__indicator{border-bottom-color:var(--colorCompoundBrandStrokePressed);}", ".ffd07pq:active>.fui-Checkbox__indicator{color:var(--colorCompoundBrandForeground1Pressed);}"],
  d: [".f19n0e5{color:var(--colorNeutralForeground1);}", ".f5opsb9>.fui-Checkbox__indicator{background-color:var(--colorCompoundBrandBackground);}", ".fpaw01r>.fui-Checkbox__indicator{color:var(--colorNeutralForegroundInverted);}", ".f1gqj827>.fui-Checkbox__indicator{border-top-color:var(--colorCompoundBrandBackground);}", ".fub94a2>.fui-Checkbox__indicator{border-right-color:var(--colorCompoundBrandBackground);}", ".f13mj44e>.fui-Checkbox__indicator{border-left-color:var(--colorCompoundBrandBackground);}", ".f1qq5vh1>.fui-Checkbox__indicator{border-bottom-color:var(--colorCompoundBrandBackground);}", ".f12fgbth>.fui-Checkbox__indicator{border-top-color:var(--colorCompoundBrandStroke);}", ".f171e6fm>.fui-Checkbox__indicator{border-right-color:var(--colorCompoundBrandStroke);}", ".fttsnhr>.fui-Checkbox__indicator{border-left-color:var(--colorCompoundBrandStroke);}", ".f1fyk1ks>.fui-Checkbox__indicator{border-bottom-color:var(--colorCompoundBrandStroke);}", ".fvvg2h8>.fui-Checkbox__indicator{color:var(--colorCompoundBrandForeground1);}", ".f158kwzp{cursor:default;}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fgiuqeu>.fui-Checkbox__indicator{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f1q4sfkt>.fui-Checkbox__indicator{border-right-color:var(--colorNeutralStrokeDisabled);}", ".f71co73>.fui-Checkbox__indicator{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f1u7lsiy>.fui-Checkbox__indicator{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".f3vxa14>.fui-Checkbox__indicator{color:var(--colorNeutralForegroundDisabled);}"],
  m: [["@media (forced-colors: active){.f1dcs8yz{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1lmtjkn>.fui-Checkbox__indicator{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useInputBaseClassName = __resetStyles("ruo9svu", null, [".ruo9svu{box-sizing:border-box;cursor:inherit;height:100%;margin:0;opacity:0;position:absolute;top:0;width:calc(16px + 2 * var(--spacingHorizontalS));}"]);
var useInputStyles = __styles({
  before: {
    j35jbq: ["f1e31b4d", "f1vgc2s3"]
  },
  after: {
    oyh7mz: ["f1vgc2s3", "f1e31b4d"]
  },
  large: {
    a9b677: "f1mq5jt6"
  }
}, {
  d: [".f1e31b4d{right:0;}", ".f1vgc2s3{left:0;}", ".f1mq5jt6{width:calc(20px + 2 * var(--spacingHorizontalS));}"]
});
var useIndicatorBaseClassName = __resetStyles("rrh91wr", null, [".rrh91wr{align-self:flex-start;box-sizing:border-box;flex-shrink:0;display:flex;align-items:center;justify-content:center;overflow:hidden;border:var(--strokeWidthThin) solid var(--colorNeutralStrokeAccessible);border-radius:var(--borderRadiusSmall);margin:var(--spacingVerticalS) var(--spacingHorizontalS);fill:currentColor;pointer-events:none;font-size:12px;height:16px;width:16px;}"]);
var useIndicatorStyles = __styles({
  large: {
    Be2twd7: "f4ybsrx",
    Bqenvij: "fjamq6b",
    a9b677: "f64fuq3"
  },
  circular: {
    Bbmb7ep: ["f8fbkgy", "f1nfllo7"],
    Beyfa6y: ["f1nfllo7", "f8fbkgy"],
    B7oj6ja: ["f1djnp8u", "f1s8kh49"],
    Btl43ni: ["f1s8kh49", "f1djnp8u"]
  }
}, {
  d: [".f4ybsrx{font-size:16px;}", ".fjamq6b{height:20px;}", ".f64fuq3{width:20px;}", ".f8fbkgy{border-bottom-right-radius:var(--borderRadiusCircular);}", ".f1nfllo7{border-bottom-left-radius:var(--borderRadiusCircular);}", ".f1djnp8u{border-top-right-radius:var(--borderRadiusCircular);}", ".f1s8kh49{border-top-left-radius:var(--borderRadiusCircular);}"]
});
var useLabelStyles2 = __styles({
  base: {
    qb2dma: "f7nlbp4",
    sj55zd: "f1ym3bx4",
    Bceei9c: "fpo1scq",
    z8tnut: "f1kwiid1",
    z189sj: ["f1vdfbxk", "f1f5gg8d"],
    Byoj8tv: "f5b47ha",
    uwmqm3: ["f1f5gg8d", "f1vdfbxk"]
  },
  before: {
    z189sj: ["f7x41pl", "fruq291"]
  },
  after: {
    uwmqm3: ["fruq291", "f7x41pl"]
  },
  medium: {
    B6of3ja: "fjzwpt6",
    jrapky: "fh6j2fo"
  },
  large: {
    B6of3ja: "f1xlvstr",
    jrapky: "f49ad5g"
  }
}, {
  d: [".f7nlbp4{align-self:center;}", ".f1ym3bx4{color:inherit;}", ".fpo1scq{cursor:inherit;}", ".f1kwiid1{padding-top:var(--spacingVerticalS);}", ".f1vdfbxk{padding-right:var(--spacingHorizontalS);}", ".f1f5gg8d{padding-left:var(--spacingHorizontalS);}", ".f5b47ha{padding-bottom:var(--spacingVerticalS);}", ".f7x41pl{padding-right:var(--spacingHorizontalXS);}", ".fruq291{padding-left:var(--spacingHorizontalXS);}", ".fjzwpt6{margin-top:calc((16px - var(--lineHeightBase300)) / 2);}", ".fh6j2fo{margin-bottom:calc((16px - var(--lineHeightBase300)) / 2);}", ".f1xlvstr{margin-top:calc((20px - var(--lineHeightBase300)) / 2);}", ".f49ad5g{margin-bottom:calc((20px - var(--lineHeightBase300)) / 2);}"]
});
var useCheckboxStyles_unstable = (state) => {
  const {
    checked,
    disabled,
    labelPosition,
    shape,
    size: size2
  } = state;
  const rootBaseClassName = useRootBaseClassName();
  const rootStyles = useRootStyles2();
  state.root.className = mergeClasses(checkboxClassNames.root, rootBaseClassName, disabled ? rootStyles.disabled : checked === "mixed" ? rootStyles.mixed : checked ? rootStyles.checked : rootStyles.unchecked, state.root.className);
  const inputBaseClassName = useInputBaseClassName();
  const inputStyles = useInputStyles();
  state.input.className = mergeClasses(checkboxClassNames.input, inputBaseClassName, size2 === "large" && inputStyles.large, inputStyles[labelPosition], state.input.className);
  const indicatorBaseClassName = useIndicatorBaseClassName();
  const indicatorStyles = useIndicatorStyles();
  if (state.indicator) {
    state.indicator.className = mergeClasses(checkboxClassNames.indicator, indicatorBaseClassName, size2 === "large" && indicatorStyles.large, shape === "circular" && indicatorStyles.circular, state.indicator.className);
  }
  const labelStyles = useLabelStyles2();
  if (state.label) {
    state.label.className = mergeClasses(checkboxClassNames.label, labelStyles.base, labelStyles[size2], labelStyles[labelPosition], state.label.className);
  }
  return state;
};

// node_modules/@fluentui/react-checkbox/lib/components/Checkbox/Checkbox.js
var Checkbox = React89.forwardRef((props, ref) => {
  const state = useCheckbox_unstable(props, ref);
  useCheckboxStyles_unstable(state);
  useCustomStyleHook("useCheckboxStyles_unstable")(state);
  return renderCheckbox_unstable(state);
});
Checkbox.displayName = "Checkbox";

// node_modules/@fluentui/react-checkbox/lib/components/Checkbox/Checkbox.types.js
var React90 = __toESM(require_react());

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-radio/lib/components/RadioGroup/RadioGroup.js
var React94 = __toESM(require_react());

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-radio/lib/contexts/RadioGroupContext.js
var React91 = __toESM(require_react());
var RadioGroupContext = React91.createContext(void 0);
var radioGroupContextDefaultValue = {};
var RadioGroupProvider = RadioGroupContext.Provider;
var useRadioGroupContextValue_unstable = () => React91.useContext(RadioGroupContext) || radioGroupContextDefaultValue;

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-radio/lib/components/RadioGroup/renderRadioGroup.js
var renderRadioGroup_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(RadioGroupContext.Provider, {
    value: contextValues.radioGroup,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-radio/lib/components/RadioGroup/useRadioGroup.js
var React92 = __toESM(require_react());
var useRadioGroup_unstable = (props, ref) => {
  props = useFieldControlProps_unstable(props);
  const generatedName = useId2("radiogroup-");
  const { name = generatedName, value, defaultValue, disabled, layout = "vertical", onChange, required } = props;
  return {
    layout,
    name,
    value,
    defaultValue,
    disabled,
    required,
    components: {
      root: "div"
    },
    root: {
      ref,
      role: "radiogroup",
      ...slot_exports.always(getIntrinsicElementProps(
        "div",
        props,
        /*excludedPropNames:*/
        [
          "onChange",
          "name"
        ]
      ), {
        elementType: "div"
      }),
      onChange: useEventCallback((ev) => {
        if (onChange && isHTMLElement(ev.target, {
          constructorName: "HTMLInputElement"
        }) && ev.target.type === "radio") {
          onChange(ev, {
            value: ev.target.value
          });
        }
      })
    }
  };
};

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-radio/lib/components/RadioGroup/useRadioGroupStyles.styles.js
var radioGroupClassNames = {
  root: "fui-RadioGroup"
};
var useStyles9 = __styles({
  root: {
    mc9l5x: "f22iagw",
    Bt984gj: "f6jr5hl"
  },
  vertical: {
    Beiy3e4: "f1vx9l62"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f6jr5hl{align-items:flex-start;}", ".f1vx9l62{flex-direction:column;}"]
});
var useRadioGroupStyles_unstable = (state) => {
  const styles = useStyles9();
  state.root.className = mergeClasses(radioGroupClassNames.root, styles.root, state.layout === "vertical" && styles.vertical, state.root.className);
};

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-radio/lib/contexts/useRadioGroupContextValues.js
var React93 = __toESM(require_react());
var useRadioGroupContextValues = (state) => {
  const { name, value, defaultValue, disabled, layout, required } = state;
  const ariaDescribedBy = state.root["aria-describedby"];
  const radioGroup = React93.useMemo(() => ({
    name,
    value,
    defaultValue,
    disabled,
    layout,
    required,
    "aria-describedby": ariaDescribedBy
  }), [
    name,
    value,
    defaultValue,
    disabled,
    layout,
    required,
    ariaDescribedBy
  ]);
  return {
    radioGroup
  };
};

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-radio/lib/components/RadioGroup/RadioGroup.js
var RadioGroup = React94.forwardRef((props, ref) => {
  const state = useRadioGroup_unstable(props, ref);
  const contextValues = useRadioGroupContextValues(state);
  useRadioGroupStyles_unstable(state);
  useCustomStyleHook("useRadioGroupStyles_unstable")(state);
  return renderRadioGroup_unstable(state, contextValues);
});
RadioGroup.displayName = "RadioGroup";

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-radio/lib/components/RadioGroup/RadioGroup.types.js
var React95 = __toESM(require_react());

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-radio/lib/components/Radio/Radio.js
var React97 = __toESM(require_react());

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-radio/lib/components/Radio/renderRadio.js
var renderRadio_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      jsx(state.input, {}),
      jsx(state.indicator, {}),
      state.label && jsx(state.label, {})
    ]
  });
};

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-radio/lib/components/Radio/useRadio.js
var React96 = __toESM(require_react());
var useRadio_unstable = (props, ref) => {
  const group = useRadioGroupContextValue_unstable();
  const { name = group.name, checked = group.value !== void 0 ? group.value === props.value : void 0, defaultChecked = group.defaultValue !== void 0 ? group.defaultValue === props.value : void 0, labelPosition = group.layout === "horizontal-stacked" ? "below" : "after", disabled = group.disabled, required = group.required, "aria-describedby": ariaDescribedBy = group["aria-describedby"], onChange } = props;
  const nativeProps = getPartitionedNativeProps({
    props,
    primarySlotTagName: "input",
    excludedPropNames: [
      "checked",
      "defaultChecked",
      "onChange"
    ]
  });
  const root = slot_exports.always(props.root, {
    defaultProps: {
      ref: useFocusWithin(),
      ...nativeProps.root
    },
    elementType: "span"
  });
  const input = slot_exports.always(props.input, {
    defaultProps: {
      ref,
      type: "radio",
      id: useId2("radio-", nativeProps.primary.id),
      name,
      checked,
      defaultChecked,
      disabled,
      required,
      "aria-describedby": ariaDescribedBy,
      ...nativeProps.primary
    },
    elementType: "input"
  });
  input.onChange = mergeCallbacks(input.onChange, (ev) => onChange === null || onChange === void 0 ? void 0 : onChange(ev, {
    value: ev.currentTarget.value
  }));
  const label = slot_exports.optional(props.label, {
    defaultProps: {
      htmlFor: input.id,
      disabled: input.disabled
    },
    elementType: Label
  });
  const indicator = slot_exports.always(props.indicator, {
    defaultProps: {
      "aria-hidden": true,
      children: React96.createElement(CircleFilled, null)
    },
    elementType: "div"
  });
  return {
    labelPosition,
    components: {
      root: "span",
      input: "input",
      label: Label,
      indicator: "div"
    },
    root,
    input,
    label,
    indicator
  };
};

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-radio/lib/components/Radio/useRadioStyles.styles.js
var radioClassNames = {
  root: "fui-Radio",
  indicator: "fui-Radio__indicator",
  input: "fui-Radio__input",
  label: "fui-Radio__label"
};
var useRootBaseClassName2 = __resetStyles("r12l4eqc", "r18esy0c", [".r12l4eqc{display:inline-flex;position:relative;}", ".r12l4eqc:focus{outline-style:none;}", ".r12l4eqc:focus-visible{outline-style:none;}", ".r12l4eqc[data-fui-focus-within]:focus-within{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}", '.r12l4eqc[data-fui-focus-within]:focus-within::after{content:"";position:absolute;pointer-events:none;z-index:1;border-top-style:solid;border-right-style:solid;border-bottom-style:solid;border-left-style:solid;border-top-width:2px;border-right-width:2px;border-bottom-width:2px;border-left-width:2px;border-bottom-right-radius:var(--borderRadiusMedium);border-bottom-left-radius:var(--borderRadiusMedium);border-top-right-radius:var(--borderRadiusMedium);border-top-left-radius:var(--borderRadiusMedium);border-top-color:var(--colorStrokeFocus2);border-right-color:var(--colorStrokeFocus2);border-bottom-color:var(--colorStrokeFocus2);border-left-color:var(--colorStrokeFocus2);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}', ".r18esy0c{display:inline-flex;position:relative;}", ".r18esy0c:focus{outline-style:none;}", ".r18esy0c:focus-visible{outline-style:none;}", ".r18esy0c[data-fui-focus-within]:focus-within{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}", '.r18esy0c[data-fui-focus-within]:focus-within::after{content:"";position:absolute;pointer-events:none;z-index:1;border-top-style:solid;border-left-style:solid;border-bottom-style:solid;border-right-style:solid;border-top-width:2px;border-left-width:2px;border-bottom-width:2px;border-right-width:2px;border-bottom-left-radius:var(--borderRadiusMedium);border-bottom-right-radius:var(--borderRadiusMedium);border-top-left-radius:var(--borderRadiusMedium);border-top-right-radius:var(--borderRadiusMedium);border-top-color:var(--colorStrokeFocus2);border-left-color:var(--colorStrokeFocus2);border-bottom-color:var(--colorStrokeFocus2);border-right-color:var(--colorStrokeFocus2);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}']);
var useRootStyles3 = __styles({
  vertical: {
    Beiy3e4: "f1vx9l62",
    Bt984gj: "f122n59"
  }
}, {
  d: [".f1vx9l62{flex-direction:column;}", ".f122n59{align-items:center;}"]
});
var useInputBaseClassName2 = __resetStyles("r9gx1vl", "r1uk1i2c", [".r9gx1vl{position:absolute;left:0;top:0;width:calc(16px + 2 * var(--spacingHorizontalS));height:100%;box-sizing:border-box;margin:0;opacity:0;}", ".r9gx1vl:enabled{cursor:pointer;}", ".r9gx1vl:enabled~.fui-Radio__label{cursor:pointer;}", ".r9gx1vl:not(:checked)~.fui-Radio__indicator>*{opacity:0;}", ".r9gx1vl:enabled:not(:checked)~.fui-Radio__label{color:var(--colorNeutralForeground3);}", ".r9gx1vl:enabled:not(:checked)~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeAccessible);}", ".r9gx1vl:enabled:not(:checked):hover~.fui-Radio__label{color:var(--colorNeutralForeground2);}", ".r9gx1vl:enabled:not(:checked):hover~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeAccessibleHover);}", ".r9gx1vl:enabled:not(:checked):hover:active~.fui-Radio__label{color:var(--colorNeutralForeground1);}", ".r9gx1vl:enabled:not(:checked):hover:active~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeAccessiblePressed);}", ".r9gx1vl:enabled:checked~.fui-Radio__label{color:var(--colorNeutralForeground1);}", ".r9gx1vl:enabled:checked~.fui-Radio__indicator{border-color:var(--colorCompoundBrandStroke);color:var(--colorCompoundBrandForeground1);}", ".r9gx1vl:enabled:checked:hover~.fui-Radio__indicator{border-color:var(--colorCompoundBrandStrokeHover);color:var(--colorCompoundBrandForeground1Hover);}", ".r9gx1vl:enabled:checked:hover:active~.fui-Radio__indicator{border-color:var(--colorCompoundBrandStrokePressed);color:var(--colorCompoundBrandForeground1Pressed);}", ".r9gx1vl:disabled~.fui-Radio__label{color:var(--colorNeutralForegroundDisabled);cursor:default;}", ".r9gx1vl:disabled~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeDisabled);color:var(--colorNeutralForegroundDisabled);}", ".r1uk1i2c{position:absolute;right:0;top:0;width:calc(16px + 2 * var(--spacingHorizontalS));height:100%;box-sizing:border-box;margin:0;opacity:0;}", ".r1uk1i2c:enabled{cursor:pointer;}", ".r1uk1i2c:enabled~.fui-Radio__label{cursor:pointer;}", ".r1uk1i2c:not(:checked)~.fui-Radio__indicator>*{opacity:0;}", ".r1uk1i2c:enabled:not(:checked)~.fui-Radio__label{color:var(--colorNeutralForeground3);}", ".r1uk1i2c:enabled:not(:checked)~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeAccessible);}", ".r1uk1i2c:enabled:not(:checked):hover~.fui-Radio__label{color:var(--colorNeutralForeground2);}", ".r1uk1i2c:enabled:not(:checked):hover~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeAccessibleHover);}", ".r1uk1i2c:enabled:not(:checked):hover:active~.fui-Radio__label{color:var(--colorNeutralForeground1);}", ".r1uk1i2c:enabled:not(:checked):hover:active~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeAccessiblePressed);}", ".r1uk1i2c:enabled:checked~.fui-Radio__label{color:var(--colorNeutralForeground1);}", ".r1uk1i2c:enabled:checked~.fui-Radio__indicator{border-color:var(--colorCompoundBrandStroke);color:var(--colorCompoundBrandForeground1);}", ".r1uk1i2c:enabled:checked:hover~.fui-Radio__indicator{border-color:var(--colorCompoundBrandStrokeHover);color:var(--colorCompoundBrandForeground1Hover);}", ".r1uk1i2c:enabled:checked:hover:active~.fui-Radio__indicator{border-color:var(--colorCompoundBrandStrokePressed);color:var(--colorCompoundBrandForeground1Pressed);}", ".r1uk1i2c:disabled~.fui-Radio__label{color:var(--colorNeutralForegroundDisabled);cursor:default;}", ".r1uk1i2c:disabled~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeDisabled);color:var(--colorNeutralForegroundDisabled);}"]);
var useInputStyles2 = __styles({
  below: {
    a9b677: "fly5x3f",
    Bqenvij: "f1je6zif"
  }
}, {
  d: [".fly5x3f{width:100%;}", ".f1je6zif{height:calc(16px + 2 * var(--spacingVerticalS));}"]
});
var useIndicatorBaseClassName2 = __resetStyles("rid4516", null, [".rid4516{width:16px;height:16px;font-size:12px;box-sizing:border-box;flex-shrink:0;display:flex;align-items:center;justify-content:center;overflow:hidden;border:var(--strokeWidthThin) solid;border-radius:var(--borderRadiusCircular);margin:var(--spacingVerticalS) var(--spacingHorizontalS);fill:currentColor;pointer-events:none;}"]);
var useLabelStyles3 = __styles({
  base: {
    qb2dma: "f7nlbp4",
    z8tnut: "f1kwiid1",
    z189sj: ["f1vdfbxk", "f1f5gg8d"],
    Byoj8tv: "f5b47ha",
    uwmqm3: ["f1f5gg8d", "f1vdfbxk"]
  },
  after: {
    uwmqm3: ["fruq291", "f7x41pl"],
    B6of3ja: "fjzwpt6",
    jrapky: "fh6j2fo"
  },
  below: {
    z8tnut: "f1ywm7hm",
    fsow6f: "f17mccla"
  }
}, {
  d: [".f7nlbp4{align-self:center;}", ".f1kwiid1{padding-top:var(--spacingVerticalS);}", ".f1vdfbxk{padding-right:var(--spacingHorizontalS);}", ".f1f5gg8d{padding-left:var(--spacingHorizontalS);}", ".f5b47ha{padding-bottom:var(--spacingVerticalS);}", ".fruq291{padding-left:var(--spacingHorizontalXS);}", ".f7x41pl{padding-right:var(--spacingHorizontalXS);}", ".fjzwpt6{margin-top:calc((16px - var(--lineHeightBase300)) / 2);}", ".fh6j2fo{margin-bottom:calc((16px - var(--lineHeightBase300)) / 2);}", ".f1ywm7hm{padding-top:var(--spacingVerticalXS);}", ".f17mccla{text-align:center;}"]
});
var useRadioStyles_unstable = (state) => {
  const {
    labelPosition
  } = state;
  const rootBaseClassName = useRootBaseClassName2();
  const rootStyles = useRootStyles3();
  state.root.className = mergeClasses(radioClassNames.root, rootBaseClassName, labelPosition === "below" && rootStyles.vertical, state.root.className);
  const inputBaseClassName = useInputBaseClassName2();
  const inputStyles = useInputStyles2();
  state.input.className = mergeClasses(radioClassNames.input, inputBaseClassName, labelPosition === "below" && inputStyles.below, state.input.className);
  const indicatorBaseClassName = useIndicatorBaseClassName2();
  state.indicator.className = mergeClasses(radioClassNames.indicator, indicatorBaseClassName, state.indicator.className);
  const labelStyles = useLabelStyles3();
  if (state.label) {
    state.label.className = mergeClasses(radioClassNames.label, labelStyles.base, labelStyles[labelPosition], state.label.className);
  }
};

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-radio/lib/components/Radio/Radio.js
var Radio = React97.forwardRef((props, ref) => {
  const state = useRadio_unstable(props, ref);
  useRadioStyles_unstable(state);
  useCustomStyleHook("useRadioStyles_unstable")(state);
  return renderRadio_unstable(state);
});
Radio.displayName = "Radio";

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-radio/lib/components/Radio/Radio.types.js
var React98 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableSelectionCell/useTableSelectionCell.js
var useTableSelectionCell_unstable = (props, ref) => {
  const tableCellState = useTableCell_unstable(props, ref);
  const { noNativeElements } = useTableContext();
  const { type = "checkbox", checked = false, subtle = false, hidden = false } = props;
  return {
    ...tableCellState,
    components: {
      ...tableCellState.components,
      checkboxIndicator: Checkbox,
      radioIndicator: Radio
    },
    checkboxIndicator: slot_exports.optional(props.checkboxIndicator, {
      renderByDefault: type === "checkbox",
      defaultProps: {
        checked: props.checked
      },
      elementType: Checkbox
    }),
    radioIndicator: slot_exports.optional(props.radioIndicator, {
      renderByDefault: type === "radio",
      defaultProps: {
        checked: !!checked,
        input: {
          name: useId2("table-selection-radio")
        }
      },
      elementType: Radio
    }),
    type,
    checked,
    noNativeElements,
    subtle,
    hidden
  };
};

// node_modules/@fluentui/react-table/lib/components/TableSelectionCell/renderTableSelectionCell.js
var renderTableSelectionCell_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.type === "checkbox" && state.checkboxIndicator && jsx(state.checkboxIndicator, {}),
      state.type === "radio" && state.radioIndicator && jsx(state.radioIndicator, {})
    ]
  });
};

// node_modules/@fluentui/react-table/lib/components/TableSelectionCell/TableSelectionCell.js
var TableSelectionCell = React100.forwardRef((props, ref) => {
  const state = useTableSelectionCell_unstable(props, ref);
  useTableSelectionCellStyles_unstable(state);
  useCustomStyleHook("useTableSelectionCellStyles_unstable")(state);
  return renderTableSelectionCell_unstable(state);
});
TableSelectionCell.displayName = "TableSelectionCell";

// node_modules/@fluentui/react-table/lib/components/TableCellActions/TableCellActions.js
var React102 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableCellActions/useTableCellActions.js
var React101 = __toESM(require_react());
var useTableCellActions_unstable = (props, ref) => {
  var _props_visible;
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    visible: (_props_visible = props.visible) !== null && _props_visible !== void 0 ? _props_visible : false
  };
};

// node_modules/@fluentui/react-table/lib/components/TableCellActions/renderTableCellActions.js
var renderTableCellActions_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-table/lib/components/TableCellActions/TableCellActions.js
var TableCellActions = React102.forwardRef((props, ref) => {
  const state = useTableCellActions_unstable(props, ref);
  useTableCellActionsStyles_unstable(state);
  useCustomStyleHook("useTableCellActionsStyles_unstable")(state);
  return renderTableCellActions_unstable(state);
});
TableCellActions.displayName = "TableCellActions";

// node_modules/@fluentui/react-table/lib/components/TableCellLayout/TableCellLayout.js
var React147 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableCellLayout/useTableCellLayout.js
var React103 = __toESM(require_react());
var tableAvatarSizeMap = {
  medium: 32,
  small: 24,
  "extra-small": 20
};
var useTableCellLayout_unstable = (props, ref) => {
  const { size: size2 } = useTableContext();
  return {
    components: {
      root: "div",
      main: "span",
      description: "span",
      content: "div",
      media: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    appearance: props.appearance,
    truncate: props.truncate,
    main: slot_exports.optional(props.main, {
      renderByDefault: true,
      elementType: "span"
    }),
    media: slot_exports.optional(props.media, {
      elementType: "span"
    }),
    description: slot_exports.optional(props.description, {
      elementType: "span"
    }),
    content: slot_exports.optional(props.content, {
      renderByDefault: !!props.description || !!props.children,
      elementType: "div"
    }),
    avatarSize: tableAvatarSizeMap[size2],
    size: size2
  };
};

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-avatar/lib/components/Avatar/Avatar.js
var React113 = __toESM(require_react());

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-avatar/lib/components/Avatar/renderAvatar.js
var renderAvatar_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.initials && jsx(state.initials, {}),
      state.icon && jsx(state.icon, {}),
      state.image && jsx(state.image, {}),
      state.badge && jsx(state.badge, {}),
      state.activeAriaLabelElement
    ]
  });
};

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-avatar/lib/components/Avatar/useAvatar.js
var React112 = __toESM(require_react());

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-avatar/lib/utils/getInitials.js
var UNWANTED_ENCLOSURES_REGEX = /[\(\[\{][^\)\]\}]*[\)\]\}]/g;
var UNWANTED_CHARS_REGEX = /[\0-\u001F\!-/:-@\[-`\{-\u00BF\u0250-\u036F\uD800-\uFFFF]/g;
var PHONENUMBER_REGEX = /^\d+[\d\s]*(:?ext|x|)\s*\d+$/i;
var MULTIPLE_WHITESPACES_REGEX = /\s+/g;
var UNSUPPORTED_TEXT_REGEX = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uAC00-\uD7AF\uD7B0-\uD7FF\u3040-\u309F\u30A0-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF]|[\uD840-\uD869][\uDC00-\uDED6]/;
function getInitialsLatin(displayName, isRtl, firstInitialOnly) {
  let initials = "";
  const splits = displayName.split(" ");
  if (splits.length !== 0) {
    initials += splits[0].charAt(0).toUpperCase();
  }
  if (!firstInitialOnly) {
    if (splits.length === 2) {
      initials += splits[1].charAt(0).toUpperCase();
    } else if (splits.length === 3) {
      initials += splits[2].charAt(0).toUpperCase();
    }
  }
  if (isRtl && initials.length > 1) {
    return initials.charAt(1) + initials.charAt(0);
  }
  return initials;
}
function cleanupDisplayName(displayName) {
  displayName = displayName.replace(UNWANTED_ENCLOSURES_REGEX, "");
  displayName = displayName.replace(UNWANTED_CHARS_REGEX, "");
  displayName = displayName.replace(MULTIPLE_WHITESPACES_REGEX, " ");
  displayName = displayName.trim();
  return displayName;
}
function getInitials(displayName, isRtl, options) {
  if (!displayName) {
    return "";
  }
  displayName = cleanupDisplayName(displayName);
  if (UNSUPPORTED_TEXT_REGEX.test(displayName) || !(options === null || options === void 0 ? void 0 : options.allowPhoneInitials) && PHONENUMBER_REGEX.test(displayName)) {
    return "";
  }
  return getInitialsLatin(displayName, isRtl, options === null || options === void 0 ? void 0 : options.firstInitialOnly);
}

// node_modules/@fluentui/react-badge/lib/components/Badge/Badge.js
var React105 = __toESM(require_react());

// node_modules/@fluentui/react-badge/lib/components/Badge/useBadge.js
var React104 = __toESM(require_react());
var useBadge_unstable = (props, ref) => {
  const { shape = "circular", size: size2 = "medium", iconPosition = "before", appearance = "filled", color = "brand" } = props;
  const state = {
    shape,
    size: size2,
    iconPosition,
    appearance,
    color,
    components: {
      root: "div",
      icon: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    icon: slot_exports.optional(props.icon, {
      elementType: "span"
    })
  };
  return state;
};

// node_modules/@fluentui/react-badge/lib/components/Badge/useBadgeStyles.styles.js
var badgeClassNames = {
  root: "fui-Badge",
  icon: "fui-Badge__icon"
};
var textPadding = tokens.spacingHorizontalXXS;
var useRootClassName = __resetStyles("r1l7mb74", "rntuq2r", [".r1l7mb74{display:inline-flex;box-sizing:border-box;align-items:center;justify-content:center;position:relative;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightSemibold);line-height:var(--lineHeightBase200);height:20px;width:20px;min-width:max-content;padding:0 calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));border-radius:var(--borderRadiusCircular);border-color:var(--colorTransparentStroke);}", '.r1l7mb74::after{content:"";position:absolute;top:0;left:0;bottom:0;right:0;border-style:solid;border-color:inherit;border-width:var(--strokeWidthThin);border-radius:inherit;}', ".rntuq2r{display:inline-flex;box-sizing:border-box;align-items:center;justify-content:center;position:relative;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightSemibold);line-height:var(--lineHeightBase200);height:20px;width:20px;min-width:max-content;padding:0 calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));border-radius:var(--borderRadiusCircular);border-color:var(--colorTransparentStroke);}", '.rntuq2r::after{content:"";position:absolute;top:0;right:0;bottom:0;left:0;border-style:solid;border-color:inherit;border-width:var(--strokeWidthThin);border-radius:inherit;}']);
var useRootStyles4 = __styles({
  fontSmallToTiny: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "f13mqy1h",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "fcpl73t"
  },
  tiny: {
    a9b677: "f16dn6v3",
    Bqenvij: "f3mu39s",
    Be2twd7: "f130uwy9",
    Bg96gwp: "fod1mrr",
    Bf4jedk: "f18p0k4z",
    z8tnut: "f1q8r6hh",
    z189sj: ["fio2s09", "fkiw60q"],
    Byoj8tv: "f9yu9nh",
    uwmqm3: ["fkiw60q", "fio2s09"]
  },
  "extra-small": {
    a9b677: "fpd43o0",
    Bqenvij: "f30q22z",
    Be2twd7: "f1tccstq",
    Bg96gwp: "f1y3arg5",
    Bf4jedk: "f18p0k4z",
    z8tnut: "f1q8r6hh",
    z189sj: ["fio2s09", "fkiw60q"],
    Byoj8tv: "f9yu9nh",
    uwmqm3: ["fkiw60q", "fio2s09"]
  },
  small: {
    a9b677: "fjw5fx7",
    Bqenvij: "fd461yt",
    z8tnut: "f1g0x7ka",
    z189sj: ["fps1v9c", "f17ae1jz"],
    Byoj8tv: "f1qch9an",
    uwmqm3: ["f17ae1jz", "fps1v9c"]
  },
  medium: {},
  large: {
    a9b677: "fq4mcun",
    Bqenvij: "frvgh55",
    z8tnut: "f1g0x7ka",
    z189sj: ["f17a92cs", "f1pe0i86"],
    Byoj8tv: "f1qch9an",
    uwmqm3: ["f1pe0i86", "f17a92cs"]
  },
  "extra-large": {
    a9b677: "f1szoe96",
    Bqenvij: "f1d2rq10",
    z8tnut: "f1g0x7ka",
    z189sj: ["fqznh8f", "f1xile11"],
    Byoj8tv: "f1qch9an",
    uwmqm3: ["f1xile11", "fqznh8f"]
  },
  square: {
    Bbmb7ep: ["fzi6hpg", "fyowgf4"],
    Beyfa6y: ["fyowgf4", "fzi6hpg"],
    B7oj6ja: ["f3fg2lr", "f13av6d4"],
    Btl43ni: ["f13av6d4", "f3fg2lr"]
  },
  rounded: {
    Bbmb7ep: ["f1aa9q02", "f16jpd5f"],
    Beyfa6y: ["f16jpd5f", "f1aa9q02"],
    B7oj6ja: ["f1jar5jt", "fyu767a"],
    Btl43ni: ["fyu767a", "f1jar5jt"]
  },
  roundedSmallToTiny: {
    Bbmb7ep: ["f1g3puop", "fi2rrw2"],
    Beyfa6y: ["fi2rrw2", "f1g3puop"],
    B7oj6ja: ["f1rstyi9", "f1s4nn1u"],
    Btl43ni: ["f1s4nn1u", "f1rstyi9"]
  },
  circular: {},
  borderGhost: {
    ap17g6: "f10ludwy"
  },
  filled: {},
  "filled-brand": {
    De3pzq: "ffp7eso",
    sj55zd: "f1phragk"
  },
  "filled-danger": {
    De3pzq: "fdl5y0r",
    sj55zd: "f1phragk"
  },
  "filled-important": {
    De3pzq: "f1c73kur",
    sj55zd: "fr0bkrk"
  },
  "filled-informative": {
    De3pzq: "f3vzo32",
    sj55zd: "f11d4kpn"
  },
  "filled-severe": {
    De3pzq: "f1s438gw",
    sj55zd: "f1phragk"
  },
  "filled-subtle": {
    De3pzq: "fxugw4r",
    sj55zd: "f19n0e5"
  },
  "filled-success": {
    De3pzq: "flxk52p",
    sj55zd: "f1phragk"
  },
  "filled-warning": {
    De3pzq: "ffq97bm",
    sj55zd: "ff5vbop"
  },
  ghost: {},
  "ghost-brand": {
    sj55zd: "f16muhyy"
  },
  "ghost-danger": {
    sj55zd: "f1whyuy6"
  },
  "ghost-important": {
    sj55zd: "f19n0e5"
  },
  "ghost-informative": {
    sj55zd: "f11d4kpn"
  },
  "ghost-severe": {
    sj55zd: "f1l8vj45"
  },
  "ghost-subtle": {
    sj55zd: "fonrgv7"
  },
  "ghost-success": {
    sj55zd: "f1m7fhi8"
  },
  "ghost-warning": {
    sj55zd: "fpti2h4"
  },
  outline: {
    g2u3we: "f23ftbb",
    h3c5rm: ["f1gkuv52", "f1p1bl80"],
    B9xav0g: "fioka3i",
    zhjwy3: ["f1p1bl80", "f1gkuv52"]
  },
  "outline-brand": {
    sj55zd: "f16muhyy"
  },
  "outline-danger": {
    sj55zd: "f1whyuy6",
    g2u3we: "fyqpifd",
    h3c5rm: ["f3ukxca", "f1k7dugc"],
    B9xav0g: "f1njxb2b",
    zhjwy3: ["f1k7dugc", "f3ukxca"]
  },
  "outline-important": {
    sj55zd: "f11d4kpn",
    g2u3we: "fq0vr37",
    h3c5rm: ["f1byw159", "f11cr0be"],
    B9xav0g: "f1c1zstj",
    zhjwy3: ["f11cr0be", "f1byw159"]
  },
  "outline-informative": {
    sj55zd: "f11d4kpn",
    g2u3we: "f68mrw8",
    h3c5rm: ["f7pw515", "fw35ms5"],
    B9xav0g: "frpde29",
    zhjwy3: ["fw35ms5", "f7pw515"]
  },
  "outline-severe": {
    sj55zd: "f1l8vj45"
  },
  "outline-subtle": {
    sj55zd: "fonrgv7"
  },
  "outline-success": {
    sj55zd: "f1m7fhi8",
    g2u3we: "f1mmhl11",
    h3c5rm: ["f1tjpp2f", "f1ocn5n7"],
    B9xav0g: "f1gjv25d",
    zhjwy3: ["f1ocn5n7", "f1tjpp2f"]
  },
  "outline-warning": {
    sj55zd: "fpti2h4"
  },
  tint: {},
  "tint-brand": {
    De3pzq: "f16xkysk",
    sj55zd: "faj9fo0",
    g2u3we: "f161y7kd",
    h3c5rm: ["f1c8dzaj", "f1sl6hi9"],
    B9xav0g: "f1619yhw",
    zhjwy3: ["f1sl6hi9", "f1c8dzaj"]
  },
  "tint-danger": {
    De3pzq: "ff0poqj",
    sj55zd: "f1hcrxcs",
    g2u3we: "f1oqjm8o",
    h3c5rm: ["fkgrb8g", "frb5wm0"],
    B9xav0g: "f1iai1ph",
    zhjwy3: ["frb5wm0", "fkgrb8g"]
  },
  "tint-important": {
    De3pzq: "f945g0u",
    sj55zd: "fr0bkrk",
    g2u3we: "fghlq4f",
    h3c5rm: ["f1gn591s", "fjscplz"],
    B9xav0g: "fb073pr",
    zhjwy3: ["fjscplz", "f1gn591s"]
  },
  "tint-informative": {
    De3pzq: "f1ctqxl6",
    sj55zd: "f11d4kpn",
    g2u3we: "f68mrw8",
    h3c5rm: ["f7pw515", "fw35ms5"],
    B9xav0g: "frpde29",
    zhjwy3: ["fw35ms5", "f7pw515"]
  },
  "tint-severe": {
    De3pzq: "f1xzsg4",
    sj55zd: "f1k5f75o",
    g2u3we: "fxy9dsj",
    h3c5rm: ["f54u6j2", "fcm23ze"],
    B9xav0g: "f4vf0uq",
    zhjwy3: ["fcm23ze", "f54u6j2"]
  },
  "tint-subtle": {
    De3pzq: "fxugw4r",
    sj55zd: "f11d4kpn",
    g2u3we: "f68mrw8",
    h3c5rm: ["f7pw515", "fw35ms5"],
    B9xav0g: "frpde29",
    zhjwy3: ["fw35ms5", "f7pw515"]
  },
  "tint-success": {
    De3pzq: "f2vsrz6",
    sj55zd: "ffmvakt",
    g2u3we: "fdmic9h",
    h3c5rm: ["f196y6m", "fetptd8"],
    B9xav0g: "f1pev5xq",
    zhjwy3: ["fetptd8", "f196y6m"]
  },
  "tint-warning": {
    De3pzq: "f10s6hli",
    sj55zd: "f42v8de",
    g2u3we: "fn9i3n",
    h3c5rm: ["f1aw8cx4", "f51if14"],
    B9xav0g: "fvq8iai",
    zhjwy3: ["f51if14", "f1aw8cx4"]
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".f13mqy1h{font-size:var(--fontSizeBase100);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fcpl73t{line-height:var(--lineHeightBase100);}", ".f16dn6v3{width:6px;}", ".f3mu39s{height:6px;}", ".f130uwy9{font-size:4px;}", ".fod1mrr{line-height:4px;}", ".f18p0k4z{min-width:unset;}", ".f1q8r6hh{padding-top:unset;}", ".fio2s09{padding-right:unset;}", ".fkiw60q{padding-left:unset;}", ".f9yu9nh{padding-bottom:unset;}", ".fpd43o0{width:10px;}", ".f30q22z{height:10px;}", ".f1tccstq{font-size:6px;}", ".f1y3arg5{line-height:6px;}", ".fjw5fx7{width:16px;}", ".fd461yt{height:16px;}", ".f1g0x7ka{padding-top:0;}", ".fps1v9c{padding-right:calc(var(--spacingHorizontalXXS) + var(--spacingHorizontalXXS));}", ".f17ae1jz{padding-left:calc(var(--spacingHorizontalXXS) + var(--spacingHorizontalXXS));}", ".f1qch9an{padding-bottom:0;}", ".fq4mcun{width:24px;}", ".frvgh55{height:24px;}", ".f17a92cs{padding-right:calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));}", ".f1pe0i86{padding-left:calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));}", ".f1szoe96{width:32px;}", ".f1d2rq10{height:32px;}", ".fqznh8f{padding-right:calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS));}", ".f1xile11{padding-left:calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS));}", ".fzi6hpg{border-bottom-right-radius:var(--borderRadiusNone);}", ".fyowgf4{border-bottom-left-radius:var(--borderRadiusNone);}", ".f3fg2lr{border-top-right-radius:var(--borderRadiusNone);}", ".f13av6d4{border-top-left-radius:var(--borderRadiusNone);}", ".f1aa9q02{border-bottom-right-radius:var(--borderRadiusMedium);}", ".f16jpd5f{border-bottom-left-radius:var(--borderRadiusMedium);}", ".f1jar5jt{border-top-right-radius:var(--borderRadiusMedium);}", ".fyu767a{border-top-left-radius:var(--borderRadiusMedium);}", ".f1g3puop{border-bottom-right-radius:var(--borderRadiusSmall);}", ".fi2rrw2{border-bottom-left-radius:var(--borderRadiusSmall);}", ".f1rstyi9{border-top-right-radius:var(--borderRadiusSmall);}", ".f1s4nn1u{border-top-left-radius:var(--borderRadiusSmall);}", ".f10ludwy::after{display:none;}", ".ffp7eso{background-color:var(--colorBrandBackground);}", ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".fdl5y0r{background-color:var(--colorPaletteRedBackground3);}", ".f1c73kur{background-color:var(--colorNeutralForeground1);}", ".fr0bkrk{color:var(--colorNeutralBackground1);}", ".f3vzo32{background-color:var(--colorNeutralBackground5);}", ".f11d4kpn{color:var(--colorNeutralForeground3);}", ".f1s438gw{background-color:var(--colorPaletteDarkOrangeBackground3);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".flxk52p{background-color:var(--colorPaletteGreenBackground3);}", ".ffq97bm{background-color:var(--colorPaletteYellowBackground3);}", ".ff5vbop{color:var(--colorNeutralForeground1Static);}", ".f16muhyy{color:var(--colorBrandForeground1);}", ".f1whyuy6{color:var(--colorPaletteRedForeground3);}", ".f1l8vj45{color:var(--colorPaletteDarkOrangeForeground3);}", ".fonrgv7{color:var(--colorNeutralForegroundStaticInverted);}", ".f1m7fhi8{color:var(--colorPaletteGreenForeground3);}", ".fpti2h4{color:var(--colorPaletteYellowForeground2);}", ".f23ftbb{border-top-color:currentColor;}", ".f1gkuv52{border-right-color:currentColor;}", ".f1p1bl80{border-left-color:currentColor;}", ".fioka3i{border-bottom-color:currentColor;}", ".fyqpifd{border-top-color:var(--colorPaletteRedBorder2);}", ".f3ukxca{border-right-color:var(--colorPaletteRedBorder2);}", ".f1k7dugc{border-left-color:var(--colorPaletteRedBorder2);}", ".f1njxb2b{border-bottom-color:var(--colorPaletteRedBorder2);}", ".fq0vr37{border-top-color:var(--colorNeutralStrokeAccessible);}", ".f1byw159{border-right-color:var(--colorNeutralStrokeAccessible);}", ".f11cr0be{border-left-color:var(--colorNeutralStrokeAccessible);}", ".f1c1zstj{border-bottom-color:var(--colorNeutralStrokeAccessible);}", ".f68mrw8{border-top-color:var(--colorNeutralStroke2);}", ".f7pw515{border-right-color:var(--colorNeutralStroke2);}", ".fw35ms5{border-left-color:var(--colorNeutralStroke2);}", ".frpde29{border-bottom-color:var(--colorNeutralStroke2);}", ".f1mmhl11{border-top-color:var(--colorPaletteGreenBorder2);}", ".f1tjpp2f{border-right-color:var(--colorPaletteGreenBorder2);}", ".f1ocn5n7{border-left-color:var(--colorPaletteGreenBorder2);}", ".f1gjv25d{border-bottom-color:var(--colorPaletteGreenBorder2);}", ".f16xkysk{background-color:var(--colorBrandBackground2);}", ".faj9fo0{color:var(--colorBrandForeground2);}", ".f161y7kd{border-top-color:var(--colorBrandStroke2);}", ".f1c8dzaj{border-right-color:var(--colorBrandStroke2);}", ".f1sl6hi9{border-left-color:var(--colorBrandStroke2);}", ".f1619yhw{border-bottom-color:var(--colorBrandStroke2);}", ".ff0poqj{background-color:var(--colorPaletteRedBackground1);}", ".f1hcrxcs{color:var(--colorPaletteRedForeground1);}", ".f1oqjm8o{border-top-color:var(--colorPaletteRedBorder1);}", ".fkgrb8g{border-right-color:var(--colorPaletteRedBorder1);}", ".frb5wm0{border-left-color:var(--colorPaletteRedBorder1);}", ".f1iai1ph{border-bottom-color:var(--colorPaletteRedBorder1);}", ".f945g0u{background-color:var(--colorNeutralForeground3);}", ".fghlq4f{border-top-color:var(--colorTransparentStroke);}", ".f1gn591s{border-right-color:var(--colorTransparentStroke);}", ".fjscplz{border-left-color:var(--colorTransparentStroke);}", ".fb073pr{border-bottom-color:var(--colorTransparentStroke);}", ".f1ctqxl6{background-color:var(--colorNeutralBackground4);}", ".f1xzsg4{background-color:var(--colorPaletteDarkOrangeBackground1);}", ".f1k5f75o{color:var(--colorPaletteDarkOrangeForeground1);}", ".fxy9dsj{border-top-color:var(--colorPaletteDarkOrangeBorder1);}", ".f54u6j2{border-right-color:var(--colorPaletteDarkOrangeBorder1);}", ".fcm23ze{border-left-color:var(--colorPaletteDarkOrangeBorder1);}", ".f4vf0uq{border-bottom-color:var(--colorPaletteDarkOrangeBorder1);}", ".f2vsrz6{background-color:var(--colorPaletteGreenBackground1);}", ".ffmvakt{color:var(--colorPaletteGreenForeground1);}", ".fdmic9h{border-top-color:var(--colorPaletteGreenBorder1);}", ".f196y6m{border-right-color:var(--colorPaletteGreenBorder1);}", ".fetptd8{border-left-color:var(--colorPaletteGreenBorder1);}", ".f1pev5xq{border-bottom-color:var(--colorPaletteGreenBorder1);}", ".f10s6hli{background-color:var(--colorPaletteYellowBackground1);}", ".f42v8de{color:var(--colorPaletteYellowForeground1);}", ".fn9i3n{border-top-color:var(--colorPaletteYellowBorder1);}", ".f1aw8cx4{border-right-color:var(--colorPaletteYellowBorder1);}", ".f51if14{border-left-color:var(--colorPaletteYellowBorder1);}", ".fvq8iai{border-bottom-color:var(--colorPaletteYellowBorder1);}"]
});
var useIconRootClassName = __resetStyles("rttl5z0", null, [".rttl5z0{display:flex;line-height:1;margin:0 calc(-1 * var(--spacingHorizontalXXS));font-size:12px;}"]);
var useIconStyles = __styles({
  beforeText: {
    t21cq0: ["f1t8l4o1", "f11juvx6"]
  },
  afterText: {
    Frg6f3: ["f11juvx6", "f1t8l4o1"]
  },
  beforeTextXL: {
    t21cq0: ["f1rs9grm", "f1kwmkpi"]
  },
  afterTextXL: {
    Frg6f3: ["f1kwmkpi", "f1rs9grm"]
  },
  tiny: {
    Be2twd7: "f1tccstq"
  },
  "extra-small": {
    Be2twd7: "fnmn6fi"
  },
  small: {
    Be2twd7: "f1ugzwwg"
  },
  medium: {},
  large: {
    Be2twd7: "f4ybsrx"
  },
  "extra-large": {
    Be2twd7: "fe5j1ua"
  }
}, {
  d: [".f1t8l4o1{margin-right:calc(var(--spacingHorizontalXXS) + var(--spacingHorizontalXXS));}", ".f11juvx6{margin-left:calc(var(--spacingHorizontalXXS) + var(--spacingHorizontalXXS));}", ".f1rs9grm{margin-right:calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));}", ".f1kwmkpi{margin-left:calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));}", ".f1tccstq{font-size:6px;}", ".fnmn6fi{font-size:10px;}", ".f1ugzwwg{font-size:12px;}", ".f4ybsrx{font-size:16px;}", ".fe5j1ua{font-size:20px;}"]
});
var useBadgeStyles_unstable = (state) => {
  const rootClassName = useRootClassName();
  const rootStyles = useRootStyles4();
  const smallToTiny = state.size === "small" || state.size === "extra-small" || state.size === "tiny";
  state.root.className = mergeClasses(badgeClassNames.root, rootClassName, smallToTiny && rootStyles.fontSmallToTiny, rootStyles[state.size], rootStyles[state.shape], state.shape === "rounded" && smallToTiny && rootStyles.roundedSmallToTiny, state.appearance === "ghost" && rootStyles.borderGhost, rootStyles[state.appearance], rootStyles[`${state.appearance}-${state.color}`], state.root.className);
  const iconRootClassName = useIconRootClassName();
  const iconStyles = useIconStyles();
  if (state.icon) {
    let iconPositionClass;
    if (state.root.children) {
      if (state.size === "extra-large") {
        iconPositionClass = state.iconPosition === "after" ? iconStyles.afterTextXL : iconStyles.beforeTextXL;
      } else {
        iconPositionClass = state.iconPosition === "after" ? iconStyles.afterText : iconStyles.beforeText;
      }
    }
    state.icon.className = mergeClasses(badgeClassNames.icon, iconRootClassName, iconPositionClass, iconStyles[state.size], state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-badge/lib/components/Badge/renderBadge.js
var renderBadge_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.iconPosition === "before" && state.icon && jsx(state.icon, {}),
      state.root.children,
      state.iconPosition === "after" && state.icon && jsx(state.icon, {})
    ]
  });
};

// node_modules/@fluentui/react-badge/lib/components/Badge/Badge.js
var Badge = React105.forwardRef((props, ref) => {
  const state = useBadge_unstable(props, ref);
  useBadgeStyles_unstable(state);
  useCustomStyleHook("useBadgeStyles_unstable")(state);
  return renderBadge_unstable(state);
});
Badge.displayName = "Badge";

// node_modules/@fluentui/react-badge/lib/components/PresenceBadge/PresenceBadge.js
var React108 = __toESM(require_react());

// node_modules/@fluentui/react-badge/lib/components/PresenceBadge/usePresenceBadge.js
var React107 = __toESM(require_react());

// node_modules/@fluentui/react-badge/lib/components/PresenceBadge/presenceIcons.js
var React106 = __toESM(require_react());
var presenceAwayRegular = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceAway10Regular,
  "extra-small": PresenceAway10Regular,
  small: PresenceAway12Regular,
  medium: PresenceAway16Regular,
  large: PresenceAway20Regular,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceAway20Regular
};
var presenceAwayFilled = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceAway10Filled,
  "extra-small": PresenceAway10Filled,
  small: PresenceAway12Filled,
  medium: PresenceAway16Filled,
  large: PresenceAway20Filled,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceAway20Filled
};
var presenceAvailableRegular = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceAvailable10Regular,
  "extra-small": PresenceAvailable10Regular,
  small: PresenceAvailable12Regular,
  medium: PresenceAvailable16Regular,
  large: PresenceAvailable20Regular,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceAvailable20Regular
};
var presenceAvailableFilled = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceAvailable10Filled,
  "extra-small": PresenceAvailable10Filled,
  small: PresenceAvailable12Filled,
  medium: PresenceAvailable16Filled,
  large: PresenceAvailable20Filled,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceAvailable20Filled
};
var presenceBlockedRegular = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceBlocked10Regular,
  "extra-small": PresenceBlocked10Regular,
  small: PresenceBlocked12Regular,
  medium: PresenceBlocked16Regular,
  large: PresenceBlocked20Regular,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceBlocked20Regular
};
var presenceBusyFilled = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceBusy10Filled,
  "extra-small": PresenceBusy10Filled,
  small: PresenceBusy12Filled,
  medium: PresenceBusy16Filled,
  large: PresenceBusy20Filled,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceBusy20Filled
};
var presenceDndFilled = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceDnd10Filled,
  "extra-small": PresenceDnd10Filled,
  small: PresenceDnd12Filled,
  medium: PresenceDnd16Filled,
  large: PresenceDnd20Filled,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceDnd20Filled
};
var presenceDndRegular = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceDnd10Regular,
  "extra-small": PresenceDnd10Regular,
  small: PresenceDnd12Regular,
  medium: PresenceDnd16Regular,
  large: PresenceDnd20Regular,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceDnd20Regular
};
var presenceOofRegular = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceOof10Regular,
  "extra-small": PresenceOof10Regular,
  small: PresenceOof12Regular,
  medium: PresenceOof16Regular,
  large: PresenceOof20Regular,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceOof20Regular
};
var presenceOfflineRegular = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceOffline10Regular,
  "extra-small": PresenceOffline10Regular,
  small: PresenceOffline12Regular,
  medium: PresenceOffline16Regular,
  large: PresenceOffline20Regular,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceOffline20Regular
};
var presenceUnknownRegular = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceUnknown10Regular,
  "extra-small": PresenceUnknown10Regular,
  small: PresenceUnknown12Regular,
  medium: PresenceUnknown16Regular,
  large: PresenceUnknown20Regular,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceUnknown20Regular
};

// node_modules/@fluentui/react-badge/lib/components/PresenceBadge/usePresenceBadge.js
var iconMap = (status, outOfOffice, size2) => {
  switch (status) {
    case "available":
      return outOfOffice ? presenceAvailableRegular[size2] : presenceAvailableFilled[size2];
    case "away":
      return outOfOffice ? presenceOofRegular[size2] : presenceAwayFilled[size2];
    case "blocked":
      return presenceBlockedRegular[size2];
    case "busy":
      return outOfOffice ? presenceUnknownRegular[size2] : presenceBusyFilled[size2];
    case "do-not-disturb":
      return outOfOffice ? presenceDndRegular[size2] : presenceDndFilled[size2];
    case "offline":
      return outOfOffice ? presenceOofRegular[size2] : presenceOfflineRegular[size2];
    case "out-of-office":
      return presenceOofRegular[size2];
    case "unknown":
      return presenceUnknownRegular[size2];
  }
};
var DEFAULT_STRINGS = {
  busy: "busy",
  "out-of-office": "out of office",
  away: "away",
  available: "available",
  offline: "offline",
  "do-not-disturb": "do not disturb",
  unknown: "unknown",
  blocked: "blocked"
};
var usePresenceBadge_unstable = (props, ref) => {
  const { size: size2 = "medium", status = "available", outOfOffice = false } = props;
  const statusText = DEFAULT_STRINGS[status];
  const oofText = props.outOfOffice && props.status !== "out-of-office" ? ` ${DEFAULT_STRINGS["out-of-office"]}` : "";
  const IconElement = iconMap(status, outOfOffice, size2);
  const state = {
    ...useBadge_unstable({
      "aria-label": statusText + oofText,
      role: "img",
      ...props,
      size: size2,
      icon: slot_exports.optional(props.icon, {
        defaultProps: {
          children: IconElement ? React107.createElement(IconElement, null) : null
        },
        renderByDefault: true,
        elementType: "span"
      })
    }, ref),
    status,
    outOfOffice
  };
  return state;
};

// node_modules/@fluentui/react-badge/lib/components/PresenceBadge/usePresenceBadgeStyles.styles.js
var presenceBadgeClassNames = {
  root: "fui-PresenceBadge",
  icon: "fui-PresenceBadge__icon"
};
var getIsBusy = (status) => {
  if (status === "busy" || status === "do-not-disturb" || status === "blocked") {
    return true;
  }
  return false;
};
var useRootClassName2 = __resetStyles("r832ydo", null, [".r832ydo{display:inline-flex;box-sizing:border-box;align-items:center;justify-content:center;border-radius:var(--borderRadiusCircular);background-color:var(--colorNeutralBackground1);padding:1px;background-clip:content-box;}"]);
var useIconClassName = __resetStyles("r11ag4qr", null, [".r11ag4qr{display:flex;margin:-1px;}"]);
var useStyles10 = __styles({
  statusBusy: {
    sj55zd: "fvi85wt"
  },
  statusAway: {
    sj55zd: "f14k8a89"
  },
  statusAvailable: {
    sj55zd: "fqa5hgp"
  },
  statusOffline: {
    sj55zd: "f11d4kpn"
  },
  statusOutOfOffice: {
    sj55zd: "fdce8r3"
  },
  statusUnknown: {
    sj55zd: "f11d4kpn"
  },
  outOfOffice: {
    sj55zd: "fr0bkrk"
  },
  outOfOfficeAvailable: {
    sj55zd: "fqa5hgp"
  },
  outOfOfficeBusy: {
    sj55zd: "fvi85wt"
  },
  outOfOfficeUnknown: {
    sj55zd: "f11d4kpn"
  },
  tiny: {
    Bubjx69: "f9ikmtg",
    a9b677: "f16dn6v3",
    B2eet1l: "f1w2irj7",
    B5pe6w7: "fab5kbq",
    p4uzdd: "f1ms1d91"
  },
  large: {
    Bubjx69: "f9ikmtg",
    a9b677: "f64fuq3",
    B5pe6w7: "f1vfi1yj",
    p4uzdd: "f15s34gz"
  },
  extraLarge: {
    Bubjx69: "f9ikmtg",
    a9b677: "f1w9dchk",
    B5pe6w7: "f14efy9b",
    p4uzdd: "fhipgdu"
  }
}, {
  d: [".fvi85wt{color:var(--colorPaletteRedBackground3);}", ".f14k8a89{color:var(--colorPaletteMarigoldBackground3);}", ".fqa5hgp{color:var(--colorPaletteLightGreenForeground3);}", ".f11d4kpn{color:var(--colorNeutralForeground3);}", ".fdce8r3{color:var(--colorPaletteBerryForeground3);}", ".fr0bkrk{color:var(--colorNeutralBackground1);}", ".f9ikmtg{aspect-ratio:1;}", ".f16dn6v3{width:6px;}", ".f1w2irj7{background-clip:unset;}", ".fab5kbq svg{width:6px!important;}", ".f1ms1d91 svg{height:6px!important;}", ".f64fuq3{width:20px;}", ".f1vfi1yj svg{width:20px!important;}", ".f15s34gz svg{height:20px!important;}", ".f1w9dchk{width:28px;}", ".f14efy9b svg{width:28px!important;}", ".fhipgdu svg{height:28px!important;}"]
});
var usePresenceBadgeStyles_unstable = (state) => {
  const rootClassName = useRootClassName2();
  const iconClassName = useIconClassName();
  const styles = useStyles10();
  const isBusy = getIsBusy(state.status);
  state.root.className = mergeClasses(presenceBadgeClassNames.root, rootClassName, isBusy && styles.statusBusy, state.status === "away" && styles.statusAway, state.status === "available" && styles.statusAvailable, state.status === "offline" && styles.statusOffline, state.status === "out-of-office" && styles.statusOutOfOffice, state.status === "unknown" && styles.statusUnknown, state.outOfOffice && styles.outOfOffice, state.outOfOffice && state.status === "available" && styles.outOfOfficeAvailable, state.outOfOffice && isBusy && styles.outOfOfficeBusy, state.outOfOffice && (state.status === "out-of-office" || state.status === "away" || state.status === "offline") && styles.statusOutOfOffice, state.outOfOffice && state.status === "unknown" && styles.outOfOfficeUnknown, state.size === "tiny" && styles.tiny, state.size === "large" && styles.large, state.size === "extra-large" && styles.extraLarge, state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(presenceBadgeClassNames.icon, iconClassName, state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-badge/lib/components/PresenceBadge/PresenceBadge.js
var PresenceBadge = React108.forwardRef((props, ref) => {
  const state = usePresenceBadge_unstable(props, ref);
  usePresenceBadgeStyles_unstable(state);
  useCustomStyleHook("usePresenceBadgeStyles_unstable")(state);
  return renderBadge_unstable(state);
});
PresenceBadge.displayName = "PresenceBadge";

// node_modules/@fluentui/react-badge/lib/components/CounterBadge/CounterBadge.js
var React110 = __toESM(require_react());

// node_modules/@fluentui/react-badge/lib/components/CounterBadge/useCounterBadge.js
var React109 = __toESM(require_react());
var useCounterBadge_unstable = (props, ref) => {
  const { shape = "circular", appearance = "filled", showZero = false, overflowCount = 99, count = 0, dot = false } = props;
  const state = {
    ...useBadge_unstable(props, ref),
    shape,
    appearance,
    showZero,
    count,
    dot
  };
  if ((count !== 0 || showZero) && !dot && !state.root.children) {
    state.root.children = count > overflowCount ? `${overflowCount}+` : `${count}`;
  }
  return state;
};

// node_modules/@fluentui/react-badge/lib/components/CounterBadge/useCounterBadgeStyles.styles.js
var counterBadgeClassNames = {
  root: "fui-CounterBadge",
  icon: "fui-CounterBadge__icon"
};
var useStyles11 = __styles({
  dot: {
    Bf4jedk: "fgfkb25",
    a9b677: "f16dn6v3",
    Bqenvij: "f3mu39s",
    z8tnut: "f1g0x7ka",
    z189sj: ["fhxju0i", "f1cnd47f"],
    Byoj8tv: "f1qch9an",
    uwmqm3: ["f1cnd47f", "fhxju0i"]
  },
  hide: {
    mc9l5x: "fjseox"
  }
}, {
  d: [".fgfkb25{min-width:auto;}", ".f16dn6v3{width:6px;}", ".f3mu39s{height:6px;}", ".f1g0x7ka{padding-top:0;}", ".fhxju0i{padding-right:0;}", ".f1cnd47f{padding-left:0;}", ".f1qch9an{padding-bottom:0;}", ".fjseox{display:none;}"]
});
var useCounterBadgeStyles_unstable = (state) => {
  const styles = useStyles11();
  state.root.className = mergeClasses(counterBadgeClassNames.root, state.dot && styles.dot, !state.root.children && !state.dot && styles.hide, state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(counterBadgeClassNames.icon, state.icon.className);
  }
  return useBadgeStyles_unstable(state);
};

// node_modules/@fluentui/react-badge/lib/components/CounterBadge/CounterBadge.js
var CounterBadge = React110.forwardRef((props, ref) => {
  const state = useCounterBadge_unstable(props, ref);
  useCounterBadgeStyles_unstable(state);
  useCustomStyleHook("useCounterBadgeStyles_unstable")(state);
  return renderBadge_unstable(state);
});
CounterBadge.displayName = "CounterBadge";

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-avatar/lib/contexts/AvatarContext.js
var React111 = __toESM(require_react());
var avatarContext = React111.createContext(void 0);
var avatarContextDefaultValue = {};
var AvatarContextProvider = avatarContext.Provider;
var useAvatarContext = () => {
  var _React_useContext;
  return (_React_useContext = React111.useContext(avatarContext)) !== null && _React_useContext !== void 0 ? _React_useContext : avatarContextDefaultValue;
};

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-avatar/lib/components/Avatar/useAvatar.js
var DEFAULT_STRINGS2 = {
  active: "active",
  inactive: "inactive"
};
var useAvatar_unstable = (props, ref) => {
  const { dir } = useFluent();
  const { shape: contextShape, size: contextSize } = useAvatarContext();
  const { name, size: size2 = contextSize !== null && contextSize !== void 0 ? contextSize : 32, shape = contextShape !== null && contextShape !== void 0 ? contextShape : "circular", active = "unset", activeAppearance = "ring", idForColor } = props;
  let { color = "neutral" } = props;
  if (color === "colorful") {
    var _ref;
    color = avatarColors[getHashCode((_ref = idForColor !== null && idForColor !== void 0 ? idForColor : name) !== null && _ref !== void 0 ? _ref : "") % avatarColors.length];
  }
  const baseId = useId2("avatar-");
  const root = slot_exports.always(getIntrinsicElementProps(
    "span",
    {
      role: "img",
      id: baseId,
      // aria-label and/or aria-labelledby are resolved below
      ...props,
      ref
    },
    /* excludedPropNames: */
    [
      "name"
    ]
  ), {
    elementType: "span"
  });
  const [imageHidden, setImageHidden] = React112.useState(void 0);
  let image = slot_exports.optional(props.image, {
    defaultProps: {
      alt: "",
      role: "presentation",
      "aria-hidden": true,
      hidden: imageHidden
    },
    elementType: "img"
  });
  if (!(image === null || image === void 0 ? void 0 : image.src)) {
    image = void 0;
  }
  if (image) {
    image.onError = mergeCallbacks(image.onError, () => setImageHidden(true));
    image.onLoad = mergeCallbacks(image.onLoad, () => setImageHidden(void 0));
  }
  let initials = slot_exports.optional(props.initials, {
    renderByDefault: true,
    defaultProps: {
      children: getInitials(name, dir === "rtl", {
        firstInitialOnly: size2 <= 16
      }),
      id: baseId + "__initials"
    },
    elementType: "span"
  });
  if (!(initials === null || initials === void 0 ? void 0 : initials.children)) {
    initials = void 0;
  }
  let icon = void 0;
  if (!initials && (!image || imageHidden)) {
    icon = slot_exports.optional(props.icon, {
      renderByDefault: true,
      defaultProps: {
        children: React112.createElement(PersonRegular, null),
        "aria-hidden": true
      },
      elementType: "span"
    });
  }
  const badge = slot_exports.optional(props.badge, {
    defaultProps: {
      size: getBadgeSize(size2),
      id: baseId + "__badge"
    },
    elementType: PresenceBadge
  });
  let activeAriaLabelElement;
  if (!root["aria-label"] && !root["aria-labelledby"]) {
    if (name) {
      root["aria-label"] = name;
      if (badge) {
        root["aria-labelledby"] = root.id + " " + badge.id;
      }
    } else if (initials) {
      root["aria-labelledby"] = initials.id + (badge ? " " + badge.id : "");
    }
    if (active === "active" || active === "inactive") {
      const activeText = DEFAULT_STRINGS2[active];
      if (root["aria-labelledby"]) {
        const activeId = baseId + "__active";
        root["aria-labelledby"] += " " + activeId;
        activeAriaLabelElement = React112.createElement("span", {
          hidden: true,
          id: activeId
        }, activeText);
      } else if (root["aria-label"]) {
        root["aria-label"] += " " + activeText;
      }
    }
  }
  return {
    size: size2,
    shape,
    active,
    activeAppearance,
    activeAriaLabelElement,
    color,
    components: {
      root: "span",
      initials: "span",
      icon: "span",
      image: "img",
      badge: PresenceBadge
    },
    root,
    initials,
    icon,
    image,
    badge
  };
};
var getBadgeSize = (size2) => {
  if (size2 >= 96) {
    return "extra-large";
  } else if (size2 >= 64) {
    return "large";
  } else if (size2 >= 56) {
    return "medium";
  } else if (size2 >= 40) {
    return "small";
  } else if (size2 >= 28) {
    return "extra-small";
  } else {
    return "tiny";
  }
};
var avatarColors = [
  "dark-red",
  "cranberry",
  "red",
  "pumpkin",
  "peach",
  "marigold",
  "gold",
  "brass",
  "brown",
  "forest",
  "seafoam",
  "dark-green",
  "light-teal",
  "teal",
  "steel",
  "blue",
  "royal-blue",
  "cornflower",
  "navy",
  "lavender",
  "purple",
  "grape",
  "lilac",
  "pink",
  "magenta",
  "plum",
  "beige",
  "mink",
  "platinum",
  "anchor"
];
var getHashCode = (str) => {
  let hashCode = 0;
  for (let len = str.length - 1; len >= 0; len--) {
    const ch = str.charCodeAt(len);
    const shift3 = len % 8;
    hashCode ^= (ch << shift3) + (ch >> 8 - shift3);
  }
  return hashCode;
};

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-avatar/lib/components/Avatar/useAvatarStyles.styles.js
var avatarClassNames = {
  root: "fui-Avatar",
  image: "fui-Avatar__image",
  initials: "fui-Avatar__initials",
  icon: "fui-Avatar__icon",
  badge: "fui-Avatar__badge"
};
var useRootClassName3 = __resetStyles("r81b29z", "r1aatmv", {
  r: [".r81b29z{display:inline-block;flex-shrink:0;position:relative;vertical-align:middle;border-radius:var(--borderRadiusCircular);font-family:var(--fontFamilyBase);font-weight:var(--fontWeightSemibold);font-size:var(--fontSizeBase300);width:32px;height:32px;}", ".r81b29z::before,.r81b29z::after{position:absolute;top:0;left:0;bottom:0;right:0;z-index:-1;margin:calc(-2 * var(--fui-Avatar-ringWidth, 0px));border-radius:inherit;transition-property:margin,opacity;transition-timing-function:var(--curveEasyEaseMax),var(--curveLinear);transition-duration:var(--durationUltraSlow),var(--durationSlower);}", ".r81b29z::before{border-style:solid;border-width:var(--fui-Avatar-ringWidth);}", ".r1aatmv{display:inline-block;flex-shrink:0;position:relative;vertical-align:middle;border-radius:var(--borderRadiusCircular);font-family:var(--fontFamilyBase);font-weight:var(--fontWeightSemibold);font-size:var(--fontSizeBase300);width:32px;height:32px;}", ".r1aatmv::before,.r1aatmv::after{position:absolute;top:0;right:0;bottom:0;left:0;z-index:-1;margin:calc(-2 * var(--fui-Avatar-ringWidth, 0px));border-radius:inherit;transition-property:margin,opacity;transition-timing-function:var(--curveEasyEaseMax),var(--curveLinear);transition-duration:var(--durationUltraSlow),var(--durationSlower);}", ".r1aatmv::before{border-style:solid;border-width:var(--fui-Avatar-ringWidth);}"],
  s: ["@media screen and (prefers-reduced-motion: reduce){.r81b29z::before,.r81b29z::after{transition-duration:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.r1aatmv::before,.r1aatmv::after{transition-duration:0.01ms;}}"]
});
var useImageClassName = __resetStyles("r136dc0n", "rjly0nl", [".r136dc0n{position:absolute;top:0;left:0;width:100%;height:100%;border-radius:inherit;object-fit:cover;vertical-align:top;}", ".rjly0nl{position:absolute;top:0;right:0;width:100%;height:100%;border-radius:inherit;object-fit:cover;vertical-align:top;}"]);
var useIconInitialsClassName = __resetStyles("rip04v", "r31uzil", [".rip04v{position:absolute;box-sizing:border-box;top:0;left:0;width:100%;height:100%;line-height:1;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);display:flex;align-items:center;justify-content:center;vertical-align:center;text-align:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border-radius:inherit;}", ".r31uzil{position:absolute;box-sizing:border-box;top:0;right:0;width:100%;height:100%;line-height:1;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);display:flex;align-items:center;justify-content:center;vertical-align:center;text-align:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border-radius:inherit;}"]);
var useStyles12 = __styles({
  textCaption2Strong: {
    Be2twd7: "f13mqy1h"
  },
  textCaption1Strong: {
    Be2twd7: "fy9rknc"
  },
  textSubtitle2: {
    Be2twd7: "fod5ikn"
  },
  textSubtitle1: {
    Be2twd7: "f1pp30po"
  },
  textTitle3: {
    Be2twd7: "f1x0m3f5"
  },
  squareSmall: {
    Bbmb7ep: ["f1g3puop", "fi2rrw2"],
    Beyfa6y: ["fi2rrw2", "f1g3puop"],
    B7oj6ja: ["f1rstyi9", "f1s4nn1u"],
    Btl43ni: ["f1s4nn1u", "f1rstyi9"]
  },
  squareMedium: {
    Bbmb7ep: ["f1aa9q02", "f16jpd5f"],
    Beyfa6y: ["f16jpd5f", "f1aa9q02"],
    B7oj6ja: ["f1jar5jt", "fyu767a"],
    Btl43ni: ["fyu767a", "f1jar5jt"]
  },
  squareLarge: {
    Bbmb7ep: ["f1ldthgs", "frrelxk"],
    Beyfa6y: ["frrelxk", "f1ldthgs"],
    B7oj6ja: ["fobrfso", "ffisxpw"],
    Btl43ni: ["ffisxpw", "fobrfso"]
  },
  squareXLarge: {
    Bbmb7ep: ["fnivh3a", "fc7yr5o"],
    Beyfa6y: ["fc7yr5o", "fnivh3a"],
    B7oj6ja: ["f1el4m67", "f8yange"],
    Btl43ni: ["f8yange", "f1el4m67"]
  },
  activeOrInactive: {
    Bz10aip: "ftfx35i",
    Bmy1vo4: "fv0atk9",
    B3o57yi: "f1iry5bo",
    Bkqvd7p: "f15n41j8",
    Hwfdqs: "f1onx1g3"
  },
  ring: {
    Ftih45: "f1wl9k8s"
  },
  ringBadgeCutout: {
    f4a502: "fp2gujx"
  },
  ringThick: {
    of393c: "fq1w1vq"
  },
  ringThicker: {
    of393c: "fzg6ace"
  },
  ringThickest: {
    of393c: "f1nu8p71"
  },
  shadow: {
    Bsft5z2: "f13zj6fq"
  },
  shadow4: {
    Be6vj1x: "fcjn15l"
  },
  shadow8: {
    Be6vj1x: "f1tm8t9f"
  },
  shadow16: {
    Be6vj1x: "f1a1aohj"
  },
  shadow28: {
    Be6vj1x: "fond6v5"
  },
  inactive: {
    abs64n: "fp25eh",
    Bz10aip: "f1clczzi",
    Bkqvd7p: "f1l3s34x",
    Bucmhp4: "f1f5ar78",
    b2tv09: ["fqxtap0", "fhjukvy"],
    Bfgortx: "f1qj1nzo",
    Bnvr3x9: ["fhjukvy", "fqxtap0"],
    b6ubon: "fw457kn",
    Bqinb2h: "f1wmllxl"
  },
  badge: {
    qhf8xq: "f1euv43f",
    B5kzvoi: "f1yab3r1",
    j35jbq: ["f1e31b4d", "f1vgc2s3"]
  },
  badgeCutout: {
    btxmck: "f1eugkqs"
  },
  badgeAlign: {
    Dnlfbu: ["f1tlnv9o", "f1y9kyih"]
  },
  tiny: {
    Bdjeniz: "f1uwoubl",
    niu6jh: "fid048z"
  },
  "extra-small": {
    Bdjeniz: "f13ar0e0",
    niu6jh: "fid048z"
  },
  small: {
    Bdjeniz: "fwwuruf",
    niu6jh: "fid048z"
  },
  medium: {
    Bdjeniz: "f1af27q5",
    niu6jh: "fid048z"
  },
  large: {
    Bdjeniz: "f18yy57a",
    niu6jh: "f924bxt"
  },
  "extra-large": {
    Bdjeniz: "f2jg042",
    niu6jh: "f924bxt"
  },
  icon12: {
    Be2twd7: "f1ugzwwg"
  },
  icon16: {
    Be2twd7: "f4ybsrx"
  },
  icon20: {
    Be2twd7: "fe5j1ua"
  },
  icon24: {
    Be2twd7: "f1rt2boy"
  },
  icon28: {
    Be2twd7: "f24l1pt"
  },
  icon32: {
    Be2twd7: "ffl51b"
  },
  icon48: {
    Be2twd7: "f18m8u13"
  }
}, {
  d: [".f13mqy1h{font-size:var(--fontSizeBase100);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".f1pp30po{font-size:var(--fontSizeBase500);}", ".f1x0m3f5{font-size:var(--fontSizeBase600);}", ".f1g3puop{border-bottom-right-radius:var(--borderRadiusSmall);}", ".fi2rrw2{border-bottom-left-radius:var(--borderRadiusSmall);}", ".f1rstyi9{border-top-right-radius:var(--borderRadiusSmall);}", ".f1s4nn1u{border-top-left-radius:var(--borderRadiusSmall);}", ".f1aa9q02{border-bottom-right-radius:var(--borderRadiusMedium);}", ".f16jpd5f{border-bottom-left-radius:var(--borderRadiusMedium);}", ".f1jar5jt{border-top-right-radius:var(--borderRadiusMedium);}", ".fyu767a{border-top-left-radius:var(--borderRadiusMedium);}", ".f1ldthgs{border-bottom-right-radius:var(--borderRadiusLarge);}", ".frrelxk{border-bottom-left-radius:var(--borderRadiusLarge);}", ".fobrfso{border-top-right-radius:var(--borderRadiusLarge);}", ".ffisxpw{border-top-left-radius:var(--borderRadiusLarge);}", ".fnivh3a{border-bottom-right-radius:var(--borderRadiusXLarge);}", ".fc7yr5o{border-bottom-left-radius:var(--borderRadiusXLarge);}", ".f1el4m67{border-top-right-radius:var(--borderRadiusXLarge);}", ".f8yange{border-top-left-radius:var(--borderRadiusXLarge);}", ".ftfx35i{transform:perspective(1px);}", ".fv0atk9{transition-property:transform,opacity;}", ".f1iry5bo{transition-duration:var(--durationUltraSlow),var(--durationFaster);}", ".f15n41j8{transition-timing-function:var(--curveEasyEaseMax),var(--curveLinear);}", '.f1wl9k8s::before{content:"";}', ".fp2gujx::before{-webkit-mask-image:radial-gradient(circle at bottom calc(var(--fui-Avatar-badgeRadius) + 2 * var(--fui-Avatar-ringWidth)) var(--fui-Avatar-badgeAlign) calc(var(--fui-Avatar-badgeRadius) + 2 * var(--fui-Avatar-ringWidth)), transparent calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) - 0.25px), white calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) + 0.25px));mask-image:radial-gradient(circle at bottom calc(var(--fui-Avatar-badgeRadius) + 2 * var(--fui-Avatar-ringWidth)) var(--fui-Avatar-badgeAlign) calc(var(--fui-Avatar-badgeRadius) + 2 * var(--fui-Avatar-ringWidth)), transparent calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) - 0.25px), white calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) + 0.25px));}", ".fq1w1vq{--fui-Avatar-ringWidth:var(--strokeWidthThick);}", ".fzg6ace{--fui-Avatar-ringWidth:var(--strokeWidthThicker);}", ".f1nu8p71{--fui-Avatar-ringWidth:var(--strokeWidthThickest);}", '.f13zj6fq::after{content:"";}', ".fcjn15l::after{box-shadow:var(--shadow4);}", ".f1tm8t9f::after{box-shadow:var(--shadow8);}", ".f1a1aohj::after{box-shadow:var(--shadow16);}", ".fond6v5::after{box-shadow:var(--shadow28);}", ".fp25eh{opacity:0.8;}", ".f1clczzi{transform:scale(0.875);}", ".f1l3s34x{transition-timing-function:var(--curveDecelerateMin),var(--curveLinear);}", ".f1f5ar78::before,.f1f5ar78::after{margin-top:0;}", ".fqxtap0::before,.fqxtap0::after{margin-right:0;}", ".fhjukvy::before,.fhjukvy::after{margin-left:0;}", ".f1qj1nzo::before,.f1qj1nzo::after{margin-bottom:0;}", ".fw457kn::before,.fw457kn::after{opacity:0;}", ".f1wmllxl::before,.f1wmllxl::after{transition-timing-function:var(--curveDecelerateMin),var(--curveLinear);}", ".f1euv43f{position:absolute;}", ".f1yab3r1{bottom:0;}", ".f1e31b4d{right:0;}", ".f1vgc2s3{left:0;}", ".f1eugkqs{-webkit-mask-image:radial-gradient(circle at bottom var(--fui-Avatar-badgeRadius) var(--fui-Avatar-badgeAlign) var(--fui-Avatar-badgeRadius), transparent calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) - 0.25px), white calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) + 0.25px));mask-image:radial-gradient(circle at bottom var(--fui-Avatar-badgeRadius) var(--fui-Avatar-badgeAlign) var(--fui-Avatar-badgeRadius), transparent calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) - 0.25px), white calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) + 0.25px));}", ".f1tlnv9o{--fui-Avatar-badgeAlign:right;}", ".f1y9kyih{--fui-Avatar-badgeAlign:left;}", ".f1uwoubl{--fui-Avatar-badgeRadius:3px;}", ".fid048z{--fui-Avatar-badgeGap:var(--strokeWidthThin);}", ".f13ar0e0{--fui-Avatar-badgeRadius:5px;}", ".fwwuruf{--fui-Avatar-badgeRadius:6px;}", ".f1af27q5{--fui-Avatar-badgeRadius:8px;}", ".f18yy57a{--fui-Avatar-badgeRadius:10px;}", ".f924bxt{--fui-Avatar-badgeGap:var(--strokeWidthThick);}", ".f2jg042{--fui-Avatar-badgeRadius:14px;}", ".f1ugzwwg{font-size:12px;}", ".f4ybsrx{font-size:16px;}", ".fe5j1ua{font-size:20px;}", ".f1rt2boy{font-size:24px;}", ".f24l1pt{font-size:28px;}", ".ffl51b{font-size:32px;}", ".f18m8u13{font-size:48px;}"],
  m: [["@media screen and (prefers-reduced-motion: reduce){.f1onx1g3{transition-duration:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }]]
});
var useSizeStyles = __styles({
  "16": {
    a9b677: "fjw5fx7",
    Bqenvij: "fd461yt"
  },
  "20": {
    a9b677: "f64fuq3",
    Bqenvij: "fjamq6b"
  },
  "24": {
    a9b677: "fq4mcun",
    Bqenvij: "frvgh55"
  },
  "28": {
    a9b677: "f1w9dchk",
    Bqenvij: "fxldao9"
  },
  "32": {
    a9b677: "f1szoe96",
    Bqenvij: "f1d2rq10"
  },
  "36": {
    a9b677: "fpdz1er",
    Bqenvij: "f8ljn23"
  },
  "40": {
    a9b677: "feqmc2u",
    Bqenvij: "fbhnoac"
  },
  "48": {
    a9b677: "f124akge",
    Bqenvij: "ff2sm71"
  },
  "56": {
    a9b677: "f1u66zr1",
    Bqenvij: "fzki0ko"
  },
  "64": {
    a9b677: "fa9ln6p",
    Bqenvij: "f16k9i2m"
  },
  "72": {
    a9b677: "fhcae8x",
    Bqenvij: "f1shusfg"
  },
  "96": {
    a9b677: "f1kyr2gn",
    Bqenvij: "fypu0ge"
  },
  "120": {
    a9b677: "fwfqyga",
    Bqenvij: "fjr5b71"
  },
  "128": {
    a9b677: "f1iksgmy",
    Bqenvij: "fele2au"
  }
}, {
  d: [".fjw5fx7{width:16px;}", ".fd461yt{height:16px;}", ".f64fuq3{width:20px;}", ".fjamq6b{height:20px;}", ".fq4mcun{width:24px;}", ".frvgh55{height:24px;}", ".f1w9dchk{width:28px;}", ".fxldao9{height:28px;}", ".f1szoe96{width:32px;}", ".f1d2rq10{height:32px;}", ".fpdz1er{width:36px;}", ".f8ljn23{height:36px;}", ".feqmc2u{width:40px;}", ".fbhnoac{height:40px;}", ".f124akge{width:48px;}", ".ff2sm71{height:48px;}", ".f1u66zr1{width:56px;}", ".fzki0ko{height:56px;}", ".fa9ln6p{width:64px;}", ".f16k9i2m{height:64px;}", ".fhcae8x{width:72px;}", ".f1shusfg{height:72px;}", ".f1kyr2gn{width:96px;}", ".fypu0ge{height:96px;}", ".fwfqyga{width:120px;}", ".fjr5b71{height:120px;}", ".f1iksgmy{width:128px;}", ".fele2au{height:128px;}"]
});
var useColorStyles = __styles({
  neutral: {
    sj55zd: "f11d4kpn",
    De3pzq: "f18f03hv"
  },
  brand: {
    sj55zd: "fonrgv7",
    De3pzq: "f1blnnmj"
  },
  "dark-red": {
    sj55zd: "fqjd1y1",
    De3pzq: "f1vq2oo4"
  },
  cranberry: {
    sj55zd: "fg9gses",
    De3pzq: "f1lwxszt"
  },
  red: {
    sj55zd: "f23f7i0",
    De3pzq: "f1q9qhfq"
  },
  pumpkin: {
    sj55zd: "fjnan08",
    De3pzq: "fz91bi3"
  },
  peach: {
    sj55zd: "fknu15p",
    De3pzq: "f1b9nr51"
  },
  marigold: {
    sj55zd: "f9603vw",
    De3pzq: "f3z4w6d"
  },
  gold: {
    sj55zd: "fmq0uwp",
    De3pzq: "fg50kya"
  },
  brass: {
    sj55zd: "f28g5vo",
    De3pzq: "f4w2gd0"
  },
  brown: {
    sj55zd: "ftl572b",
    De3pzq: "f14wu1f4"
  },
  forest: {
    sj55zd: "f1gymlvd",
    De3pzq: "f19ut4y6"
  },
  seafoam: {
    sj55zd: "fnnb6wn",
    De3pzq: "f1n057jc"
  },
  "dark-green": {
    sj55zd: "ff58qw8",
    De3pzq: "f11t05wk"
  },
  "light-teal": {
    sj55zd: "f1up9qbj",
    De3pzq: "f42feg1"
  },
  teal: {
    sj55zd: "f135dsb4",
    De3pzq: "f6hvv1p"
  },
  steel: {
    sj55zd: "f151dlcp",
    De3pzq: "f1lnp8zf"
  },
  blue: {
    sj55zd: "f1rjv50u",
    De3pzq: "f1ggcpy6"
  },
  "royal-blue": {
    sj55zd: "f1emykk5",
    De3pzq: "f12rj61f"
  },
  cornflower: {
    sj55zd: "fqsigj7",
    De3pzq: "f8k7hur"
  },
  navy: {
    sj55zd: "f1nj97xi",
    De3pzq: "f19gw0ux"
  },
  lavender: {
    sj55zd: "fwctg0i",
    De3pzq: "ff379vm"
  },
  purple: {
    sj55zd: "fjrsgpu",
    De3pzq: "f1mzf1e1"
  },
  grape: {
    sj55zd: "f1fiiydq",
    De3pzq: "f1o4k8oy"
  },
  lilac: {
    sj55zd: "f1res9jt",
    De3pzq: "f1x6mz1o"
  },
  pink: {
    sj55zd: "fv3fbbi",
    De3pzq: "fydlv6t"
  },
  magenta: {
    sj55zd: "f1f1fwnz",
    De3pzq: "f4xb6j5"
  },
  plum: {
    sj55zd: "f8ptl6j",
    De3pzq: "fqo8e26"
  },
  beige: {
    sj55zd: "f1ntv3ld",
    De3pzq: "f101elhj"
  },
  mink: {
    sj55zd: "f1fscmp",
    De3pzq: "f13g8o5c"
  },
  platinum: {
    sj55zd: "f1dr00v2",
    De3pzq: "fkh7blw"
  },
  anchor: {
    sj55zd: "f1f3ti53",
    De3pzq: "fu4yj0j"
  }
}, {
  d: [".f11d4kpn{color:var(--colorNeutralForeground3);}", ".f18f03hv{background-color:var(--colorNeutralBackground6);}", ".fonrgv7{color:var(--colorNeutralForegroundStaticInverted);}", ".f1blnnmj{background-color:var(--colorBrandBackgroundStatic);}", ".fqjd1y1{color:var(--colorPaletteDarkRedForeground2);}", ".f1vq2oo4{background-color:var(--colorPaletteDarkRedBackground2);}", ".fg9gses{color:var(--colorPaletteCranberryForeground2);}", ".f1lwxszt{background-color:var(--colorPaletteCranberryBackground2);}", ".f23f7i0{color:var(--colorPaletteRedForeground2);}", ".f1q9qhfq{background-color:var(--colorPaletteRedBackground2);}", ".fjnan08{color:var(--colorPalettePumpkinForeground2);}", ".fz91bi3{background-color:var(--colorPalettePumpkinBackground2);}", ".fknu15p{color:var(--colorPalettePeachForeground2);}", ".f1b9nr51{background-color:var(--colorPalettePeachBackground2);}", ".f9603vw{color:var(--colorPaletteMarigoldForeground2);}", ".f3z4w6d{background-color:var(--colorPaletteMarigoldBackground2);}", ".fmq0uwp{color:var(--colorPaletteGoldForeground2);}", ".fg50kya{background-color:var(--colorPaletteGoldBackground2);}", ".f28g5vo{color:var(--colorPaletteBrassForeground2);}", ".f4w2gd0{background-color:var(--colorPaletteBrassBackground2);}", ".ftl572b{color:var(--colorPaletteBrownForeground2);}", ".f14wu1f4{background-color:var(--colorPaletteBrownBackground2);}", ".f1gymlvd{color:var(--colorPaletteForestForeground2);}", ".f19ut4y6{background-color:var(--colorPaletteForestBackground2);}", ".fnnb6wn{color:var(--colorPaletteSeafoamForeground2);}", ".f1n057jc{background-color:var(--colorPaletteSeafoamBackground2);}", ".ff58qw8{color:var(--colorPaletteDarkGreenForeground2);}", ".f11t05wk{background-color:var(--colorPaletteDarkGreenBackground2);}", ".f1up9qbj{color:var(--colorPaletteLightTealForeground2);}", ".f42feg1{background-color:var(--colorPaletteLightTealBackground2);}", ".f135dsb4{color:var(--colorPaletteTealForeground2);}", ".f6hvv1p{background-color:var(--colorPaletteTealBackground2);}", ".f151dlcp{color:var(--colorPaletteSteelForeground2);}", ".f1lnp8zf{background-color:var(--colorPaletteSteelBackground2);}", ".f1rjv50u{color:var(--colorPaletteBlueForeground2);}", ".f1ggcpy6{background-color:var(--colorPaletteBlueBackground2);}", ".f1emykk5{color:var(--colorPaletteRoyalBlueForeground2);}", ".f12rj61f{background-color:var(--colorPaletteRoyalBlueBackground2);}", ".fqsigj7{color:var(--colorPaletteCornflowerForeground2);}", ".f8k7hur{background-color:var(--colorPaletteCornflowerBackground2);}", ".f1nj97xi{color:var(--colorPaletteNavyForeground2);}", ".f19gw0ux{background-color:var(--colorPaletteNavyBackground2);}", ".fwctg0i{color:var(--colorPaletteLavenderForeground2);}", ".ff379vm{background-color:var(--colorPaletteLavenderBackground2);}", ".fjrsgpu{color:var(--colorPalettePurpleForeground2);}", ".f1mzf1e1{background-color:var(--colorPalettePurpleBackground2);}", ".f1fiiydq{color:var(--colorPaletteGrapeForeground2);}", ".f1o4k8oy{background-color:var(--colorPaletteGrapeBackground2);}", ".f1res9jt{color:var(--colorPaletteLilacForeground2);}", ".f1x6mz1o{background-color:var(--colorPaletteLilacBackground2);}", ".fv3fbbi{color:var(--colorPalettePinkForeground2);}", ".fydlv6t{background-color:var(--colorPalettePinkBackground2);}", ".f1f1fwnz{color:var(--colorPaletteMagentaForeground2);}", ".f4xb6j5{background-color:var(--colorPaletteMagentaBackground2);}", ".f8ptl6j{color:var(--colorPalettePlumForeground2);}", ".fqo8e26{background-color:var(--colorPalettePlumBackground2);}", ".f1ntv3ld{color:var(--colorPaletteBeigeForeground2);}", ".f101elhj{background-color:var(--colorPaletteBeigeBackground2);}", ".f1fscmp{color:var(--colorPaletteMinkForeground2);}", ".f13g8o5c{background-color:var(--colorPaletteMinkBackground2);}", ".f1dr00v2{color:var(--colorPalettePlatinumForeground2);}", ".fkh7blw{background-color:var(--colorPalettePlatinumBackground2);}", ".f1f3ti53{color:var(--colorPaletteAnchorForeground2);}", ".fu4yj0j{background-color:var(--colorPaletteAnchorBackground2);}"]
});
var useRingColorStyles = __styles({
  neutral: {
    Bic5iru: "f1uuiafn"
  },
  brand: {
    Bic5iru: "f1uuiafn"
  },
  "dark-red": {
    Bic5iru: "f1t2x9on"
  },
  cranberry: {
    Bic5iru: "f1pvshc9"
  },
  red: {
    Bic5iru: "f1ectbk9"
  },
  pumpkin: {
    Bic5iru: "fvzpl0b"
  },
  peach: {
    Bic5iru: "fwj2kd7"
  },
  marigold: {
    Bic5iru: "fr120vy"
  },
  gold: {
    Bic5iru: "f8xmmar"
  },
  brass: {
    Bic5iru: "f1hbety2"
  },
  brown: {
    Bic5iru: "f1vg3s4g"
  },
  forest: {
    Bic5iru: "f1m3olm5"
  },
  seafoam: {
    Bic5iru: "f17xiqtr"
  },
  "dark-green": {
    Bic5iru: "fx32vyh"
  },
  "light-teal": {
    Bic5iru: "f1mkihwv"
  },
  teal: {
    Bic5iru: "fecnooh"
  },
  steel: {
    Bic5iru: "f15hfgzm"
  },
  blue: {
    Bic5iru: "fqproka"
  },
  "royal-blue": {
    Bic5iru: "f17v2w59"
  },
  cornflower: {
    Bic5iru: "fp0q1mo"
  },
  navy: {
    Bic5iru: "f1nlym55"
  },
  lavender: {
    Bic5iru: "f62vk8h"
  },
  purple: {
    Bic5iru: "f15zl69q"
  },
  grape: {
    Bic5iru: "f53w4j7"
  },
  lilac: {
    Bic5iru: "fu2771t"
  },
  pink: {
    Bic5iru: "fzflscs"
  },
  magenta: {
    Bic5iru: "fb6rmqc"
  },
  plum: {
    Bic5iru: "f1a4gm5b"
  },
  beige: {
    Bic5iru: "f1qpf9z1"
  },
  mink: {
    Bic5iru: "f1l7or83"
  },
  platinum: {
    Bic5iru: "fzrj0iu"
  },
  anchor: {
    Bic5iru: "f8oz6wf"
  }
}, {
  d: [".f1uuiafn::before{color:var(--colorBrandStroke1);}", ".f1t2x9on::before{color:var(--colorPaletteDarkRedBorderActive);}", ".f1pvshc9::before{color:var(--colorPaletteCranberryBorderActive);}", ".f1ectbk9::before{color:var(--colorPaletteRedBorderActive);}", ".fvzpl0b::before{color:var(--colorPalettePumpkinBorderActive);}", ".fwj2kd7::before{color:var(--colorPalettePeachBorderActive);}", ".fr120vy::before{color:var(--colorPaletteMarigoldBorderActive);}", ".f8xmmar::before{color:var(--colorPaletteGoldBorderActive);}", ".f1hbety2::before{color:var(--colorPaletteBrassBorderActive);}", ".f1vg3s4g::before{color:var(--colorPaletteBrownBorderActive);}", ".f1m3olm5::before{color:var(--colorPaletteForestBorderActive);}", ".f17xiqtr::before{color:var(--colorPaletteSeafoamBorderActive);}", ".fx32vyh::before{color:var(--colorPaletteDarkGreenBorderActive);}", ".f1mkihwv::before{color:var(--colorPaletteLightTealBorderActive);}", ".fecnooh::before{color:var(--colorPaletteTealBorderActive);}", ".f15hfgzm::before{color:var(--colorPaletteSteelBorderActive);}", ".fqproka::before{color:var(--colorPaletteBlueBorderActive);}", ".f17v2w59::before{color:var(--colorPaletteRoyalBlueBorderActive);}", ".fp0q1mo::before{color:var(--colorPaletteCornflowerBorderActive);}", ".f1nlym55::before{color:var(--colorPaletteNavyBorderActive);}", ".f62vk8h::before{color:var(--colorPaletteLavenderBorderActive);}", ".f15zl69q::before{color:var(--colorPalettePurpleBorderActive);}", ".f53w4j7::before{color:var(--colorPaletteGrapeBorderActive);}", ".fu2771t::before{color:var(--colorPaletteLilacBorderActive);}", ".fzflscs::before{color:var(--colorPalettePinkBorderActive);}", ".fb6rmqc::before{color:var(--colorPaletteMagentaBorderActive);}", ".f1a4gm5b::before{color:var(--colorPalettePlumBorderActive);}", ".f1qpf9z1::before{color:var(--colorPaletteBeigeBorderActive);}", ".f1l7or83::before{color:var(--colorPaletteMinkBorderActive);}", ".fzrj0iu::before{color:var(--colorPalettePlatinumBorderActive);}", ".f8oz6wf::before{color:var(--colorPaletteAnchorBorderActive);}"]
});
var useAvatarStyles_unstable = (state) => {
  const {
    size: size2,
    shape,
    active,
    activeAppearance,
    color
  } = state;
  const rootClassName = useRootClassName3();
  const imageClassName = useImageClassName();
  const iconInitialsClassName = useIconInitialsClassName();
  const styles = useStyles12();
  const sizeStyles = useSizeStyles();
  const colorStyles = useColorStyles();
  const ringColorStyles = useRingColorStyles();
  const rootClasses = [rootClassName, size2 !== 32 && sizeStyles[size2]];
  if (state.badge) {
    rootClasses.push(styles.badgeAlign, styles[state.badge.size || "medium"]);
  }
  if (size2 <= 24) {
    rootClasses.push(styles.textCaption2Strong);
  } else if (size2 <= 28) {
    rootClasses.push(styles.textCaption1Strong);
  } else if (size2 <= 40) {
  } else if (size2 <= 56) {
    rootClasses.push(styles.textSubtitle2);
  } else if (size2 <= 96) {
    rootClasses.push(styles.textSubtitle1);
  } else {
    rootClasses.push(styles.textTitle3);
  }
  if (shape === "square") {
    if (size2 <= 24) {
      rootClasses.push(styles.squareSmall);
    } else if (size2 <= 48) {
      rootClasses.push(styles.squareMedium);
    } else if (size2 <= 72) {
      rootClasses.push(styles.squareLarge);
    } else {
      rootClasses.push(styles.squareXLarge);
    }
  }
  if (active === "active" || active === "inactive") {
    rootClasses.push(styles.activeOrInactive);
    if (activeAppearance === "ring" || activeAppearance === "ring-shadow") {
      rootClasses.push(styles.ring, ringColorStyles[color]);
      if (state.badge) {
        rootClasses.push(styles.ringBadgeCutout);
      }
      if (size2 <= 48) {
        rootClasses.push(styles.ringThick);
      } else if (size2 <= 64) {
        rootClasses.push(styles.ringThicker);
      } else {
        rootClasses.push(styles.ringThickest);
      }
    }
    if (activeAppearance === "shadow" || activeAppearance === "ring-shadow") {
      rootClasses.push(styles.shadow);
      if (size2 <= 28) {
        rootClasses.push(styles.shadow4);
      } else if (size2 <= 48) {
        rootClasses.push(styles.shadow8);
      } else if (size2 <= 64) {
        rootClasses.push(styles.shadow16);
      } else {
        rootClasses.push(styles.shadow28);
      }
    }
    if (active === "inactive") {
      rootClasses.push(styles.inactive);
    }
  }
  state.root.className = mergeClasses(avatarClassNames.root, ...rootClasses, state.root.className);
  if (state.badge) {
    state.badge.className = mergeClasses(avatarClassNames.badge, styles.badge, state.badge.className);
  }
  if (state.image) {
    state.image.className = mergeClasses(avatarClassNames.image, imageClassName, colorStyles[color], state.badge && styles.badgeCutout, state.image.className);
  }
  if (state.initials) {
    state.initials.className = mergeClasses(avatarClassNames.initials, iconInitialsClassName, colorStyles[color], state.badge && styles.badgeCutout, state.initials.className);
  }
  if (state.icon) {
    let iconSizeClass;
    if (size2 <= 16) {
      iconSizeClass = styles.icon12;
    } else if (size2 <= 24) {
      iconSizeClass = styles.icon16;
    } else if (size2 <= 40) {
      iconSizeClass = styles.icon20;
    } else if (size2 <= 48) {
      iconSizeClass = styles.icon24;
    } else if (size2 <= 56) {
      iconSizeClass = styles.icon28;
    } else if (size2 <= 72) {
      iconSizeClass = styles.icon32;
    } else {
      iconSizeClass = styles.icon48;
    }
    state.icon.className = mergeClasses(avatarClassNames.icon, iconInitialsClassName, iconSizeClass, colorStyles[color], state.badge && styles.badgeCutout, state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-avatar/lib/components/Avatar/Avatar.js
var Avatar = React113.forwardRef((props, ref) => {
  const state = useAvatar_unstable(props, ref);
  useAvatarStyles_unstable(state);
  useCustomStyleHook("useAvatarStyles_unstable")(state);
  return renderAvatar_unstable(state);
});
Avatar.displayName = "Avatar";

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-avatar/lib/components/AvatarGroup/AvatarGroup.js
var React118 = __toESM(require_react());

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-context-selector/lib/createContext.js
var React114 = __toESM(require_react());
var import_scheduler = __toESM(require_scheduler());
var createProvider = (Original) => {
  const Provider2 = (props) => {
    const valueRef = React114.useRef(props.value);
    const versionRef = React114.useRef(0);
    const contextValue = React114.useRef();
    if (!contextValue.current) {
      contextValue.current = {
        value: valueRef,
        version: versionRef,
        listeners: []
      };
    }
    useIsomorphicLayoutEffect(() => {
      valueRef.current = props.value;
      versionRef.current += 1;
      (0, import_scheduler.unstable_runWithPriority)(import_scheduler.unstable_NormalPriority, () => {
        contextValue.current.listeners.forEach((listener) => {
          listener([
            versionRef.current,
            props.value
          ]);
        });
      });
    }, [
      props.value
    ]);
    return React114.createElement(Original, {
      value: contextValue.current
    }, props.children);
  };
  if (true) {
    Provider2.displayName = "ContextSelector.Provider";
  }
  return Provider2;
};
var createContext20 = (defaultValue) => {
  const context = React114.createContext({
    value: {
      current: defaultValue
    },
    version: {
      current: -1
    },
    listeners: []
  });
  context.Provider = createProvider(context.Provider);
  delete context.Consumer;
  return context;
};

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-context-selector/lib/useContextSelector.js
var React115 = __toESM(require_react());
var useContextSelector = (context, selector) => {
  const contextValue = React115.useContext(context);
  const { value: { current: value }, version: { current: version2 }, listeners } = contextValue;
  const selected = selector(value);
  const [state, dispatch] = React115.useReducer((prevState, payload) => {
    if (!payload) {
      return [
        value,
        selected
      ];
    }
    if (payload[0] <= version2) {
      if (objectIs(prevState[1], selected)) {
        return prevState;
      }
      return [
        value,
        selected
      ];
    }
    try {
      if (objectIs(prevState[0], payload[1])) {
        return prevState;
      }
      const nextSelected = selector(payload[1]);
      if (objectIs(prevState[1], nextSelected)) {
        return prevState;
      }
      return [
        payload[1],
        nextSelected
      ];
    } catch (e2) {
    }
    return [
      prevState[0],
      prevState[1]
    ];
  }, [
    value,
    selected
  ]);
  if (!objectIs(state[1], selected)) {
    dispatch(void 0);
  }
  useIsomorphicLayoutEffect(() => {
    listeners.push(dispatch);
    return () => {
      const index = listeners.indexOf(dispatch);
      listeners.splice(index, 1);
    };
  }, [
    listeners
  ]);
  return state[1];
};
function is(x2, y2) {
  return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
}
var objectIs = (
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore fallback to native if it exists (not in IE11)
  typeof Object.is === "function" ? Object.is : is
);

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-context-selector/lib/useHasParentContext.js
var React116 = __toESM(require_react());
function useHasParentContext(context) {
  const contextValue = React116.useContext(context);
  if (contextValue.version) {
    return contextValue.version.current !== -1;
  }
  return false;
}

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-avatar/lib/contexts/AvatarGroupContext.js
var AvatarGroupContext = createContext20(void 0);
var avatarGroupContextDefaultValue = {};
var AvatarGroupProvider = AvatarGroupContext.Provider;
var useAvatarGroupContext_unstable = (selector) => useContextSelector(AvatarGroupContext, (ctx = avatarGroupContextDefaultValue) => selector(ctx));

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-avatar/lib/components/AvatarGroup/renderAvatarGroup.js
var renderAvatarGroup_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(AvatarGroupProvider, {
    value: contextValues.avatarGroup,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-avatar/lib/components/AvatarGroup/useAvatarGroup.js
var React117 = __toESM(require_react());
var useAvatarGroup_unstable = (props, ref) => {
  const { layout = "spread", size: size2 = defaultAvatarGroupSize } = props;
  const root = slot_exports.always(getIntrinsicElementProps("div", {
    role: "group",
    ...props,
    // FIXME:
    // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
    // but since it would be a breaking change to fix it, we are casting ref to it's proper type
    ref
  }, [
    "size"
  ]), {
    elementType: "div"
  });
  return {
    layout,
    size: size2,
    components: {
      root: "div"
    },
    root
  };
};
var defaultAvatarGroupSize = 32;

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-avatar/lib/components/AvatarGroup/useAvatarGroupContextValues.js
var useAvatarGroupContextValues = (state) => {
  const { layout, size: size2 } = state;
  const avatarGroup = {
    layout,
    size: size2
  };
  return {
    avatarGroup
  };
};

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-avatar/lib/components/AvatarGroup/useAvatarGroupStyles.styles.js
var avatarGroupClassNames = {
  root: "fui-AvatarGroup"
};
var useStyles13 = __styles({
  base: {
    mc9l5x: "ftuwxu6",
    qhf8xq: "f10pi13n"
  },
  pie: {
    Bgl5zvf: "f1uz6ud1",
    De3pzq: "f1ganh6p",
    Bsw6fvg: "fe2ae1k"
  }
}, {
  d: [".ftuwxu6{display:inline-flex;}", ".f10pi13n{position:relative;}", ".f1uz6ud1{clip-path:circle(50%);}", ".f1ganh6p{background-color:var(--colorTransparentStroke);}"],
  m: [["@media (forced-colors: active){.fe2ae1k{background-color:CanvasText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useAvatarGroupStyles_unstable = (state) => {
  const {
    layout,
    size: size2
  } = state;
  const styles = useStyles13();
  const sizeStyles = useSizeStyles();
  state.root.className = mergeClasses(avatarGroupClassNames.root, styles.base, layout === "pie" && sizeStyles[size2], layout === "pie" && styles.pie, state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-avatar/lib/components/AvatarGroup/AvatarGroup.js
var AvatarGroup = React118.forwardRef((props, ref) => {
  const state = useAvatarGroup_unstable(props, ref);
  const contextValues = useAvatarGroupContextValues(state);
  useAvatarGroupStyles_unstable(state);
  useCustomStyleHook("useAvatarGroupStyles_unstable")(state);
  return renderAvatarGroup_unstable(state, contextValues);
});
AvatarGroup.displayName = "AvatarGroup";

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-avatar/lib/components/AvatarGroupItem/AvatarGroupItem.js
var React120 = __toESM(require_react());

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-avatar/lib/components/AvatarGroupItem/renderAvatarGroupItem.js
var renderAvatarGroupItem_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      jsx(state.avatar, {}),
      state.isOverflowItem && jsx(state.overflowLabel, {})
    ]
  });
};

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-avatar/lib/components/AvatarGroupItem/useAvatarGroupItem.js
var React119 = __toESM(require_react());
var useAvatarGroupItem_unstable = (props, ref) => {
  const groupIsOverflow = useAvatarGroupContext_unstable((ctx) => ctx.isOverflow);
  const groupSize = useAvatarGroupContext_unstable((ctx) => ctx.size);
  const layout = useAvatarGroupContext_unstable((ctx) => ctx.layout);
  const { style, className, ...avatarSlotProps } = props;
  const size2 = groupSize !== null && groupSize !== void 0 ? groupSize : defaultAvatarGroupSize;
  const hasAvatarGroupContext = useHasParentContext(AvatarGroupContext);
  if (!hasAvatarGroupContext) {
    console.warn("AvatarGroupItem must only be used inside an AvatarGroup component.");
  }
  return {
    isOverflowItem: groupIsOverflow,
    layout,
    size: size2,
    components: {
      root: groupIsOverflow ? "li" : "div",
      avatar: Avatar,
      overflowLabel: "span"
    },
    root: slot_exports.always(props.root, {
      defaultProps: {
        style,
        className
      },
      elementType: groupIsOverflow ? "li" : "div"
    }),
    avatar: slot_exports.always(props.avatar, {
      defaultProps: {
        ref,
        size: size2,
        color: "colorful",
        ...avatarSlotProps
      },
      elementType: Avatar
    }),
    overflowLabel: slot_exports.always(props.overflowLabel, {
      defaultProps: {
        // Avatar already has its aria-label set to the name, this will prevent the name to be read twice.
        "aria-hidden": true,
        children: props.name
      },
      elementType: "span"
    })
  };
};

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-avatar/lib/components/AvatarGroupItem/useAvatarGroupItemStyles.styles.js
var avatarGroupItemClassNames = {
  root: "fui-AvatarGroupItem",
  avatar: "fui-AvatarGroupItem__avatar",
  overflowLabel: "fui-AvatarGroupItem__overflowLabel"
};
var useRootStyles5 = __styles({
  base: {
    Bt984gj: "f122n59",
    mc9l5x: "ftuwxu6",
    Bnnss6s: "fi64zpg",
    qhf8xq: "f10pi13n"
  },
  overflowItem: {
    z8tnut: "f1ywm7hm",
    z189sj: ["f7x41pl", "fruq291"],
    Byoj8tv: "f14wxoun",
    uwmqm3: ["fruq291", "f7x41pl"]
  },
  nonOverflowItem: {
    Bbmb7ep: ["f8fbkgy", "f1nfllo7"],
    Beyfa6y: ["f1nfllo7", "f8fbkgy"],
    B7oj6ja: ["f1djnp8u", "f1s8kh49"],
    Btl43ni: ["f1s8kh49", "f1djnp8u"]
  }
}, {
  d: [".f122n59{align-items:center;}", ".ftuwxu6{display:inline-flex;}", ".fi64zpg{flex-shrink:0;}", ".f10pi13n{position:relative;}", ".f1ywm7hm{padding-top:var(--spacingVerticalXS);}", ".f7x41pl{padding-right:var(--spacingHorizontalXS);}", ".fruq291{padding-left:var(--spacingHorizontalXS);}", ".f14wxoun{padding-bottom:var(--spacingVerticalXS);}", ".f8fbkgy{border-bottom-right-radius:var(--borderRadiusCircular);}", ".f1nfllo7{border-bottom-left-radius:var(--borderRadiusCircular);}", ".f1djnp8u{border-top-right-radius:var(--borderRadiusCircular);}", ".f1s8kh49{border-top-left-radius:var(--borderRadiusCircular);}"]
});
var useAvatarStyles = __styles({
  nonOverflowItem: {
    qhf8xq: "f1euv43f"
  },
  pie: {
    Bbmb7ep: ["f1krrbdw", "f1deotkl"],
    Beyfa6y: ["f1deotkl", "f1krrbdw"],
    B7oj6ja: ["f10ostut", "f1ozlkrg"],
    Btl43ni: ["f1ozlkrg", "f10ostut"]
  }
}, {
  d: [".f1euv43f{position:absolute;}", ".f1krrbdw{border-bottom-right-radius:0;}", ".f1deotkl{border-bottom-left-radius:0;}", ".f10ostut{border-top-right-radius:0;}", ".f1ozlkrg{border-top-left-radius:0;}"]
});
var useOverflowLabelStyles = __styles({
  base: {
    Frg6f3: ["foyynoy", "f1vcna3q"],
    sj55zd: "f19n0e5",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi"
  }
}, {
  d: [".foyynoy{margin-left:var(--spacingHorizontalS);}", ".f1vcna3q{margin-right:var(--spacingHorizontalS);}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}"]
});
var useStackStyles = __styles({
  thick: {
    E5pizo: "foiuzp5"
  },
  thicker: {
    E5pizo: "f1x6o7w7"
  },
  thickest: {
    E5pizo: "f2aml1u"
  },
  xxs: {
    jhia2w: ["f1cjco14", "f13dxjc9"]
  },
  xs: {
    jhia2w: ["f15p6bln", "f1bab3ru"]
  },
  s: {
    jhia2w: ["f1v53ncc", "f17pu8r8"]
  },
  l: {
    jhia2w: ["flv48ch", "fnh1ydj"]
  }
}, {
  d: [".foiuzp5{box-shadow:0 0 0 var(--strokeWidthThick) var(--colorNeutralBackground2);}", ".f1x6o7w7{box-shadow:0 0 0 var(--strokeWidthThicker) var(--colorNeutralBackground2);}", ".f2aml1u{box-shadow:0 0 0 var(--strokeWidthThickest) var(--colorNeutralBackground2);}", ".f1cjco14:not(:first-child){margin-left:calc(-1 * var(--spacingHorizontalXXS));}", ".f13dxjc9:not(:first-child){margin-right:calc(-1 * var(--spacingHorizontalXXS));}", ".f15p6bln:not(:first-child){margin-left:calc(-1 * var(--spacingHorizontalXS));}", ".f1bab3ru:not(:first-child){margin-right:calc(-1 * var(--spacingHorizontalXS));}", ".f1v53ncc:not(:first-child){margin-left:calc(-1 * var(--spacingHorizontalS));}", ".f17pu8r8:not(:first-child){margin-right:calc(-1 * var(--spacingHorizontalS));}", ".flv48ch:not(:first-child){margin-left:calc(-1 * var(--spacingHorizontalL));}", ".fnh1ydj:not(:first-child){margin-right:calc(-1 * var(--spacingHorizontalL));}"]
});
var useSpreadStyles = __styles({
  s: {
    jhia2w: ["f7lhxv7", "f6ou2b0"]
  },
  mNudge: {
    jhia2w: ["f1h0okno", "fnnqava"]
  },
  m: {
    jhia2w: ["f1wkt588", "f1maio5g"]
  },
  l: {
    jhia2w: ["f1l333zn", "f1r41m4c"]
  },
  xl: {
    jhia2w: ["fahr13a", "f2n7rbo"]
  }
}, {
  d: [".f7lhxv7:not(:first-child){margin-left:var(--spacingHorizontalS);}", ".f6ou2b0:not(:first-child){margin-right:var(--spacingHorizontalS);}", ".f1h0okno:not(:first-child){margin-left:var(--spacingHorizontalMNudge);}", ".fnnqava:not(:first-child){margin-right:var(--spacingHorizontalMNudge);}", ".f1wkt588:not(:first-child){margin-left:var(--spacingHorizontalM);}", ".f1maio5g:not(:first-child){margin-right:var(--spacingHorizontalM);}", ".f1l333zn:not(:first-child){margin-left:var(--spacingHorizontalL);}", ".f1r41m4c:not(:first-child){margin-right:var(--spacingHorizontalL);}", ".fahr13a:not(:first-child){margin-left:var(--spacingHorizontalXL);}", ".f2n7rbo:not(:first-child){margin-right:var(--spacingHorizontalXL);}"]
});
var usePieStyles = __styles({
  base: {
    qhf8xq: "f1euv43f"
  },
  slices: {
    B3gf25r: "f16m7w7k",
    Be2twx7: ["f1o4hhgz", "fb4gjrz"],
    Bvaow4n: "f1pgb5nx",
    Gpecfs: ["fugirid", "f4sk99m"],
    bhabj1: "fjreaf3",
    B7rc6i7: ["f1k4vw81", "f1w1xcy7"],
    Bwrfys5: "f1ef8vxk",
    Bwuzm9m: ["f1x2qbfv", "f1xwf4nz"],
    fflka: "ff6xuso",
    do7bja: "fzpvk6c",
    Be8zqhl: "f4onu7f",
    Bij0kh0: ["f1ydfez1", "fjensob"],
    Bwexnyt: "f1yv732j",
    Bhe5x6o: "fchq2fj",
    B3kv7bh: "ff5binh"
  },
  rtlSlices: {
    B3gf25r: "f5vdl61",
    Bvaow4n: "f1bnra92",
    bhabj1: "f4ibo7t",
    Bwrfys5: "f17heuis",
    Bwuzm9m: ["f64f2ud", "f1yjglu3"],
    Be8zqhl: "fa6l61x",
    Bij0kh0: ["f1w2396a", "f14ab3yo"]
  },
  thick: {
    uiicq7: "fnyfzln"
  },
  thicker: {
    uiicq7: "f1xdzzot"
  },
  thickest: {
    uiicq7: "f1auhru5"
  }
}, {
  d: [".f1euv43f{position:absolute;}", ".f16m7w7k:nth-of-type(1):nth-last-of-type(2){clip-path:inset(0 calc(25% + (var(--fuiAvatarGroupItem__divider--width) / 2)) 0 25%);}", ".f1o4hhgz:nth-of-type(1):nth-last-of-type(2){left:-25%;}", ".fb4gjrz:nth-of-type(1):nth-last-of-type(2){right:-25%;}", ".f1pgb5nx:nth-of-type(2):nth-last-of-type(1){clip-path:inset(0 25% 0 calc(25% + (var(--fuiAvatarGroupItem__divider--width) / 2)));}", ".fugirid:nth-of-type(2):nth-last-of-type(1){left:25%;}", ".f4sk99m:nth-of-type(2):nth-last-of-type(1){right:25%;}", ".fjreaf3:nth-of-type(1):nth-last-of-type(3){clip-path:inset(0 calc(25% + (var(--fuiAvatarGroupItem__divider--width) / 2)) 0 25%);}", ".f1k4vw81:nth-of-type(1):nth-last-of-type(3){left:-25%;}", ".f1w1xcy7:nth-of-type(1):nth-last-of-type(3){right:-25%;}", ".f1ef8vxk:nth-of-type(2):nth-last-of-type(2){clip-path:inset(0 0 var(--fuiAvatarGroupItem__divider--width) var(--fuiAvatarGroupItem__divider--width));}", ".f1x2qbfv:nth-of-type(2):nth-last-of-type(2){left:50%;}", ".f1xwf4nz:nth-of-type(2):nth-last-of-type(2){right:50%;}", ".ff6xuso:nth-of-type(2):nth-last-of-type(2){transform:scale(0.5);}", ".fzpvk6c:nth-of-type(2):nth-last-of-type(2){transform-origin:0 0;}", ".f4onu7f:nth-of-type(3):nth-last-of-type(1){clip-path:inset(var(--fuiAvatarGroupItem__divider--width) 0 0 var(--fuiAvatarGroupItem__divider--width));}", ".f1ydfez1:nth-of-type(3):nth-last-of-type(1){left:50%;}", ".fjensob:nth-of-type(3):nth-last-of-type(1){right:50%;}", ".f1yv732j:nth-of-type(3):nth-last-of-type(1){top:50%;}", ".fchq2fj:nth-of-type(3):nth-last-of-type(1){transform:scale(0.5);}", ".ff5binh:nth-of-type(3):nth-last-of-type(1){transform-origin:0 0;}", ".f5vdl61:nth-of-type(1):nth-last-of-type(2){clip-path:inset(0 25% 0 calc(25% + (var(--fuiAvatarGroupItem__divider--width) / 2)));}", ".f1bnra92:nth-of-type(2):nth-last-of-type(1){clip-path:inset(0 calc(25% + (var(--fuiAvatarGroupItem__divider--width) / 2)) 0 25%);}", ".f4ibo7t:nth-of-type(1):nth-last-of-type(3){clip-path:inset(0 25% 0 calc(25% + (var(--fuiAvatarGroupItem__divider--width) / 2)));}", ".f17heuis:nth-of-type(2):nth-last-of-type(2){clip-path:inset(0 var(--fuiAvatarGroupItem__divider--width) var(--fuiAvatarGroupItem__divider--width) 0);}", ".f64f2ud:nth-of-type(2):nth-last-of-type(2){left:0;}", ".f1yjglu3:nth-of-type(2):nth-last-of-type(2){right:0;}", ".fa6l61x:nth-of-type(3):nth-last-of-type(1){clip-path:inset(var(--fuiAvatarGroupItem__divider--width) var(--fuiAvatarGroupItem__divider--width) 0 0);}", ".f1w2396a:nth-of-type(3):nth-last-of-type(1){left:0;}", ".f14ab3yo:nth-of-type(3):nth-last-of-type(1){right:0;}", ".fnyfzln{--fuiAvatarGroupItem__divider--width:var(--strokeWidthThick);}", ".f1xdzzot{--fuiAvatarGroupItem__divider--width:var(--strokeWidthThicker);}", ".f1auhru5{--fuiAvatarGroupItem__divider--width:var(--strokeWidthThickest);}"]
});
var useAvatarGroupItemStyles_unstable = (state) => {
  const {
    isOverflowItem,
    layout,
    size: size2
  } = state;
  const {
    dir
  } = useFluent();
  const avatarStyles = useAvatarStyles();
  const overflowLabelStyles = useOverflowLabelStyles();
  const pieStyles = usePieStyles();
  const rootStyles = useRootStyles5();
  const sizeStyles = useSizeStyles();
  const groupChildClassName = useGroupChildClassName(layout, size2);
  const rootClasses = [rootStyles.base];
  if (!isOverflowItem) {
    rootClasses.push(rootStyles.nonOverflowItem);
    rootClasses.push(groupChildClassName);
    rootClasses.push(sizeStyles[size2]);
    if (layout === "pie") {
      rootClasses.push(pieStyles.base);
      if (size2 < 56) {
        rootClasses.push(pieStyles.thick);
      } else if (size2 < 72) {
        rootClasses.push(pieStyles.thicker);
      } else {
        rootClasses.push(pieStyles.thickest);
      }
      rootClasses.push(pieStyles.slices);
      if (dir === "rtl") {
        rootClasses.push(pieStyles.rtlSlices);
      }
    }
  } else {
    rootClasses.push(rootStyles.overflowItem);
  }
  state.root.className = mergeClasses(avatarGroupItemClassNames.root, ...rootClasses, state.root.className);
  state.avatar.className = mergeClasses(avatarGroupItemClassNames.avatar, !isOverflowItem && avatarStyles.nonOverflowItem, layout === "pie" && avatarStyles.pie, state.avatar.className);
  if (state.overflowLabel) {
    state.overflowLabel.className = mergeClasses(avatarGroupItemClassNames.overflowLabel, overflowLabelStyles.base, state.overflowLabel.className);
  }
  return state;
};
var useGroupChildClassName = (layout, size2) => {
  const stackStyles = useStackStyles();
  const spreadStyles = useSpreadStyles();
  const layoutClasses = [];
  if (size2) {
    if (layout === "stack") {
      if (size2 < 56) {
        layoutClasses.push(stackStyles.thick);
      } else if (size2 < 72) {
        layoutClasses.push(stackStyles.thicker);
      } else {
        layoutClasses.push(stackStyles.thickest);
      }
      if (size2 < 24) {
        layoutClasses.push(stackStyles.xxs);
      } else if (size2 < 48) {
        layoutClasses.push(stackStyles.xs);
      } else if (size2 < 96) {
        layoutClasses.push(stackStyles.s);
      } else {
        layoutClasses.push(stackStyles.l);
      }
    } else if (layout === "spread") {
      if (size2 < 20) {
        layoutClasses.push(spreadStyles.s);
      } else if (size2 < 32) {
        layoutClasses.push(spreadStyles.mNudge);
      } else if (size2 < 64) {
        layoutClasses.push(spreadStyles.l);
      } else {
        layoutClasses.push(spreadStyles.xl);
      }
    }
  }
  return mergeClasses(...layoutClasses);
};

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-avatar/lib/components/AvatarGroupItem/AvatarGroupItem.js
var AvatarGroupItem = React120.forwardRef((props, ref) => {
  const state = useAvatarGroupItem_unstable(props, ref);
  useAvatarGroupItemStyles_unstable(state);
  useCustomStyleHook("useAvatarGroupItemStyles_unstable")(state);
  return renderAvatarGroupItem_unstable(state);
});
AvatarGroupItem.displayName = "AvatarGroupItem";

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-avatar/lib/components/AvatarGroupPopover/AvatarGroupPopover.js
var React144 = __toESM(require_react());

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-popover/lib/components/Popover/Popover.js
var React135 = __toESM(require_react());

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-popover/lib/components/Popover/usePopover.js
var React133 = __toESM(require_react());

// node_modules/@fluentui/react-positioning/lib/createVirtualElementFromClick.js
function createVirtualElementFromClick(nativeEvent) {
  const left2 = nativeEvent.clientX;
  const top = nativeEvent.clientY;
  const right2 = left2 + 1;
  const bottom = top + 1;
  function getBoundingClientRect2() {
    return {
      left: left2,
      top,
      right: right2,
      bottom,
      x: left2,
      y: top,
      height: 1,
      width: 1
    };
  }
  return {
    getBoundingClientRect: getBoundingClientRect2
  };
}

// node_modules/@fluentui/react-positioning/lib/constants.js
var DATA_POSITIONING_INTERSECTING = "data-popper-is-intersecting";
var DATA_POSITIONING_ESCAPED = "data-popper-escaped";
var DATA_POSITIONING_HIDDEN = "data-popper-reference-hidden";
var DATA_POSITIONING_PLACEMENT = "data-popper-placement";

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var createCoords = (v2) => ({
  x: v2,
  y: v2
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp2(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i3 = 0; i3 < validMiddleware.length; i3++) {
    const {
      name,
      fn
    } = validMiddleware[i3];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i3 = -1;
      continue;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    ...rects.floating,
    x: x2,
    y: y2
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x2,
      y: y2
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset3 = clamp2(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center != offset3 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset3,
        centerOffset: center - offset3 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d3) => d3.overflows[0] <= 0).sort((a3, b2) => a3.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d3) => [d3.placement, d3.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a3, b2) => a3[1] - b2[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp2(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp2(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x: x2,
        y: y2,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset3 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset3, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const overflowAvailableHeight = height - overflow[heightSide];
      const overflowAvailableWidth = width - overflow[widthSide];
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        const maximumClippingWidth = width - overflow.left - overflow.right;
        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement3(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const webkit = isWebKit();
  const css = getComputedStyle(element);
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement3(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement3(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement3(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement3(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x2 = ($ ? round(rect.width) : rect.width) / width;
  let y2 = ($ ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle(currentIFrame);
      const left2 = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left2;
      y2 += top;
      currentIFrame = getWindow(currentIFrame).frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement3(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement3(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle(body).direction === "rtl") {
    x2 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left2 = clientRect.left + element.clientLeft;
  const scale = isHTMLElement3(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x2 = left2 * scale.x;
  const y2 = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache2) {
  const cachedResult = cache2.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache2.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  return getCssDimensions(element);
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement3(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement3(element) || getComputedStyle(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const window2 = getWindow(element);
  if (!isHTMLElement3(element)) {
    return window2;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
var getElementRects = async function(_ref) {
  let {
    reference,
    floating,
    strategy
  } = _ref;
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  return {
    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),
    floating: {
      x: 0,
      y: 0,
      ...await getDimensionsFn(floating)
    }
  };
};
function isRTL(element) {
  return getComputedStyle(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
var computePosition2 = (reference, floating, options) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@fluentui/react-positioning/lib/usePositioning.js
var React123 = __toESM(require_react());

// node_modules/@fluentui/react-positioning/lib/utils/parseFloatingUIPlacement.js
function parseFloatingUIPlacement(placement) {
  const tokens2 = placement.split("-");
  return {
    side: tokens2[0],
    alignment: tokens2[1]
  };
}

// node_modules/@fluentui/react-positioning/lib/utils/getScrollParent.js
var getParentNode2 = (node) => {
  if (node.nodeName === "HTML") {
    return node;
  }
  return node.parentNode || node.host;
};
var getStyleComputedProperty = (node) => {
  var _node_ownerDocument;
  if (node.nodeType !== 1) {
    return {};
  }
  const window2 = (_node_ownerDocument = node.ownerDocument) === null || _node_ownerDocument === void 0 ? void 0 : _node_ownerDocument.defaultView;
  return window2.getComputedStyle(node, null);
};
var getScrollParent = (node) => {
  const parentNode = node && getParentNode2(node);
  if (!parentNode)
    return document.body;
  switch (parentNode.nodeName) {
    case "HTML":
    case "BODY":
      return parentNode.ownerDocument.body;
    case "#document":
      return parentNode.body;
  }
  const { overflow, overflowX, overflowY } = getStyleComputedProperty(parentNode);
  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return parentNode;
  }
  return getScrollParent(parentNode);
};
var hasScrollParent = (node) => {
  var _scrollParentElement_ownerDocument;
  const scrollParentElement = getScrollParent(node);
  return scrollParentElement ? scrollParentElement !== ((_scrollParentElement_ownerDocument = scrollParentElement.ownerDocument) === null || _scrollParentElement_ownerDocument === void 0 ? void 0 : _scrollParentElement_ownerDocument.body) : false;
};

// node_modules/@fluentui/react-positioning/lib/utils/getBoundary.js
function getBoundary(element, boundary) {
  if (boundary === "window") {
    return element === null || element === void 0 ? void 0 : element.ownerDocument.documentElement;
  }
  if (boundary === "clippingParents") {
    return "clippingAncestors";
  }
  if (boundary === "scrollParent") {
    let boundariesNode = getScrollParent(element);
    if (boundariesNode.nodeName === "BODY") {
      boundariesNode = element === null || element === void 0 ? void 0 : element.ownerDocument.documentElement;
    }
    return boundariesNode;
  }
  return boundary;
}

// node_modules/@fluentui/react-positioning/lib/utils/getReactFiberFromNode.js
var React121 = __toESM(require_react());
var WorkTag;
(function(WorkTag2) {
  WorkTag2[WorkTag2["FunctionComponent"] = 0] = "FunctionComponent";
  WorkTag2[WorkTag2["ClassComponent"] = 1] = "ClassComponent";
  WorkTag2[WorkTag2["IndeterminateComponent"] = 2] = "IndeterminateComponent";
  WorkTag2[WorkTag2["HostRoot"] = 3] = "HostRoot";
  WorkTag2[WorkTag2["HostPortal"] = 4] = "HostPortal";
  WorkTag2[WorkTag2["HostComponent"] = 5] = "HostComponent";
  WorkTag2[WorkTag2["HostText"] = 6] = "HostText";
  WorkTag2[WorkTag2["Fragment"] = 7] = "Fragment";
  WorkTag2[WorkTag2["Mode"] = 8] = "Mode";
  WorkTag2[WorkTag2["ContextConsumer"] = 9] = "ContextConsumer";
  WorkTag2[WorkTag2["ContextProvider"] = 10] = "ContextProvider";
  WorkTag2[WorkTag2["ForwardRef"] = 11] = "ForwardRef";
  WorkTag2[WorkTag2["Profiler"] = 12] = "Profiler";
  WorkTag2[WorkTag2["SuspenseComponent"] = 13] = "SuspenseComponent";
  WorkTag2[WorkTag2["MemoComponent"] = 14] = "MemoComponent";
  WorkTag2[WorkTag2["SimpleMemoComponent"] = 15] = "SimpleMemoComponent";
  WorkTag2[WorkTag2["LazyComponent"] = 16] = "LazyComponent";
  WorkTag2[WorkTag2["IncompleteClassComponent"] = 17] = "IncompleteClassComponent";
  WorkTag2[WorkTag2["DehydratedFragment"] = 18] = "DehydratedFragment";
  WorkTag2[WorkTag2["SuspenseListComponent"] = 19] = "SuspenseListComponent";
  WorkTag2[WorkTag2["FundamentalComponent"] = 20] = "FundamentalComponent";
  WorkTag2[WorkTag2["ScopeComponent"] = 21] = "ScopeComponent";
})(WorkTag || (WorkTag = {}));
function getReactFiberFromNode(elm) {
  if (!elm) {
    return null;
  }
  for (const k2 in elm) {
    if (k2.indexOf("__reactInternalInstance$") === 0 || k2.indexOf("__reactFiber$") === 0) {
      return elm[k2];
    }
  }
  throw new Error("getReactFiber(): Failed to find a React Fiber on a node");
}

// node_modules/@fluentui/react-positioning/lib/utils/mergeArrowOffset.js
function mergeArrowOffset(userOffset, arrowHeight2) {
  if (typeof userOffset === "number") {
    return addArrowOffset(userOffset, arrowHeight2);
  }
  if (typeof userOffset === "object" && userOffset !== null) {
    return addArrowOffset(userOffset, arrowHeight2);
  }
  if (typeof userOffset === "function") {
    return (offsetParams) => {
      const offset3 = userOffset(offsetParams);
      return addArrowOffset(offset3, arrowHeight2);
    };
  }
  return {
    mainAxis: arrowHeight2
  };
}
var addArrowOffset = (offset3, arrowHeight2) => {
  if (typeof offset3 === "number") {
    return {
      mainAxis: offset3 + arrowHeight2
    };
  }
  var _offset_mainAxis;
  return {
    ...offset3,
    mainAxis: ((_offset_mainAxis = offset3.mainAxis) !== null && _offset_mainAxis !== void 0 ? _offset_mainAxis : 0) + arrowHeight2
  };
};

// node_modules/@fluentui/react-positioning/lib/utils/toFloatingUIPadding.js
function toFloatingUIPadding(padding, isRtl) {
  if (typeof padding === "number") {
    return padding;
  }
  const { start, end, ...verticalPadding } = padding;
  const paddingObject = verticalPadding;
  const left2 = isRtl ? "end" : "start";
  const right2 = isRtl ? "start" : "end";
  if (padding[left2]) {
    paddingObject.left = padding[left2];
  }
  if (padding[right2]) {
    paddingObject.right = padding[right2];
  }
  return paddingObject;
}

// node_modules/@fluentui/react-positioning/lib/utils/toFloatingUIPlacement.js
var getPositionMap = (rtl) => ({
  above: "top",
  below: "bottom",
  before: rtl ? "right" : "left",
  after: rtl ? "left" : "right"
});
var getAlignmentMap = () => ({
  start: "start",
  end: "end",
  top: "start",
  bottom: "end",
  center: void 0
});
var shouldAlignToCenter = (p3, a3) => {
  const positionedVertically = p3 === "above" || p3 === "below";
  const alignedVertically = a3 === "top" || a3 === "bottom";
  return positionedVertically && alignedVertically || !positionedVertically && !alignedVertically;
};
var toFloatingUIPlacement = (align, position, rtl) => {
  const alignment = shouldAlignToCenter(position, align) ? "center" : align;
  const computedPosition = position && getPositionMap(rtl)[position];
  const computedAlignment = alignment && getAlignmentMap()[alignment];
  if (computedPosition && computedAlignment) {
    return `${computedPosition}-${computedAlignment}`;
  }
  return computedPosition;
};

// node_modules/@fluentui/react-positioning/lib/utils/fromFloatingUIPlacement.js
var getPositionMap2 = () => ({
  top: "above",
  bottom: "below",
  right: "after",
  left: "before"
});
var getAlignmentMap2 = (position) => {
  if (position === "above" || position === "below") {
    return {
      start: "start",
      end: "end"
    };
  }
  return {
    start: "top",
    end: "bottom"
  };
};
var fromFloatingUIPlacement = (placement) => {
  const { side, alignment: floatingUIAlignment } = parseFloatingUIPlacement(placement);
  const position = getPositionMap2()[side];
  const alignment = floatingUIAlignment && getAlignmentMap2(position)[floatingUIAlignment];
  return {
    position,
    alignment
  };
};

// node_modules/@fluentui/react-positioning/lib/utils/resolvePositioningShorthand.js
var shorthandLookup = {
  above: {
    position: "above",
    align: "center"
  },
  "above-start": {
    position: "above",
    align: "start"
  },
  "above-end": {
    position: "above",
    align: "end"
  },
  below: {
    position: "below",
    align: "center"
  },
  "below-start": {
    position: "below",
    align: "start"
  },
  "below-end": {
    position: "below",
    align: "end"
  },
  before: {
    position: "before",
    align: "center"
  },
  "before-top": {
    position: "before",
    align: "top"
  },
  "before-bottom": {
    position: "before",
    align: "bottom"
  },
  after: {
    position: "after",
    align: "center"
  },
  "after-top": {
    position: "after",
    align: "top"
  },
  "after-bottom": {
    position: "after",
    align: "bottom"
  }
};
function resolvePositioningShorthand(shorthand) {
  if (shorthand === void 0 || shorthand === null) {
    return {};
  }
  if (typeof shorthand === "string") {
    return shorthandLookup[shorthand];
  }
  return shorthand;
}

// node_modules/@fluentui/react-positioning/lib/utils/useCallbackRef.js
var React122 = __toESM(require_react());
function useCallbackRef(initialValue, callback, skipInitialResolve) {
  const isFirst = React122.useRef(true);
  const [ref] = React122.useState(() => ({
    // value
    value: initialValue,
    // last callback
    callback,
    // "memoized" public interface
    facade: {
      get current() {
        return ref.value;
      },
      set current(value) {
        const last = ref.value;
        if (last !== value) {
          ref.value = value;
          if (skipInitialResolve && isFirst.current) {
            return;
          }
          ref.callback(value, last);
        }
      }
    }
  }));
  useIsomorphicLayoutEffect(() => {
    isFirst.current = false;
  }, []);
  ref.callback = callback;
  return ref.facade;
}

// node_modules/@fluentui/react-positioning/lib/utils/debounce.js
function debounce(fn) {
  let pending;
  return () => {
    if (!pending) {
      pending = new Promise((resolve) => {
        Promise.resolve().then(() => {
          pending = void 0;
          resolve(fn());
        });
      });
    }
    return pending;
  };
}

// node_modules/@fluentui/react-positioning/lib/utils/hasAutoFocusFilter.js
function hasAutofocusProp(node) {
  const isAutoFocusableElement = node.nodeName === "BUTTON" || node.nodeName === "INPUT" || node.nodeName === "SELECT" || node.nodeName === "TEXTAREA";
  if (isAutoFocusableElement) {
    var _getReactFiberFromNode;
    return !!((_getReactFiberFromNode = getReactFiberFromNode(node)) === null || _getReactFiberFromNode === void 0 ? void 0 : _getReactFiberFromNode.pendingProps.autoFocus);
  }
  return false;
}
function hasAutofocusFilter(node) {
  return hasAutofocusProp(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
}

// node_modules/@fluentui/react-positioning/lib/utils/writeArrowUpdates.js
function writeArrowUpdates(options) {
  const { arrow: arrow2, middlewareData } = options;
  if (!middlewareData.arrow || !arrow2) {
    return;
  }
  const { x: arrowX, y: arrowY } = middlewareData.arrow;
  Object.assign(arrow2.style, {
    left: `${arrowX}px`,
    top: `${arrowY}px`
  });
}

// node_modules/@fluentui/react-positioning/lib/utils/writeContainerupdates.js
function writeContainerUpdates(options) {
  var _middlewareData_hide, _middlewareData_hide1, _container_ownerDocument_defaultView;
  const { container, placement, middlewareData, strategy, lowPPI, coordinates, useTransform = true } = options;
  if (!container) {
    return;
  }
  container.setAttribute(DATA_POSITIONING_PLACEMENT, placement);
  container.removeAttribute(DATA_POSITIONING_INTERSECTING);
  if (middlewareData.intersectionObserver.intersecting) {
    container.setAttribute(DATA_POSITIONING_INTERSECTING, "");
  }
  container.removeAttribute(DATA_POSITIONING_ESCAPED);
  if ((_middlewareData_hide = middlewareData.hide) === null || _middlewareData_hide === void 0 ? void 0 : _middlewareData_hide.escaped) {
    container.setAttribute(DATA_POSITIONING_ESCAPED, "");
  }
  container.removeAttribute(DATA_POSITIONING_HIDDEN);
  if ((_middlewareData_hide1 = middlewareData.hide) === null || _middlewareData_hide1 === void 0 ? void 0 : _middlewareData_hide1.referenceHidden) {
    container.setAttribute(DATA_POSITIONING_HIDDEN, "");
  }
  const devicePixelRatio = ((_container_ownerDocument_defaultView = container.ownerDocument.defaultView) === null || _container_ownerDocument_defaultView === void 0 ? void 0 : _container_ownerDocument_defaultView.devicePixelRatio) || 1;
  const x2 = Math.round(coordinates.x * devicePixelRatio) / devicePixelRatio;
  const y2 = Math.round(coordinates.y * devicePixelRatio) / devicePixelRatio;
  Object.assign(container.style, {
    position: strategy
  });
  if (useTransform) {
    Object.assign(container.style, {
      transform: lowPPI ? `translate(${x2}px, ${y2}px)` : `translate3d(${x2}px, ${y2}px, 0)`
    });
    return;
  }
  Object.assign(container.style, {
    left: `${x2}px`,
    top: `${y2}px`
  });
}

// node_modules/@fluentui/react-positioning/lib/utils/normalizeAutoSize.js
var normalizeAutoSize = (autoSize) => {
  switch (autoSize) {
    case "always":
    case true:
      return {
        applyMaxWidth: true,
        applyMaxHeight: true
      };
    case "width-always":
    case "width":
      return {
        applyMaxWidth: true,
        applyMaxHeight: false
      };
    case "height-always":
    case "height":
      return {
        applyMaxWidth: false,
        applyMaxHeight: true
      };
    default:
      return false;
  }
};

// node_modules/@fluentui/react-positioning/lib/middleware/coverTarget.js
function coverTarget() {
  return {
    name: "coverTarget",
    fn: (middlewareArguments) => {
      const { placement, rects, x: x2, y: y2 } = middlewareArguments;
      const basePlacement = parseFloatingUIPlacement(placement).side;
      const newCoords = {
        x: x2,
        y: y2
      };
      switch (basePlacement) {
        case "bottom":
          newCoords.y -= rects.reference.height;
          break;
        case "top":
          newCoords.y += rects.reference.height;
          break;
        case "left":
          newCoords.x += rects.reference.width;
          break;
        case "right":
          newCoords.x -= rects.reference.width;
          break;
      }
      return newCoords;
    }
  };
}

// node_modules/@fluentui/react-positioning/lib/middleware/flip.js
function flip2(options) {
  const { hasScrollableElement, flipBoundary, container, fallbackPositions = [], isRtl } = options;
  const fallbackPlacements = fallbackPositions.reduce((acc, shorthand) => {
    const { position, align } = resolvePositioningShorthand(shorthand);
    const placement = toFloatingUIPlacement(align, position, isRtl);
    if (placement) {
      acc.push(placement);
    }
    return acc;
  }, []);
  return flip({
    ...hasScrollableElement && {
      boundary: "clippingAncestors"
    },
    ...flipBoundary && {
      altBoundary: true,
      boundary: getBoundary(container, flipBoundary)
    },
    fallbackStrategy: "bestFit",
    ...fallbackPlacements.length && {
      fallbackPlacements
    }
  });
}

// node_modules/@fluentui/react-positioning/lib/middleware/intersecting.js
function intersecting() {
  return {
    name: "intersectionObserver",
    fn: async (middlewareArguments) => {
      const floatingRect = middlewareArguments.rects.floating;
      const altOverflow = await detectOverflow(middlewareArguments, {
        altBoundary: true
      });
      const isIntersectingTop = altOverflow.top < floatingRect.height && altOverflow.top > 0;
      const isIntersectingBottom = altOverflow.bottom < floatingRect.height && altOverflow.bottom > 0;
      const isIntersecting = isIntersectingTop || isIntersectingBottom;
      return {
        data: {
          intersecting: isIntersecting
        }
      };
    }
  };
}

// node_modules/@fluentui/react-positioning/lib/middleware/maxSize.js
var resetMaxSize = (autoSize) => ({
  name: "resetMaxSize",
  fn({ middlewareData, elements }) {
    var _middlewareData_resetMaxSize;
    if ((_middlewareData_resetMaxSize = middlewareData.resetMaxSize) === null || _middlewareData_resetMaxSize === void 0 ? void 0 : _middlewareData_resetMaxSize.maxSizeAlreadyReset) {
      return {};
    }
    const { applyMaxWidth, applyMaxHeight } = autoSize;
    if (applyMaxWidth) {
      elements.floating.style.removeProperty("box-sizing");
      elements.floating.style.removeProperty("max-width");
      elements.floating.style.removeProperty("width");
    }
    if (applyMaxHeight) {
      elements.floating.style.removeProperty("box-sizing");
      elements.floating.style.removeProperty("max-height");
      elements.floating.style.removeProperty("height");
    }
    return {
      data: {
        maxSizeAlreadyReset: true
      },
      reset: {
        rects: true
      }
    };
  }
});
function maxSize(autoSize, options) {
  const { container, overflowBoundary } = options;
  return size({
    ...overflowBoundary && {
      altBoundary: true,
      boundary: getBoundary(container, overflowBoundary)
    },
    apply({ availableHeight, availableWidth, elements, rects }) {
      const applyMaxSizeStyles = (apply, dimension, availableSize) => {
        if (!apply) {
          return;
        }
        elements.floating.style.setProperty("box-sizing", "border-box");
        elements.floating.style.setProperty(`max-${dimension}`, `${availableSize}px`);
        if (rects.floating[dimension] > availableSize) {
          elements.floating.style.setProperty(dimension, `${availableSize}px`);
          const axis = dimension === "width" ? "x" : "y";
          if (!elements.floating.style.getPropertyValue(`overflow-${axis}`)) {
            elements.floating.style.setProperty(`overflow-${axis}`, "auto");
          }
        }
      };
      const { applyMaxWidth, applyMaxHeight } = autoSize;
      applyMaxSizeStyles(applyMaxWidth, "width", availableWidth);
      applyMaxSizeStyles(applyMaxHeight, "height", availableHeight);
    }
  });
}

// node_modules/@fluentui/react-positioning/lib/utils/getFloatingUIOffset.js
function getFloatingUIOffset(rawOffset) {
  if (!rawOffset) {
    return rawOffset;
  }
  if (typeof rawOffset === "number" || typeof rawOffset === "object") {
    return rawOffset;
  }
  return ({ rects: { floating, reference }, placement }) => {
    const { position, alignment } = fromFloatingUIPlacement(placement);
    return rawOffset({
      positionedRect: floating,
      targetRect: reference,
      position,
      alignment
    });
  };
}

// node_modules/@fluentui/react-positioning/lib/middleware/offset.js
function offset2(offsetValue) {
  const floatingUIOffset = getFloatingUIOffset(offsetValue);
  return offset(floatingUIOffset);
}

// node_modules/@fluentui/react-positioning/lib/middleware/shift.js
function shift2(options) {
  const { hasScrollableElement, disableTether, overflowBoundary, container, overflowBoundaryPadding, isRtl } = options;
  return shift({
    ...hasScrollableElement && {
      boundary: "clippingAncestors"
    },
    ...disableTether && {
      crossAxis: disableTether === "all",
      limiter: limitShift({
        crossAxis: disableTether !== "all",
        mainAxis: false
      })
    },
    ...overflowBoundaryPadding && {
      padding: toFloatingUIPadding(overflowBoundaryPadding, isRtl)
    },
    ...overflowBoundary && {
      altBoundary: true,
      boundary: getBoundary(container, overflowBoundary)
    }
  });
}

// node_modules/@fluentui/react-positioning/lib/middleware/matchTargetSize.js
function matchTargetSize() {
  return {
    name: "matchTargetSize",
    fn: async (middlewareArguments) => {
      const { rects: { reference: referenceRect, floating: floatingRect }, elements: { floating: floatingElement }, middlewareData: { matchTargetSize: { matchTargetSizeAttempt = false } = {} } } = middlewareArguments;
      if (referenceRect.width === floatingRect.width || matchTargetSizeAttempt) {
        return {};
      }
      const { width } = referenceRect;
      floatingElement.style.width = `${width}px`;
      floatingElement.style.boxSizing = "border-box";
      return {
        data: {
          matchTargetSizeAttempt: true
        },
        reset: {
          rects: true
        }
      };
    }
  };
}

// node_modules/@fluentui/react-positioning/lib/utils/listScrollParents.js
function listScrollParents(node) {
  const scrollParents = [];
  let cur = node;
  while (cur) {
    const scrollParent = getScrollParent(cur);
    if (node.ownerDocument.body === scrollParent) {
      scrollParents.push(scrollParent);
      break;
    }
    scrollParents.push(scrollParent);
    cur = scrollParent;
  }
  return scrollParents;
}

// node_modules/@fluentui/react-positioning/lib/createPositionManager.js
function createPositionManager(options) {
  const { container, target, arrow: arrow2, strategy, middleware, placement, useTransform = true } = options;
  let isDestroyed = false;
  if (!target || !container) {
    return {
      updatePosition: () => void 0,
      dispose: () => void 0
    };
  }
  let isFirstUpdate = true;
  const scrollParents = /* @__PURE__ */ new Set();
  const targetWindow = container.ownerDocument.defaultView;
  Object.assign(container.style, {
    position: "fixed",
    left: 0,
    top: 0,
    margin: 0
  });
  const forceUpdate = () => {
    if (isDestroyed) {
      return;
    }
    if (isFirstUpdate) {
      listScrollParents(container).forEach((scrollParent) => scrollParents.add(scrollParent));
      if (isHTMLElement(target)) {
        listScrollParents(target).forEach((scrollParent) => scrollParents.add(scrollParent));
      }
      scrollParents.forEach((scrollParent) => {
        scrollParent.addEventListener("scroll", updatePosition, {
          passive: true
        });
      });
      isFirstUpdate = false;
    }
    Object.assign(container.style, {
      position: strategy
    });
    computePosition2(target, container, {
      placement,
      middleware,
      strategy
    }).then(({ x: x2, y: y2, middlewareData, placement: computedPlacement }) => {
      if (isDestroyed) {
        return;
      }
      writeArrowUpdates({
        arrow: arrow2,
        middlewareData
      });
      writeContainerUpdates({
        container,
        middlewareData,
        placement: computedPlacement,
        coordinates: {
          x: x2,
          y: y2
        },
        lowPPI: ((targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.devicePixelRatio) || 1) <= 1,
        strategy,
        useTransform
      });
    }).catch((err) => {
      if (true) {
        console.error("[usePositioning]: Failed to calculate position", err);
      }
    });
  };
  const updatePosition = debounce(() => forceUpdate());
  const dispose = () => {
    isDestroyed = true;
    if (targetWindow) {
      targetWindow.removeEventListener("scroll", updatePosition);
      targetWindow.removeEventListener("resize", updatePosition);
    }
    scrollParents.forEach((scrollParent) => {
      scrollParent.removeEventListener("scroll", updatePosition);
    });
    scrollParents.clear();
  };
  if (targetWindow) {
    targetWindow.addEventListener("scroll", updatePosition, {
      passive: true
    });
    targetWindow.addEventListener("resize", updatePosition);
  }
  updatePosition();
  return {
    updatePosition,
    dispose
  };
}

// node_modules/floating-ui-devtools/lib/floating-ui-devtools.js
var s2 = "__FUIDT_CONTROLLER__";
var i2 = "__FUIDT_ELEMENT_METADATA__";
var a2 = "__FUIDT_HTML_ELEMENT_REFERENCE__";
var c2 = (e2) => !!(e2 && i2 in e2 && e2.parentElement !== null);
var d2 = () => {
  let e2 = null;
  const n2 = new MutationObserver((r2) => {
    if (e2)
      for (const t2 of r2)
        t2.type === "childList" && Array.from(t2.removedNodes).includes(e2) && o2.withdraw();
  }), o2 = {
    get selectedElement() {
      return e2;
    },
    select: (r2) => (c2(r2) && (e2 = r2, n2.observe(r2.parentElement, { childList: true, subtree: false })), e2 && r2 && f2(e2, r2) || o2.withdraw(), e2),
    withdraw: () => {
      e2 = null, n2.disconnect();
    }
  };
  return o2;
};
var l2 = (e2) => {
  e2.defaultView && (e2.defaultView[s2] || (e2.defaultView[s2] = d2()));
};
function f2(e2, n2) {
  const o2 = e2[i2];
  switch (o2.type) {
    case "middleware":
      return o2.references.has(n2);
    default:
      return false;
  }
}
function u2(e2, n2) {
  var o2;
  const r2 = e2;
  var t2;
  return !!(!(r2 == null || (o2 = r2.ownerDocument) === null || o2 === void 0) && o2.defaultView && r2 instanceof r2.ownerDocument.defaultView[(t2 = n2 == null ? void 0 : n2.constructorName) !== null && t2 !== void 0 ? t2 : "HTMLElement"]);
}
function E2() {
  return `${a2}:${crypto.randomUUID()}`;
}
function _() {
  const e2 = /* @__PURE__ */ new WeakSet(), n2 = /* @__PURE__ */ new Map();
  return {
    add(r2) {
      const t2 = E2();
      return n2.set(t2, r2), e2.add(r2), t2;
    },
    get(r2) {
      const t2 = n2.get(r2);
      if (t2 && e2.has(t2))
        return t2;
    },
    has(r2) {
      return e2.has(r2);
    }
  };
}
var w2 = (e2) => {
  const n2 = _();
  return [JSON.parse(
    JSON.stringify(e2, (r2, t2) => u2(t2) ? n2.add(t2) : typeof t2 == "object" && t2 && Object.getPrototypeOf(t2) !== Object.prototype && Object.getPrototypeOf(t2) !== Array.prototype ? "toString" in t2 ? t2.toString() : void 0 : t2)
  ), n2];
};
var m2 = (e2, n2 = p2) => ({
  name: "floating-ui-devtools",
  fn: (o2) => {
    l2(e2);
    const [r2, t2] = w2(n2(o2));
    return Object.assign(o2.elements.floating, {
      [i2]: { references: t2, serializedData: r2, type: "middleware" }
    }), {};
  }
});
var p2 = (e2) => ({
  ...e2,
  type: "FloatingUIMiddleware"
});

// node_modules/@fluentui/react-positioning/lib/utils/devtools.js
var devtoolsCallback = (options) => (middlewareState) => {
  const { elements: { floating, reference } } = middlewareState;
  const scrollParentsSet = /* @__PURE__ */ new Set();
  if (isHTMLElement(reference)) {
    listScrollParents(reference).forEach((scrollParent) => scrollParentsSet.add(scrollParent));
  }
  listScrollParents(floating).forEach((scrollParent) => scrollParentsSet.add(scrollParent));
  const flipBoundaries = Array.isArray(options.flipBoundary) ? options.flipBoundary : isHTMLElement(options.flipBoundary) ? [
    options.flipBoundary
  ] : [];
  const overflowBoundaries = Array.isArray(options.overflowBoundary) ? options.overflowBoundary : isHTMLElement(options.overflowBoundary) ? [
    options.overflowBoundary
  ] : [];
  return {
    type: "FluentUIMiddleware",
    middlewareState,
    options,
    initialPlacement: fromFloatingUIPlacement(middlewareState.initialPlacement),
    placement: fromFloatingUIPlacement(middlewareState.placement),
    flipBoundaries,
    overflowBoundaries,
    scrollParents: Array.from(scrollParentsSet)
  };
};

// node_modules/@fluentui/react-positioning/lib/usePositioning.js
function usePositioning(options) {
  const managerRef = React123.useRef(null);
  const targetRef = React123.useRef(null);
  const overrideTargetRef = React123.useRef(null);
  const containerRef = React123.useRef(null);
  const arrowRef = React123.useRef(null);
  const { enabled = true } = options;
  const resolvePositioningOptions = usePositioningOptions(options);
  const updatePositionManager = React123.useCallback(() => {
    if (managerRef.current) {
      managerRef.current.dispose();
    }
    managerRef.current = null;
    var _overrideTargetRef_current;
    const target = (_overrideTargetRef_current = overrideTargetRef.current) !== null && _overrideTargetRef_current !== void 0 ? _overrideTargetRef_current : targetRef.current;
    if (enabled && canUseDOM() && target && containerRef.current) {
      managerRef.current = createPositionManager({
        container: containerRef.current,
        target,
        arrow: arrowRef.current,
        ...resolvePositioningOptions(containerRef.current, arrowRef.current)
      });
    }
  }, [
    enabled,
    resolvePositioningOptions
  ]);
  const setOverrideTarget = useEventCallback((target) => {
    overrideTargetRef.current = target;
    updatePositionManager();
  });
  React123.useImperativeHandle(options.positioningRef, () => ({
    updatePosition: () => {
      var _managerRef_current;
      return (_managerRef_current = managerRef.current) === null || _managerRef_current === void 0 ? void 0 : _managerRef_current.updatePosition();
    },
    setTarget: (target) => {
      if (options.target && true) {
        const err = new Error();
        console.warn("Imperative setTarget should not be used at the same time as target option");
        console.warn(err.stack);
      }
      setOverrideTarget(target);
    }
  }), [
    options.target,
    setOverrideTarget
  ]);
  useIsomorphicLayoutEffect(() => {
    var _options_target;
    setOverrideTarget((_options_target = options.target) !== null && _options_target !== void 0 ? _options_target : null);
  }, [
    options.target,
    setOverrideTarget
  ]);
  useIsomorphicLayoutEffect(() => {
    updatePositionManager();
  }, [
    updatePositionManager
  ]);
  if (true) {
    React123.useEffect(() => {
      if (containerRef.current) {
        var _contentNode_ownerDocument;
        const contentNode = containerRef.current;
        const treeWalker = (_contentNode_ownerDocument = contentNode.ownerDocument) === null || _contentNode_ownerDocument === void 0 ? void 0 : _contentNode_ownerDocument.createTreeWalker(contentNode, NodeFilter.SHOW_ELEMENT, {
          acceptNode: hasAutofocusFilter
        });
        while (treeWalker.nextNode()) {
          const node = treeWalker.currentNode;
          console.warn("<Popper>:", node);
          console.warn([
            '<Popper>: ^ this node contains "autoFocus" prop on a React element. This can break the initial',
            "positioning of an element and cause a window jump effect. This issue occurs because React polyfills",
            '"autoFocus" behavior to solve inconsistencies between different browsers:',
            "https://github.com/facebook/react/issues/11851#issuecomment-351787078",
            "\n",
            'However, ".focus()" in this case occurs before any other React effects will be executed',
            "(React.useEffect(), componentDidMount(), etc.) and we can not prevent this behavior. If you really",
            'want to use "autoFocus" please add "position: fixed" to styles of the element that is wrapped by',
            '"Popper".',
            `In general, it's not recommended to use "autoFocus" as it may break accessibility aspects:`,
            "https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-autofocus.md",
            "\n",
            'We suggest to use the "trapFocus" prop on Fluent components or a catch "ref" and then use',
            '"ref.current.focus" in React.useEffect():',
            "https://reactjs.org/docs/refs-and-the-dom.html#adding-a-ref-to-a-dom-element"
          ].join(" "));
        }
      }
    }, []);
  }
  const setTarget = useCallbackRef(null, (target) => {
    if (targetRef.current !== target) {
      targetRef.current = target;
      updatePositionManager();
    }
  });
  const setContainer = useCallbackRef(null, (container) => {
    if (containerRef.current !== container) {
      containerRef.current = container;
      updatePositionManager();
    }
  });
  const setArrow = useCallbackRef(null, (arrow2) => {
    if (arrowRef.current !== arrow2) {
      arrowRef.current = arrow2;
      updatePositionManager();
    }
  });
  return {
    targetRef: setTarget,
    containerRef: setContainer,
    arrowRef: setArrow
  };
}
function usePositioningOptions(options) {
  const {
    align,
    arrowPadding,
    autoSize: rawAutoSize,
    coverTarget: coverTarget2,
    flipBoundary,
    offset: offset3,
    overflowBoundary,
    pinned,
    position,
    unstable_disableTether: disableTether,
    // eslint-disable-next-line deprecation/deprecation
    positionFixed,
    strategy,
    overflowBoundaryPadding,
    fallbackPositions,
    useTransform,
    matchTargetSize: matchTargetSize2
  } = options;
  const { dir, targetDocument } = useFluent();
  const isRtl = dir === "rtl";
  const positionStrategy = (strategy !== null && strategy !== void 0 ? strategy : positionFixed) ? "fixed" : "absolute";
  const autoSize = normalizeAutoSize(rawAutoSize);
  return React123.useCallback(
    (container, arrow2) => {
      const hasScrollableElement = hasScrollParent(container);
      const middleware = [
        autoSize && resetMaxSize(autoSize),
        matchTargetSize2 && matchTargetSize(),
        offset3 && offset2(offset3),
        coverTarget2 && coverTarget(),
        !pinned && flip2({
          container,
          flipBoundary,
          hasScrollableElement,
          isRtl,
          fallbackPositions
        }),
        shift2({
          container,
          hasScrollableElement,
          overflowBoundary,
          disableTether,
          overflowBoundaryPadding,
          isRtl
        }),
        autoSize && maxSize(autoSize, {
          container,
          overflowBoundary
        }),
        intersecting(),
        arrow2 && arrow({
          element: arrow2,
          padding: arrowPadding
        }),
        hide({
          strategy: "referenceHidden"
        }),
        hide({
          strategy: "escaped"
        }),
        targetDocument && m2(targetDocument, devtoolsCallback(options))
      ].filter(Boolean);
      const placement = toFloatingUIPlacement(align, position, isRtl);
      return {
        placement,
        middleware,
        strategy: positionStrategy,
        useTransform
      };
    },
    // Options is missing here, but it's not required
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      align,
      arrowPadding,
      autoSize,
      coverTarget2,
      disableTether,
      flipBoundary,
      isRtl,
      offset3,
      overflowBoundary,
      pinned,
      position,
      positionStrategy,
      overflowBoundaryPadding,
      fallbackPositions,
      useTransform,
      matchTargetSize2,
      targetDocument
    ]
  );
}

// node_modules/@fluentui/react-positioning/lib/usePositioningMouseTarget.js
var React124 = __toESM(require_react());
var usePositioningMouseTarget = (initialState) => {
  const [virtualElement, setVirtualElement] = React124.useState(initialState);
  const setVirtualMouseTarget = (event) => {
    if (event === void 0 || event === null) {
      setVirtualElement(void 0);
      return;
    }
    let mouseevent;
    if (!(event instanceof MouseEvent)) {
      mouseevent = event.nativeEvent;
    } else {
      mouseevent = event;
    }
    if (!(mouseevent instanceof MouseEvent) && true) {
      console.error("usePositioningMouseTarget should only be used with MouseEvent");
    }
    const contextTarget = createVirtualElementFromClick(mouseevent);
    setVirtualElement(contextTarget);
  };
  return [
    virtualElement,
    setVirtualMouseTarget
  ];
};

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-popover/lib/components/PopoverSurface/PopoverSurface.js
var React132 = __toESM(require_react());

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-popover/lib/components/PopoverSurface/usePopoverSurface.js
var React125 = __toESM(require_react());

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-popover/lib/popoverContext.js
var PopoverContext = createContext20(void 0);
var popoverContextDefaultValue = {
  open: false,
  setOpen: () => null,
  toggleOpen: () => null,
  triggerRef: {
    current: null
  },
  contentRef: {
    current: null
  },
  arrowRef: {
    current: null
  },
  openOnContext: false,
  openOnHover: false,
  size: "medium",
  trapFocus: false,
  inline: false
};
var PopoverProvider = PopoverContext.Provider;
var usePopoverContext_unstable = (selector) => useContextSelector(PopoverContext, (ctx = popoverContextDefaultValue) => selector(ctx));

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-popover/lib/components/PopoverSurface/usePopoverSurface.js
var usePopoverSurface_unstable = (props, ref) => {
  const contentRef = usePopoverContext_unstable((context) => context.contentRef);
  const openOnHover = usePopoverContext_unstable((context) => context.openOnHover);
  const setOpen = usePopoverContext_unstable((context) => context.setOpen);
  const mountNode = usePopoverContext_unstable((context) => context.mountNode);
  const arrowRef = usePopoverContext_unstable((context) => context.arrowRef);
  const size2 = usePopoverContext_unstable((context) => context.size);
  const withArrow = usePopoverContext_unstable((context) => context.withArrow);
  const appearance = usePopoverContext_unstable((context) => context.appearance);
  const trapFocus = usePopoverContext_unstable((context) => context.trapFocus);
  const inertTrapFocus = usePopoverContext_unstable((context) => context.inertTrapFocus);
  const inline2 = usePopoverContext_unstable((context) => context.inline);
  const { modalAttributes } = useModalAttributes({
    trapFocus,
    legacyTrapFocus: !inertTrapFocus,
    alwaysFocusable: !trapFocus
  });
  const state = {
    inline: inline2,
    appearance,
    withArrow,
    size: size2,
    arrowRef,
    mountNode,
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `contentRef` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, contentRef),
      role: trapFocus ? "dialog" : "group",
      "aria-modal": trapFocus ? true : void 0,
      ...modalAttributes,
      ...props
    }), {
      elementType: "div"
    })
  };
  const { onMouseEnter: onMouseEnterOriginal, onMouseLeave: onMouseLeaveOriginal, onKeyDown: onKeyDownOriginal } = state.root;
  state.root.onMouseEnter = (e2) => {
    if (openOnHover) {
      setOpen(e2, true);
    }
    onMouseEnterOriginal === null || onMouseEnterOriginal === void 0 ? void 0 : onMouseEnterOriginal(e2);
  };
  state.root.onMouseLeave = (e2) => {
    if (openOnHover) {
      setOpen(e2, false);
    }
    onMouseLeaveOriginal === null || onMouseLeaveOriginal === void 0 ? void 0 : onMouseLeaveOriginal(e2);
  };
  state.root.onKeyDown = (e2) => {
    var _contentRef_current;
    if (e2.key === "Escape" && ((_contentRef_current = contentRef.current) === null || _contentRef_current === void 0 ? void 0 : _contentRef_current.contains(e2.target))) {
      e2.preventDefault();
      setOpen(e2, false);
    }
    onKeyDownOriginal === null || onKeyDownOriginal === void 0 ? void 0 : onKeyDownOriginal(e2);
  };
  return state;
};

// node_modules/@fluentui/react-portal/lib/components/Portal/Portal.js
var React130 = __toESM(require_react());

// node_modules/@fluentui/react-portal/lib/components/Portal/usePortal.js
var React128 = __toESM(require_react());

// node_modules/@fluentui/react-portal/lib/utils/toMountNodeProps.js
function toMountNodeProps(mountNode) {
  if (isHTMLElement(mountNode)) {
    return {
      element: mountNode
    };
  }
  if (typeof mountNode === "object") {
    if (mountNode === null) {
      return {
        element: null
      };
    }
    return mountNode;
  }
  return {};
}

// node_modules/@fluentui/react-portal/lib/components/Portal/usePortalMountNode.js
var React127 = __toESM(require_react());

// node_modules/use-disposable/lib/index.js
var React126 = __toESM(require_react());
var React410 = __toESM(require_react());
var React210 = __toESM(require_react());
var React310 = __toESM(require_react());
var getCurrentOwner = () => React126.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner.current;
var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
var useIsStrictMode = () => {
  if (false) {
    return false;
  }
  const isStrictMode = React126.useRef(void 0);
  const reactMajorVersion = React126.useMemo(() => {
    return Number(React126.version.split(".")[0]);
  }, [React126.version]);
  if (isNaN(reactMajorVersion) || reactMajorVersion < 18) {
    return false;
  }
  if (isStrictMode.current === void 0) {
    let currentOwner = getCurrentOwner();
    while (currentOwner && currentOwner.return) {
      currentOwner = currentOwner.return;
      if (currentOwner.type === REACT_STRICT_MODE_TYPE || currentOwner.elementType === REACT_STRICT_MODE_TYPE) {
        isStrictMode.current = true;
      }
    }
  }
  return !!isStrictMode.current;
};
var effectSet = /* @__PURE__ */ new WeakSet();
function useStrictEffect(effect, deps) {
  const currentOwner = getCurrentOwner();
  React210.useEffect(() => {
    if (!effectSet.has(currentOwner)) {
      effectSet.add(currentOwner);
      effect();
      return;
    }
    const dispose = effect();
    return dispose;
  }, deps);
}
var memoSet = /* @__PURE__ */ new WeakSet();
function useStrictMemo(factory, deps) {
  return React310.useMemo(() => {
    const currentOwner = getCurrentOwner();
    if (!memoSet.has(currentOwner)) {
      memoSet.add(currentOwner);
      return null;
    }
    return factory();
  }, deps);
}
function useDisposable(factory, deps) {
  var _a;
  const isStrictMode = useIsStrictMode() && true;
  const useMemo42 = isStrictMode ? useStrictMemo : React410.useMemo;
  const useEffect32 = isStrictMode ? useStrictEffect : React410.useEffect;
  const [disposable, dispose] = (_a = useMemo42(() => factory(), deps)) != null ? _a : [
    null,
    () => null
  ];
  useEffect32(() => {
    return dispose;
  }, deps);
  return disposable;
}

// node_modules/@fluentui/react-portal/lib/components/Portal/usePortalMountNodeStyles.styles.js
var usePortalMountNodeStylesStyles = __styles({
  root: {
    qhf8xq: "f1euv43f",
    Bhzewxz: "f15twtuk",
    oyh7mz: ["f1vgc2s3", "f1e31b4d"],
    j35jbq: ["f1e31b4d", "f1vgc2s3"],
    Bj3rh1h: "f494woh"
  }
}, {
  d: [".f1euv43f{position:absolute;}", ".f15twtuk{top:0;}", ".f1vgc2s3{left:0;}", ".f1e31b4d{right:0;}", ".f494woh{z-index:1000000;}"]
});

// node_modules/@fluentui/react-portal/lib/components/Portal/usePortalMountNode.js
var useInsertionEffect2 = React127["useInsertionEffect"];
var usePortalMountNode2 = (options) => {
  const { targetDocument, dir } = useFluent();
  const mountNode = usePortalMountNode();
  const focusVisibleRef = useFocusVisible();
  const classes = usePortalMountNodeStylesStyles();
  const themeClassName = useThemeClassName();
  const className = mergeClasses(themeClassName, classes.root, options.className);
  const targetNode = mountNode !== null && mountNode !== void 0 ? mountNode : targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.body;
  const element = useDisposable(() => {
    if (targetNode === void 0 || options.disabled) {
      return [
        null,
        () => null
      ];
    }
    const newElement = targetNode.ownerDocument.createElement("div");
    targetNode.appendChild(newElement);
    return [
      newElement,
      () => newElement.remove()
    ];
  }, [
    targetNode
  ]);
  if (useInsertionEffect2) {
    useInsertionEffect2(() => {
      if (!element) {
        return;
      }
      const classesToApply = className.split(" ").filter(Boolean);
      element.classList.add(...classesToApply);
      element.setAttribute("dir", dir);
      focusVisibleRef.current = element;
      return () => {
        element.classList.remove(...classesToApply);
        element.removeAttribute("dir");
      };
    }, [
      className,
      dir,
      element,
      focusVisibleRef
    ]);
  } else {
    React127.useMemo(() => {
      if (!element) {
        return;
      }
      element.className = className;
      element.setAttribute("dir", dir);
      focusVisibleRef.current = element;
    }, [
      className,
      dir,
      element,
      focusVisibleRef
    ]);
  }
  return element;
};

// node_modules/@fluentui/react-portal/lib/components/Portal/usePortal.js
var usePortal_unstable = (props) => {
  const { element, className } = toMountNodeProps(props.mountNode);
  const virtualParentRootRef = React128.useRef(null);
  const fallbackElement = usePortalMountNode2({
    disabled: !!element,
    className
  });
  const state = {
    children: props.children,
    mountNode: element !== null && element !== void 0 ? element : fallbackElement,
    virtualParentRootRef
  };
  React128.useEffect(() => {
    if (state.virtualParentRootRef.current && state.mountNode) {
      setVirtualParent(state.mountNode, state.virtualParentRootRef.current);
    }
    return () => {
      if (state.mountNode) {
        setVirtualParent(state.mountNode, void 0);
      }
    };
  }, [
    state.virtualParentRootRef,
    state.mountNode
  ]);
  return state;
};

// node_modules/@fluentui/react-portal/lib/components/Portal/renderPortal.js
var ReactDOM = __toESM(require_react_dom());
var React129 = __toESM(require_react());
var renderPortal_unstable = (state) => {
  return React129.createElement("span", {
    hidden: true,
    ref: state.virtualParentRootRef
  }, state.mountNode && ReactDOM.createPortal(state.children, state.mountNode));
};

// node_modules/@fluentui/react-portal/lib/components/Portal/Portal.js
var Portal = (props) => {
  const state = usePortal_unstable(props);
  return renderPortal_unstable(state);
};
Portal.displayName = "Portal";

// node_modules/@fluentui/react-portal/lib/components/Portal/Portal.types.js
var React131 = __toESM(require_react());

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-popover/lib/components/PopoverSurface/renderPopoverSurface.js
var renderPopoverSurface_unstable = (state) => {
  assertSlots(state);
  const surface = jsxs(state.root, {
    children: [
      state.withArrow && jsx("div", {
        ref: state.arrowRef,
        className: state.arrowClassName
      }),
      state.root.children
    ]
  });
  if (state.inline) {
    return surface;
  }
  return jsx(Portal, {
    mountNode: state.mountNode,
    children: surface
  });
};

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-popover/lib/components/PopoverSurface/usePopoverSurfaceStyles.styles.js
var popoverSurfaceClassNames = {
  root: "fui-PopoverSurface"
};
var arrowHeights = {
  small: 6,
  medium: 8,
  large: 8
};
var useStyles14 = __styles({
  root: {
    sj55zd: "f19n0e5",
    De3pzq: "fxugw4r",
    E5pizo: "f1hg901r",
    Bbmb7ep: ["f1aa9q02", "f16jpd5f"],
    Beyfa6y: ["f16jpd5f", "f1aa9q02"],
    B7oj6ja: ["f1jar5jt", "fyu767a"],
    Btl43ni: ["fyu767a", "f1jar5jt"],
    B4j52fo: "f5ogflp",
    Bekrc4i: ["f1hqa2wf", "finvdd3"],
    Bn0qgzm: "f1f09k3d",
    ibv6hh: ["finvdd3", "f1hqa2wf"],
    icvyot: "fzkkow9",
    vrafjx: ["fcdblym", "fjik90z"],
    oivjwe: "fg706s2",
    wvpqe5: ["fjik90z", "fcdblym"],
    g2u3we: "fghlq4f",
    h3c5rm: ["f1gn591s", "fjscplz"],
    B9xav0g: "fb073pr",
    zhjwy3: ["fjscplz", "f1gn591s"],
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi",
    B93otf3: "f18k4bn6",
    vin17d: "fo1kyvf",
    Ezkn3b: "fetxo7e",
    ex8oj8: "fmm77a6",
    Bksk4gw: "f12t24nk",
    Bc5phfd: "f1babd7",
    cbiifc: "f1jgo889",
    fyiq5g: "f1ij1pew",
    Bqc19t1: "f1gu8pa9",
    Eet2gb: "fhfnl4n",
    Bhl7k63: "fk8tkmz",
    Bv12yb3: "f3n0535",
    z0t1cu: "fi19xcv",
    Bks05zx: "f1mzajhk",
    Bvtglag: "fjp4h9y"
  },
  inline: {
    Bj3rh1h: "f19g0ac"
  },
  inverted: {
    De3pzq: "fg3r6xk",
    sj55zd: "fonrgv7"
  },
  brand: {
    De3pzq: "ffp7eso",
    sj55zd: "f1phragk"
  },
  smallPadding: {
    z8tnut: "f1kcqot9",
    z189sj: ["f11qrl6u", "fjlbh76"],
    Byoj8tv: "fpe6lb7",
    uwmqm3: ["fjlbh76", "f11qrl6u"]
  },
  mediumPadding: {
    z8tnut: "fqag9an",
    z189sj: ["f1gbmcue", "f1rh9g5y"],
    Byoj8tv: "fp67ikv",
    uwmqm3: ["f1rh9g5y", "f1gbmcue"]
  },
  largePadding: {
    z8tnut: "fc7z3ec",
    z189sj: ["fat0sn4", "fekwl8i"],
    Byoj8tv: "fe2my4m",
    uwmqm3: ["fekwl8i", "fat0sn4"]
  },
  smallArrow: {
    a9b677: "f1ekdpwm",
    Bqenvij: "f83vc9z"
  },
  mediumLargeArrow: {
    a9b677: "f1kmc0fn",
    Bqenvij: "fb6lvc5"
  },
  arrow: {
    qhf8xq: "f1euv43f",
    De3pzq: "f1u2r49w",
    Bcdw1i0: "fd7fpy0",
    Bj3rh1h: "f1bsuimh",
    Ftih45: "f1wl9k8s",
    B1puzpu: "f1wkw4r9",
    Brfgrao: "f1j7ml58",
    Bcvre1j: "fyl8oag",
    Ccq8qp: "frdoeuz",
    Baz25je: "fb81m9q",
    cmx5o7: "f1ljr5q2",
    B4f6apu: "fyfemzf",
    m598lv: "focyt6c",
    Bk5zm6e: "fnhxbxj",
    y0oebl: "fdw6hkg",
    qa3bma: "f11yjt3y",
    Bqjgrrk: "f1172wan",
    Budzafs: ["f9e5op9", "f112wvtl"],
    Hv9wc6: ["ftj5xct", "fyavhwi"],
    hl6cv3: "f1773hnp",
    Bh2vraf: "f1n8855c",
    yayu3t: "f1v7783n",
    wedwtw: "fsw6im5",
    rhl9o9: "fh2hsk5",
    Bu8t5uz: "f159pzir",
    B6q6orb: "f11yvu4",
    Bwwlvwl: "fm1ycve"
  }
}, {
  d: [".f19n0e5{color:var(--colorNeutralForeground1);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f1hg901r{box-shadow:var(--shadow16);}", ".f1aa9q02{border-bottom-right-radius:var(--borderRadiusMedium);}", ".f16jpd5f{border-bottom-left-radius:var(--borderRadiusMedium);}", ".f1jar5jt{border-top-right-radius:var(--borderRadiusMedium);}", ".fyu767a{border-top-left-radius:var(--borderRadiusMedium);}", ".f5ogflp{border-top-width:1px;}", ".f1hqa2wf{border-right-width:1px;}", ".finvdd3{border-left-width:1px;}", ".f1f09k3d{border-bottom-width:1px;}", ".fzkkow9{border-top-style:solid;}", ".fcdblym{border-right-style:solid;}", ".fjik90z{border-left-style:solid;}", ".fg706s2{border-bottom-style:solid;}", ".fghlq4f{border-top-color:var(--colorTransparentStroke);}", ".f1gn591s{border-right-color:var(--colorTransparentStroke);}", ".fjscplz{border-left-color:var(--colorTransparentStroke);}", ".fb073pr{border-bottom-color:var(--colorTransparentStroke);}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".f18k4bn6{animation-composition:accumulate;}", ".fo1kyvf{animation-duration:var(--durationSlower);}", ".fetxo7e{animation-timing-function:var(--curveDecelerateMid);}", ".fmm77a6{--slide-distance-x:0px;}", ".f12t24nk{--slide-distance-y:10px;}", ".f1babd7[data-popper-placement^=right]{--slide-distance-x:-10px;}", ".f1jgo889[data-popper-placement^=right]{--slide-distance-y:0px;}", ".f1ij1pew[data-popper-placement^=bottom]{--slide-distance-x:0px;}", ".f1gu8pa9[data-popper-placement^=bottom]{--slide-distance-y:-10px;}", ".fhfnl4n[data-popper-placement^=left]{--slide-distance-x:10px;}", ".fk8tkmz[data-popper-placement^=left]{--slide-distance-y:0px;}", ".f3n0535{animation-name:f5j8bii,fld5wjx;}", ".f19g0ac{z-index:1;}", ".fg3r6xk{background-color:var(--colorNeutralBackgroundStatic);}", ".fonrgv7{color:var(--colorNeutralForegroundStaticInverted);}", ".ffp7eso{background-color:var(--colorBrandBackground);}", ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".f1kcqot9{padding-top:12px;}", ".f11qrl6u{padding-right:12px;}", ".fjlbh76{padding-left:12px;}", ".fpe6lb7{padding-bottom:12px;}", ".fqag9an{padding-top:16px;}", ".f1gbmcue{padding-right:16px;}", ".f1rh9g5y{padding-left:16px;}", ".fp67ikv{padding-bottom:16px;}", ".fc7z3ec{padding-top:20px;}", ".fat0sn4{padding-right:20px;}", ".fekwl8i{padding-left:20px;}", ".fe2my4m{padding-bottom:20px;}", ".f1ekdpwm{width:8.484px;}", ".f83vc9z{height:8.484px;}", ".f1kmc0fn{width:11.312px;}", ".fb6lvc5{height:11.312px;}", ".f1euv43f{position:absolute;}", ".f1u2r49w{background-color:inherit;}", ".fd7fpy0{visibility:hidden;}", ".f1bsuimh{z-index:-1;}", '.f1wl9k8s::before{content:"";}', ".f1wkw4r9::before{visibility:visible;}", ".f1j7ml58::before{position:absolute;}", ".fyl8oag::before{box-sizing:border-box;}", ".frdoeuz::before{width:inherit;}", ".fb81m9q::before{height:inherit;}", ".f1ljr5q2::before{background-color:inherit;}", ".fyfemzf::before{border-right-width:1px;}", ".focyt6c::before{border-right-style:solid;}", ".fnhxbxj::before{border-right-color:var(--colorTransparentStroke);}", ".fdw6hkg::before{border-bottom-width:1px;}", ".f11yjt3y::before{border-bottom-style:solid;}", ".f1172wan::before{border-bottom-color:var(--colorTransparentStroke);}", ".f9e5op9::before{border-bottom-right-radius:var(--borderRadiusSmall);}", ".f112wvtl::before{border-bottom-left-radius:var(--borderRadiusSmall);}", ".ftj5xct::before{transform:rotate(var(--angle)) translate(0, 50%) rotate(45deg);}", ".fyavhwi::before{transform:rotate(var(--angle)) translate(0, 50%) rotate(-45deg);}", '[data-popper-placement^="top"] .f1773hnp{bottom:-1px;}', '[data-popper-placement^="top"] .f1n8855c{--angle:0;}', '[data-popper-placement^="right"] .f1v7783n{left:-1px;}', '[data-popper-placement^="right"] .fsw6im5{--angle:90deg;}', '[data-popper-placement^="bottom"] .fh2hsk5{top:-1px;}', '[data-popper-placement^="bottom"] .f159pzir{--angle:180deg;}', '[data-popper-placement^="left"] .f11yvu4{right:-1px;}', '[data-popper-placement^="left"] .fm1ycve{--angle:270deg;}'],
  k: ["@keyframes f5j8bii{from{opacity:0;}to{opacity:1;}}", "@keyframes fld5wjx{from{transform:translate(var(--slide-distance-x), var(--slide-distance-y));}}"],
  m: [["@media (prefers-reduced-motion){.fi19xcv[data-popper-placement]{animation-duration:1ms;}}", {
    m: "(prefers-reduced-motion)"
  }], ["@media (prefers-reduced-motion){.f1mzajhk[data-popper-placement]{animation-name:f5j8bii;}}", {
    m: "(prefers-reduced-motion)"
  }]],
  t: ["@supports not (animation-composition: accumulate){.fjp4h9y[data-popper-placement]{animation-name:f5j8bii;}}"]
});
var usePopoverSurfaceStyles_unstable = (state) => {
  const styles = useStyles14();
  state.root.className = mergeClasses(popoverSurfaceClassNames.root, styles.root, state.inline && styles.inline, state.size === "small" && styles.smallPadding, state.size === "medium" && styles.mediumPadding, state.size === "large" && styles.largePadding, state.appearance === "inverted" && styles.inverted, state.appearance === "brand" && styles.brand, state.root.className);
  state.arrowClassName = mergeClasses(styles.arrow, state.size === "small" ? styles.smallArrow : styles.mediumLargeArrow);
  return state;
};

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-popover/lib/components/PopoverSurface/PopoverSurface.js
var PopoverSurface = React132.forwardRef((props, ref) => {
  const state = usePopoverSurface_unstable(props, ref);
  usePopoverSurfaceStyles_unstable(state);
  useCustomStyleHook("usePopoverSurfaceStyles_unstable")(state);
  return renderPopoverSurface_unstable(state);
});
PopoverSurface.displayName = "PopoverSurface";

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-popover/lib/components/Popover/constants.js
var popoverSurfaceBorderRadius = 4;

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-popover/lib/components/Popover/usePopover.js
var usePopover_unstable = (props) => {
  const [contextTarget, setContextTarget] = usePositioningMouseTarget();
  const initialState = {
    size: "medium",
    contextTarget,
    setContextTarget,
    ...props
  };
  const children = React133.Children.toArray(props.children);
  if (true) {
    if (children.length === 0) {
      console.warn("Popover must contain at least one child");
    }
    if (children.length > 2) {
      console.warn("Popover must contain at most two children");
    }
  }
  let popoverTrigger = void 0;
  let popoverSurface = void 0;
  if (children.length === 2) {
    popoverTrigger = children[0];
    popoverSurface = children[1];
  } else if (children.length === 1) {
    popoverSurface = children[0];
  }
  const [open, setOpenState] = useOpenState(initialState);
  const setOpenTimeoutRef = React133.useRef(0);
  const setOpen = useEventCallback((e2, shouldOpen) => {
    clearTimeout(setOpenTimeoutRef.current);
    if (!(e2 instanceof Event) && e2.persist) {
      e2.persist();
    }
    if (e2.type === "mouseleave") {
      var _props_mouseLeaveDelay;
      setOpenTimeoutRef.current = setTimeout(() => {
        setOpenState(e2, shouldOpen);
      }, (_props_mouseLeaveDelay = props.mouseLeaveDelay) !== null && _props_mouseLeaveDelay !== void 0 ? _props_mouseLeaveDelay : 500);
    } else {
      setOpenState(e2, shouldOpen);
    }
  });
  React133.useEffect(() => {
    return () => {
      clearTimeout(setOpenTimeoutRef.current);
    };
  }, []);
  const toggleOpen = React133.useCallback((e2) => {
    setOpen(e2, !open);
  }, [
    setOpen,
    open
  ]);
  const positioningRefs = usePopoverRefs(initialState);
  const { targetDocument } = useFluent();
  var _props_closeOnIframeFocus;
  useOnClickOutside({
    contains: elementContains,
    element: targetDocument,
    callback: (ev) => setOpen(ev, false),
    refs: [
      positioningRefs.triggerRef,
      positioningRefs.contentRef
    ],
    disabled: !open,
    disabledFocusOnIframe: !((_props_closeOnIframeFocus = props.closeOnIframeFocus) !== null && _props_closeOnIframeFocus !== void 0 ? _props_closeOnIframeFocus : true)
  });
  const closeOnScroll = initialState.openOnContext || initialState.closeOnScroll;
  useOnScrollOutside({
    contains: elementContains,
    element: targetDocument,
    callback: (ev) => setOpen(ev, false),
    refs: [
      positioningRefs.triggerRef,
      positioningRefs.contentRef
    ],
    disabled: !open || !closeOnScroll
  });
  const { findFirstFocusable } = useFocusFinders();
  React133.useEffect(() => {
    if (props.unstable_disableAutoFocus) {
      return;
    }
    if (open && positioningRefs.contentRef.current) {
      var _positioningRefs_contentRef_current_getAttribute;
      const containerTabIndex = (_positioningRefs_contentRef_current_getAttribute = positioningRefs.contentRef.current.getAttribute("tabIndex")) !== null && _positioningRefs_contentRef_current_getAttribute !== void 0 ? _positioningRefs_contentRef_current_getAttribute : void 0;
      const firstFocusable = isNaN(containerTabIndex) ? findFirstFocusable(positioningRefs.contentRef.current) : positioningRefs.contentRef.current;
      firstFocusable === null || firstFocusable === void 0 ? void 0 : firstFocusable.focus();
    }
  }, [
    findFirstFocusable,
    open,
    positioningRefs.contentRef,
    props.unstable_disableAutoFocus
  ]);
  var _props_inertTrapFocus, _props_inline;
  return {
    ...initialState,
    ...positioningRefs,
    // eslint-disable-next-line deprecation/deprecation
    inertTrapFocus: (_props_inertTrapFocus = props.inertTrapFocus) !== null && _props_inertTrapFocus !== void 0 ? _props_inertTrapFocus : props.legacyTrapFocus === void 0 ? false : !props.legacyTrapFocus,
    popoverTrigger,
    popoverSurface,
    open,
    setOpen,
    toggleOpen,
    setContextTarget,
    contextTarget,
    inline: (_props_inline = props.inline) !== null && _props_inline !== void 0 ? _props_inline : false
  };
};
function useOpenState(state) {
  const onOpenChange = useEventCallback((e2, data) => {
    var _state_onOpenChange;
    return (_state_onOpenChange = state.onOpenChange) === null || _state_onOpenChange === void 0 ? void 0 : _state_onOpenChange.call(state, e2, data);
  });
  const [open, setOpenState] = useControllableState({
    state: state.open,
    defaultState: state.defaultOpen,
    initialState: false
  });
  state.open = open !== void 0 ? open : state.open;
  const setContextTarget = state.setContextTarget;
  const setOpen = React133.useCallback((e2, shouldOpen) => {
    if (shouldOpen && e2.type === "contextmenu") {
      setContextTarget(e2);
    }
    if (!shouldOpen) {
      setContextTarget(void 0);
    }
    setOpenState(shouldOpen);
    onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(e2, {
      open: shouldOpen
    });
  }, [
    setOpenState,
    onOpenChange,
    setContextTarget
  ]);
  return [
    open,
    setOpen
  ];
}
function usePopoverRefs(state) {
  const positioningOptions = {
    position: "above",
    align: "center",
    arrowPadding: 2 * popoverSurfaceBorderRadius,
    target: state.openOnContext ? state.contextTarget : void 0,
    ...resolvePositioningShorthand(state.positioning)
  };
  if (positioningOptions.coverTarget) {
    state.withArrow = false;
  }
  if (state.withArrow) {
    positioningOptions.offset = mergeArrowOffset(positioningOptions.offset, arrowHeights[state.size]);
  }
  const { targetRef: triggerRef, containerRef: contentRef, arrowRef } = usePositioning(positioningOptions);
  return {
    triggerRef,
    contentRef,
    arrowRef
  };
}

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-popover/lib/components/Popover/renderPopover.js
var React134 = __toESM(require_react());
var renderPopover_unstable = (state) => {
  const { appearance, arrowRef, contentRef, inline: inline2, mountNode, open, openOnContext, openOnHover, setOpen, size: size2, toggleOpen, trapFocus, triggerRef, withArrow, inertTrapFocus } = state;
  return React134.createElement(PopoverContext.Provider, {
    value: {
      appearance,
      arrowRef,
      contentRef,
      inline: inline2,
      mountNode,
      open,
      openOnContext,
      openOnHover,
      setOpen,
      toggleOpen,
      triggerRef,
      size: size2,
      trapFocus,
      inertTrapFocus,
      withArrow
    }
  }, state.popoverTrigger, state.open && state.popoverSurface);
};

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-popover/lib/components/Popover/Popover.js
var Popover = (props) => {
  const state = usePopover_unstable(props);
  return renderPopover_unstable(state);
};
Popover.displayName = "Popover";

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-popover/lib/components/Popover/Popover.types.js
var React136 = __toESM(require_react());

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-popover/lib/components/PopoverTrigger/PopoverTrigger.js
var React138 = __toESM(require_react());

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-popover/lib/components/PopoverTrigger/usePopoverTrigger.js
var React137 = __toESM(require_react());
var usePopoverTrigger_unstable = (props) => {
  const { children, disableButtonEnhancement = false } = props;
  const child = getTriggerChild(children);
  const open = usePopoverContext_unstable((context) => context.open);
  const setOpen = usePopoverContext_unstable((context) => context.setOpen);
  const toggleOpen = usePopoverContext_unstable((context) => context.toggleOpen);
  const triggerRef = usePopoverContext_unstable((context) => context.triggerRef);
  const openOnHover = usePopoverContext_unstable((context) => context.openOnHover);
  const openOnContext = usePopoverContext_unstable((context) => context.openOnContext);
  const { triggerAttributes } = useModalAttributes();
  const onContextMenu = (e2) => {
    if (openOnContext) {
      e2.preventDefault();
      setOpen(e2, true);
    }
  };
  const onClick = (e2) => {
    if (!openOnContext) {
      toggleOpen(e2);
    }
  };
  const onKeyDown = (e2) => {
    if (e2.key === Escape2 && open && !e2.isDefaultPrevented()) {
      setOpen(e2, false);
      e2.preventDefault();
    }
  };
  const onMouseEnter = (e2) => {
    if (openOnHover) {
      setOpen(e2, true);
    }
  };
  const onMouseLeave = (e2) => {
    if (openOnHover) {
      setOpen(e2, false);
    }
  };
  const contextMenuProps = {
    ...triggerAttributes,
    "aria-expanded": `${open}`,
    ...child === null || child === void 0 ? void 0 : child.props,
    onMouseEnter: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseEnter, onMouseEnter)),
    onMouseLeave: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseLeave, onMouseLeave)),
    onContextMenu: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onContextMenu, onContextMenu)),
    ref: useMergedRefs(triggerRef, child === null || child === void 0 ? void 0 : child.ref)
  };
  const triggerChildProps = {
    ...contextMenuProps,
    onClick: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onClick, onClick)),
    onKeyDown: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onKeyDown, onKeyDown))
  };
  const ariaButtonTriggerChildProps = useARIAButtonProps((child === null || child === void 0 ? void 0 : child.type) === "button" || (child === null || child === void 0 ? void 0 : child.type) === "a" ? child.type : "div", triggerChildProps);
  return {
    children: applyTriggerPropsToChildren(props.children, useARIAButtonProps((child === null || child === void 0 ? void 0 : child.type) === "button" || (child === null || child === void 0 ? void 0 : child.type) === "a" ? child.type : "div", openOnContext ? contextMenuProps : disableButtonEnhancement ? triggerChildProps : ariaButtonTriggerChildProps))
  };
};

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-popover/lib/components/PopoverTrigger/renderPopoverTrigger.js
var renderPopoverTrigger_unstable = (state) => {
  return state.children;
};

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-popover/lib/components/PopoverTrigger/PopoverTrigger.js
var PopoverTrigger = (props) => {
  const state = usePopoverTrigger_unstable(props);
  return renderPopoverTrigger_unstable(state);
};
PopoverTrigger.displayName = "PopoverTrigger";
PopoverTrigger.isFluentTriggerComponent = true;

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-popover/lib/components/PopoverTrigger/PopoverTrigger.types.js
var React139 = __toESM(require_react());

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-avatar/lib/components/AvatarGroupPopover/renderAvatarGroupPopover.js
var renderAvatarGroupPopover_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      jsx(PopoverTrigger, {
        disableButtonEnhancement: true,
        children: jsx(state.tooltip, {
          children: jsx(state.triggerButton, {})
        })
      }),
      jsx(state.popoverSurface, {
        children: jsx(AvatarGroupProvider, {
          value: contextValues.avatarGroup,
          children: jsx(state.content, {})
        })
      })
    ]
  });
};

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-avatar/lib/components/AvatarGroupPopover/useAvatarGroupPopoverContextValues.js
var useAvatarGroupPopoverContextValues = (state) => {
  const avatarGroup = {
    isOverflow: true,
    size: 24
  };
  return {
    avatarGroup
  };
};

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-avatar/lib/components/AvatarGroupPopover/useAvatarGroupPopover.js
var React143 = __toESM(require_react());

// node_modules/@fluentui/react-tooltip/lib/components/Tooltip/Tooltip.js
var React141 = __toESM(require_react());

// node_modules/@fluentui/react-tooltip/lib/components/Tooltip/useTooltip.js
var React140 = __toESM(require_react());

// node_modules/@fluentui/react-tooltip/lib/components/Tooltip/private/constants.js
var arrowHeight = 6;
var tooltipBorderRadius = 4;

// node_modules/@fluentui/react-tooltip/lib/components/Tooltip/useTooltip.js
var useTooltip_unstable = (props) => {
  var _child_props, _child_props1, _child_props2, _child_props3;
  const context = useTooltipVisibility();
  const isServerSideRender = useIsSSR();
  const { targetDocument } = useFluent();
  const [setDelayTimeout, clearDelayTimeout] = useTimeout();
  const { appearance = "normal", children, content, withArrow = false, positioning = "above", onVisibleChange, relationship, showDelay = 250, hideDelay = 250, mountNode } = props;
  const [visible, setVisibleInternal] = useControllableState({
    state: props.visible,
    initialState: false
  });
  const setVisible = React140.useCallback((ev, data) => {
    clearDelayTimeout();
    setVisibleInternal((oldVisible) => {
      if (data.visible !== oldVisible) {
        onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(ev, data);
      }
      return data.visible;
    });
  }, [
    clearDelayTimeout,
    setVisibleInternal,
    onVisibleChange
  ]);
  const state = {
    withArrow,
    positioning,
    showDelay,
    hideDelay,
    relationship,
    visible,
    shouldRenderTooltip: visible,
    appearance,
    mountNode,
    // Slots
    components: {
      content: "div"
    },
    content: slot_exports.always(content, {
      defaultProps: {
        role: "tooltip"
      },
      elementType: "div"
    })
  };
  state.content.id = useId2("tooltip-", state.content.id);
  const positioningOptions = {
    enabled: state.visible,
    arrowPadding: 2 * tooltipBorderRadius,
    position: "above",
    align: "center",
    offset: 4,
    ...resolvePositioningShorthand(state.positioning)
  };
  if (state.withArrow) {
    positioningOptions.offset = mergeArrowOffset(positioningOptions.offset, arrowHeight);
  }
  const { targetRef, containerRef, arrowRef } = usePositioning(positioningOptions);
  state.content.ref = useMergedRefs(state.content.ref, containerRef);
  state.arrowRef = arrowRef;
  useIsomorphicLayoutEffect(() => {
    if (visible) {
      var _context_visibleTooltip;
      const thisTooltip = {
        hide: (ev) => setVisible(void 0, {
          visible: false,
          documentKeyboardEvent: ev
        })
      };
      (_context_visibleTooltip = context.visibleTooltip) === null || _context_visibleTooltip === void 0 ? void 0 : _context_visibleTooltip.hide();
      context.visibleTooltip = thisTooltip;
      const onDocumentKeyDown = (ev) => {
        if (ev.key === Escape2 && !ev.defaultPrevented) {
          thisTooltip.hide(ev);
          ev.preventDefault();
        }
      };
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener("keydown", onDocumentKeyDown, {
        // As this event is added at targeted document,
        // we need to capture the event to be sure keydown handling from tooltip happens first
        capture: true
      });
      return () => {
        if (context.visibleTooltip === thisTooltip) {
          context.visibleTooltip = void 0;
        }
        targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener("keydown", onDocumentKeyDown, {
          capture: true
        });
      };
    }
  }, [
    context,
    targetDocument,
    visible,
    setVisible
  ]);
  const ignoreNextFocusEventRef = React140.useRef(false);
  const onEnterTrigger = React140.useCallback((ev) => {
    if (ev.type === "focus" && ignoreNextFocusEventRef.current) {
      ignoreNextFocusEventRef.current = false;
      return;
    }
    const delay = context.visibleTooltip ? 0 : state.showDelay;
    setDelayTimeout(() => {
      setVisible(ev, {
        visible: true
      });
    }, delay);
    ev.persist();
  }, [
    setDelayTimeout,
    setVisible,
    state.showDelay,
    context
  ]);
  const [keyborgListenerCallbackRef] = React140.useState(() => {
    const onKeyborgFocusIn = (ev) => {
      var _ev_details;
      if ((_ev_details = ev.details) === null || _ev_details === void 0 ? void 0 : _ev_details.isFocusedProgrammatically) {
        ignoreNextFocusEventRef.current = true;
      }
    };
    let current = null;
    return (element) => {
      current === null || current === void 0 ? void 0 : current.removeEventListener(KEYBORG_FOCUSIN, onKeyborgFocusIn);
      element === null || element === void 0 ? void 0 : element.addEventListener(KEYBORG_FOCUSIN, onKeyborgFocusIn);
      current = element;
    };
  });
  const onLeaveTrigger = React140.useCallback((ev) => {
    let delay = state.hideDelay;
    if (ev.type === "blur") {
      delay = 0;
      ignoreNextFocusEventRef.current = (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement) === ev.target;
    }
    setDelayTimeout(() => {
      setVisible(ev, {
        visible: false
      });
    }, delay);
    ev.persist();
  }, [
    setDelayTimeout,
    setVisible,
    state.hideDelay,
    targetDocument
  ]);
  state.content.onPointerEnter = mergeCallbacks(state.content.onPointerEnter, clearDelayTimeout);
  state.content.onPointerLeave = mergeCallbacks(state.content.onPointerLeave, onLeaveTrigger);
  state.content.onFocus = mergeCallbacks(state.content.onFocus, clearDelayTimeout);
  state.content.onBlur = mergeCallbacks(state.content.onBlur, onLeaveTrigger);
  const child = getTriggerChild(children);
  const triggerAriaProps = {};
  if (relationship === "label") {
    if (typeof state.content.children === "string") {
      triggerAriaProps["aria-label"] = state.content.children;
    } else {
      triggerAriaProps["aria-labelledby"] = state.content.id;
      state.shouldRenderTooltip = true;
    }
  } else if (relationship === "description") {
    triggerAriaProps["aria-describedby"] = state.content.id;
    state.shouldRenderTooltip = true;
  }
  if (isServerSideRender) {
    state.shouldRenderTooltip = false;
  }
  state.children = applyTriggerPropsToChildren(children, {
    ...triggerAriaProps,
    ...child === null || child === void 0 ? void 0 : child.props,
    ref: useMergedRefs(
      child === null || child === void 0 ? void 0 : child.ref,
      keyborgListenerCallbackRef,
      // If the target prop is not provided, attach targetRef to the trigger element's ref prop
      positioningOptions.target === void 0 ? targetRef : void 0
    ),
    onPointerEnter: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : (_child_props = child.props) === null || _child_props === void 0 ? void 0 : _child_props.onPointerEnter, onEnterTrigger)),
    onPointerLeave: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : (_child_props1 = child.props) === null || _child_props1 === void 0 ? void 0 : _child_props1.onPointerLeave, onLeaveTrigger)),
    onFocus: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : (_child_props2 = child.props) === null || _child_props2 === void 0 ? void 0 : _child_props2.onFocus, onEnterTrigger)),
    onBlur: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : (_child_props3 = child.props) === null || _child_props3 === void 0 ? void 0 : _child_props3.onBlur, onLeaveTrigger))
  });
  return state;
};

// node_modules/@fluentui/react-tooltip/lib/components/Tooltip/renderTooltip.js
var renderTooltip_unstable = (state) => {
  assertSlots(state);
  return jsxs(import_react3.Fragment, {
    children: [
      state.children,
      state.shouldRenderTooltip && jsx(Portal, {
        mountNode: state.mountNode,
        children: jsxs(state.content, {
          children: [
            state.withArrow && jsx("div", {
              ref: state.arrowRef,
              className: state.arrowClassName
            }),
            state.content.children
          ]
        })
      })
    ]
  });
};

// node_modules/@fluentui/react-tooltip/lib/components/Tooltip/useTooltipStyles.styles.js
var tooltipClassNames = {
  content: "fui-Tooltip__content"
};
var useStyles15 = __styles({
  root: {
    mc9l5x: "fjseox",
    B7ck84d: "f1ewtqcl",
    B2u0y6b: "f132xexn",
    Bceei9c: "f158kwzp",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bg96gwp: "fwrc4pm",
    Btd35i7: "fokg9q4",
    Bbmb7ep: ["f1aa9q02", "f16jpd5f"],
    Beyfa6y: ["f16jpd5f", "f1aa9q02"],
    B7oj6ja: ["f1jar5jt", "fyu767a"],
    Btl43ni: ["fyu767a", "f1jar5jt"],
    B4j52fo: "f5ogflp",
    Bekrc4i: ["f1hqa2wf", "finvdd3"],
    Bn0qgzm: "f1f09k3d",
    ibv6hh: ["finvdd3", "f1hqa2wf"],
    icvyot: "fzkkow9",
    vrafjx: ["fcdblym", "fjik90z"],
    oivjwe: "fg706s2",
    wvpqe5: ["fjik90z", "fcdblym"],
    g2u3we: "fghlq4f",
    h3c5rm: ["f1gn591s", "fjscplz"],
    B9xav0g: "fb073pr",
    zhjwy3: ["fjscplz", "f1gn591s"],
    z8tnut: "f10ra9hq",
    z189sj: ["fd9xhir", "f1jlaasf"],
    Byoj8tv: "f1d7kygh",
    uwmqm3: ["f1jlaasf", "fd9xhir"],
    De3pzq: "fxugw4r",
    sj55zd: "f19n0e5",
    Bhu2qc9: "fxeb0a7"
  },
  visible: {
    mc9l5x: "ftgm304"
  },
  inverted: {
    De3pzq: "fg3r6xk",
    sj55zd: "fonrgv7"
  },
  arrow: {
    qhf8xq: "f1euv43f",
    De3pzq: "f1u2r49w",
    Bcdw1i0: "fd7fpy0",
    Bj3rh1h: "f1bsuimh",
    a9b677: "f1ekdpwm",
    Bqenvij: "f83vc9z",
    Ftih45: "f1wl9k8s",
    B1puzpu: "f1wkw4r9",
    Brfgrao: "f1j7ml58",
    Bcvre1j: "fyl8oag",
    Ccq8qp: "frdoeuz",
    Baz25je: "fb81m9q",
    cmx5o7: "f1ljr5q2",
    B4f6apu: "fyfemzf",
    m598lv: "focyt6c",
    Bk5zm6e: "fnhxbxj",
    y0oebl: "fdw6hkg",
    qa3bma: "f11yjt3y",
    Bqjgrrk: "f1172wan",
    Budzafs: ["f9e5op9", "f112wvtl"],
    Hv9wc6: ["ftj5xct", "fyavhwi"],
    hl6cv3: "f1773hnp",
    Bh2vraf: "f1n8855c",
    yayu3t: "f1v7783n",
    wedwtw: "fsw6im5",
    rhl9o9: "fh2hsk5",
    Bu8t5uz: "f159pzir",
    B6q6orb: "f11yvu4",
    Bwwlvwl: "fm1ycve"
  }
}, {
  d: [".fjseox{display:none;}", ".f1ewtqcl{box-sizing:border-box;}", ".f132xexn{max-width:240px;}", ".f158kwzp{cursor:default;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".fokg9q4{overflow-wrap:break-word;}", ".f1aa9q02{border-bottom-right-radius:var(--borderRadiusMedium);}", ".f16jpd5f{border-bottom-left-radius:var(--borderRadiusMedium);}", ".f1jar5jt{border-top-right-radius:var(--borderRadiusMedium);}", ".fyu767a{border-top-left-radius:var(--borderRadiusMedium);}", ".f5ogflp{border-top-width:1px;}", ".f1hqa2wf{border-right-width:1px;}", ".finvdd3{border-left-width:1px;}", ".f1f09k3d{border-bottom-width:1px;}", ".fzkkow9{border-top-style:solid;}", ".fcdblym{border-right-style:solid;}", ".fjik90z{border-left-style:solid;}", ".fg706s2{border-bottom-style:solid;}", ".fghlq4f{border-top-color:var(--colorTransparentStroke);}", ".f1gn591s{border-right-color:var(--colorTransparentStroke);}", ".fjscplz{border-left-color:var(--colorTransparentStroke);}", ".fb073pr{border-bottom-color:var(--colorTransparentStroke);}", ".f10ra9hq{padding-top:4px;}", ".fd9xhir{padding-right:11px;}", ".f1jlaasf{padding-left:11px;}", ".f1d7kygh{padding-bottom:6px;}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".fxeb0a7{filter:drop-shadow(0 0 2px var(--colorNeutralShadowAmbient)) drop-shadow(0 4px 8px var(--colorNeutralShadowKey));}", ".ftgm304{display:block;}", ".fg3r6xk{background-color:var(--colorNeutralBackgroundStatic);}", ".fonrgv7{color:var(--colorNeutralForegroundStaticInverted);}", ".f1euv43f{position:absolute;}", ".f1u2r49w{background-color:inherit;}", ".fd7fpy0{visibility:hidden;}", ".f1bsuimh{z-index:-1;}", ".f1ekdpwm{width:8.484px;}", ".f83vc9z{height:8.484px;}", '.f1wl9k8s::before{content:"";}', ".f1wkw4r9::before{visibility:visible;}", ".f1j7ml58::before{position:absolute;}", ".fyl8oag::before{box-sizing:border-box;}", ".frdoeuz::before{width:inherit;}", ".fb81m9q::before{height:inherit;}", ".f1ljr5q2::before{background-color:inherit;}", ".fyfemzf::before{border-right-width:1px;}", ".focyt6c::before{border-right-style:solid;}", ".fnhxbxj::before{border-right-color:var(--colorTransparentStroke);}", ".fdw6hkg::before{border-bottom-width:1px;}", ".f11yjt3y::before{border-bottom-style:solid;}", ".f1172wan::before{border-bottom-color:var(--colorTransparentStroke);}", ".f9e5op9::before{border-bottom-right-radius:var(--borderRadiusSmall);}", ".f112wvtl::before{border-bottom-left-radius:var(--borderRadiusSmall);}", ".ftj5xct::before{transform:rotate(var(--angle)) translate(0, 50%) rotate(45deg);}", ".fyavhwi::before{transform:rotate(var(--angle)) translate(0, 50%) rotate(-45deg);}", '[data-popper-placement^="top"] .f1773hnp{bottom:-1px;}', '[data-popper-placement^="top"] .f1n8855c{--angle:0;}', '[data-popper-placement^="right"] .f1v7783n{left:-1px;}', '[data-popper-placement^="right"] .fsw6im5{--angle:90deg;}', '[data-popper-placement^="bottom"] .fh2hsk5{top:-1px;}', '[data-popper-placement^="bottom"] .f159pzir{--angle:180deg;}', '[data-popper-placement^="left"] .f11yvu4{right:-1px;}', '[data-popper-placement^="left"] .fm1ycve{--angle:270deg;}']
});
var useTooltipStyles_unstable = (state) => {
  const styles = useStyles15();
  state.content.className = mergeClasses(tooltipClassNames.content, styles.root, state.appearance === "inverted" && styles.inverted, state.visible && styles.visible, state.content.className);
  state.arrowClassName = styles.arrow;
  return state;
};

// node_modules/@fluentui/react-tooltip/lib/components/Tooltip/Tooltip.js
var Tooltip = (props) => {
  const state = useTooltip_unstable(props);
  useTooltipStyles_unstable(state);
  useCustomStyleHook("useTooltipStyles_unstable")(state);
  return renderTooltip_unstable(state);
};
Tooltip.displayName = "Tooltip";
Tooltip.isFluentTriggerComponent = true;

// node_modules/@fluentui/react-tooltip/lib/components/Tooltip/Tooltip.types.js
var React142 = __toESM(require_react());

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-avatar/lib/components/AvatarGroupPopover/useAvatarGroupPopover.js
var useAvatarGroupPopover_unstable = (props) => {
  var _useAvatarGroupContext_unstable;
  const size2 = (_useAvatarGroupContext_unstable = useAvatarGroupContext_unstable((ctx) => ctx.size)) !== null && _useAvatarGroupContext_unstable !== void 0 ? _useAvatarGroupContext_unstable : defaultAvatarGroupSize;
  const layout = useAvatarGroupContext_unstable((ctx) => ctx.layout);
  const { indicator = size2 < 24 ? "icon" : "count", count = React143.Children.count(props.children), children, ...restOfProps } = props;
  const [popoverOpen, setPopoverOpen] = useControllableState({
    state: props.open,
    defaultState: props.defaultOpen,
    initialState: false
  });
  const handleOnPopoverChange = (e2, data) => {
    var _restOfProps_onOpenChange;
    (_restOfProps_onOpenChange = restOfProps.onOpenChange) === null || _restOfProps_onOpenChange === void 0 ? void 0 : _restOfProps_onOpenChange.call(restOfProps, e2, data);
    setPopoverOpen(data.open);
  };
  let triggerButtonChildren;
  if (layout === "pie") {
    triggerButtonChildren = null;
  } else if (indicator === "icon") {
    triggerButtonChildren = React143.createElement(MoreHorizontalRegular, null);
  } else {
    triggerButtonChildren = count > 99 ? "99+" : `+${count}`;
  }
  return {
    count,
    indicator,
    layout,
    popoverOpen,
    size: size2,
    components: {
      root: Popover,
      triggerButton: "button",
      content: "ul",
      popoverSurface: PopoverSurface,
      tooltip: Tooltip
    },
    root: slot_exports.always({
      // Popover expects a child for its children. The children are added in the renderAvatarGroupPopover.
      children: React143.createElement(React143.Fragment, null),
      size: "small",
      trapFocus: true,
      ...restOfProps,
      open: popoverOpen,
      onOpenChange: handleOnPopoverChange
    }, {
      elementType: Popover
    }),
    triggerButton: slot_exports.always(props.triggerButton, {
      defaultProps: {
        children: triggerButtonChildren,
        type: "button"
      },
      elementType: "button"
    }),
    content: slot_exports.always(props.content, {
      defaultProps: {
        children,
        role: "list"
      },
      elementType: "ul"
    }),
    popoverSurface: slot_exports.always(props.popoverSurface, {
      defaultProps: {
        "aria-label": "Overflow",
        tabIndex: 0
      },
      elementType: PopoverSurface
    }),
    tooltip: slot_exports.always(props.tooltip, {
      defaultProps: {
        content: "View more people.",
        relationship: "label"
      },
      elementType: Tooltip
    })
  };
};

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-avatar/lib/components/AvatarGroupPopover/useAvatarGroupPopoverStyles.styles.js
var avatarGroupPopoverClassNames = {
  root: "fui-AvatarGroupPopover",
  content: "fui-AvatarGroupPopover__content",
  popoverSurface: "fui-AvatarGroupPopover__popoverSurface",
  tooltip: "fui-AvatarGroupPopover__tooltip",
  triggerButton: "fui-AvatarGroupPopover__triggerButton"
};
var useContentStyles = __styles({
  base: {
    dclx09: "ftrb29c",
    B6of3ja: "f1hu3pq6",
    t21cq0: ["f11qmguv", "f1tyq0we"],
    jrapky: "f19f4twv",
    Frg6f3: ["f1tyq0we", "f11qmguv"],
    z8tnut: "f1g0x7ka",
    z189sj: ["fhxju0i", "f1cnd47f"],
    Byoj8tv: "f1qch9an",
    uwmqm3: ["f1cnd47f", "fhxju0i"],
    mc9l5x: "f22iagw",
    Beiy3e4: "f1vx9l62"
  }
}, {
  d: [".ftrb29c{list-style-type:none;}", ".f1hu3pq6{margin-top:0;}", ".f11qmguv{margin-right:0;}", ".f1tyq0we{margin-left:0;}", ".f19f4twv{margin-bottom:0;}", ".f1g0x7ka{padding-top:0;}", ".fhxju0i{padding-right:0;}", ".f1cnd47f{padding-left:0;}", ".f1qch9an{padding-bottom:0;}", ".f22iagw{display:flex;}", ".f1vx9l62{flex-direction:column;}"]
});
var usePopoverSurfaceStyles = __styles({
  base: {
    Bxyxcbc: "fopcw2o",
    sshi5w: "f1n5o1gx",
    B68tc82: "f1p9o1ba",
    Bmxbyg5: "fqkkaap",
    z8tnut: "f1kwiid1",
    z189sj: ["f1vdfbxk", "f1f5gg8d"],
    Byoj8tv: "f5b47ha",
    uwmqm3: ["f1f5gg8d", "f1vdfbxk"],
    a9b677: "f13dwy2t"
  }
}, {
  d: [".fopcw2o{max-height:220px;}", ".f1n5o1gx{min-height:80px;}", ".f1p9o1ba{overflow-x:hidden;}", ".fqkkaap{overflow-y:scroll;}", ".f1kwiid1{padding-top:var(--spacingVerticalS);}", ".f1vdfbxk{padding-right:var(--spacingHorizontalS);}", ".f1f5gg8d{padding-left:var(--spacingHorizontalS);}", ".f5b47ha{padding-bottom:var(--spacingVerticalS);}", ".f13dwy2t{width:220px;}"]
});
var useTriggerButtonStyles = __styles({
  base: {
    mc9l5x: "ftuwxu6",
    qhf8xq: "f10pi13n",
    Bnnss6s: "fi64zpg",
    Brf1p80: "f4d9j23",
    Bt984gj: "f122n59",
    sj55zd: "f19n0e5",
    De3pzq: "fxugw4r",
    g2u3we: "fj3muxo",
    h3c5rm: ["f1akhkt", "f1lxtadh"],
    B9xav0g: "f1aperda",
    zhjwy3: ["f1lxtadh", "f1akhkt"],
    Bbmb7ep: ["f8fbkgy", "f1nfllo7"],
    Beyfa6y: ["f1nfllo7", "f8fbkgy"],
    B7oj6ja: ["f1djnp8u", "f1s8kh49"],
    Btl43ni: ["f1s8kh49", "f1djnp8u"],
    icvyot: "fzkkow9",
    vrafjx: ["fcdblym", "fjik90z"],
    oivjwe: "fg706s2",
    wvpqe5: ["fjik90z", "fcdblym"],
    z8tnut: "f1g0x7ka",
    z189sj: ["fhxju0i", "f1cnd47f"],
    Byoj8tv: "f1qch9an",
    uwmqm3: ["f1cnd47f", "fhxju0i"],
    Bjwas2f: "fw33nwi",
    Bn1d65q: ["f1ptkjjm", "fmzzjfk"],
    Bxeuatn: "f15j0dln",
    n51gp8: ["fmzzjfk", "f1ptkjjm"]
  },
  pie: {
    De3pzq: "f1c21dwh",
    g2u3we: "fghlq4f",
    h3c5rm: ["f1gn591s", "fjscplz"],
    B9xav0g: "fb073pr",
    zhjwy3: ["fjscplz", "f1gn591s"],
    sj55zd: "f44pa96"
  },
  focusIndicator: {
    Bbcte9g: "fhqs6ru",
    Bn40d3w: ["f14qhy8p", "f12lscv2"],
    i2cumq: "f1p9w1qi",
    lbo84a: ["f12lscv2", "f14qhy8p"],
    B5gfjzb: "ff4w5z6",
    u5e7qz: ["f1slf1ze", "f33ndkz"],
    Bbjhlyh: "fsap1ud",
    mqozju: ["f33ndkz", "f1slf1ze"],
    B8q5s1w: "f17t0x8g",
    Bci5o5g: ["f194v5ow", "fk7jm04"],
    n8qw10: "f1qgg65p",
    Bdrgwmp: ["fk7jm04", "f194v5ow"],
    g9k6zt: "f1nev41a"
  },
  states: {
    Bi91k9c: "feu1g3u",
    Jwef8y: "f1knas48",
    Bgoe8wy: "fvcxoqz",
    Bwzppfd: ["f1ub3y4t", "f1m52nbi"],
    oetu4i: "f1xlaoq0",
    gg5e9n: ["f1m52nbi", "f1ub3y4t"],
    lj723h: "f1g4hkjv",
    ecr2s2: "fb40n2d",
    B6oc9vd: "fvs00aa",
    ak43y8: ["f1assf6x", "f4ruux4"],
    wmxk5l: "fumykes",
    B50zh58: ["f4ruux4", "f1assf6x"]
  },
  selected: {
    sj55zd: "f14nttnl",
    De3pzq: "f1nfm20t",
    g2u3we: "f1ly1fcm",
    h3c5rm: ["fi8bssc", "fj6btzu"],
    B9xav0g: "f1s9tnsa",
    zhjwy3: ["fj6btzu", "fi8bssc"]
  },
  icon12: {
    Be2twd7: "f1ugzwwg"
  },
  icon16: {
    Be2twd7: "f4ybsrx"
  },
  icon20: {
    Be2twd7: "fe5j1ua"
  },
  icon24: {
    Be2twd7: "f1rt2boy"
  },
  icon28: {
    Be2twd7: "f24l1pt"
  },
  icon32: {
    Be2twd7: "ffl51b"
  },
  icon48: {
    Be2twd7: "f18m8u13"
  },
  caption2Strong: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "f13mqy1h",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "fcpl73t"
  },
  caption1Strong: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "fwrc4pm"
  },
  body1Strong: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "f1i3iumi"
  },
  subtitle2: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "faaz57k"
  },
  subtitle1: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "f1pp30po",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "f106mvju"
  },
  title3: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "f1x0m3f5",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "fb86gi6"
  },
  borderThin: {
    B4j52fo: "f192inf7",
    Bekrc4i: ["f5tn483", "f1ojsxk5"],
    Bn0qgzm: "f1vxd6vx",
    ibv6hh: ["f1ojsxk5", "f5tn483"]
  },
  borderThick: {
    B4j52fo: "f18zi460",
    Bekrc4i: ["f1wpluaz", "fsfsuhs"],
    Bn0qgzm: "fmklw6v",
    ibv6hh: ["fsfsuhs", "f1wpluaz"]
  },
  borderThicker: {
    B4j52fo: "fgx37oo",
    Bekrc4i: ["f130t4y6", "f1efpmoh"],
    Bn0qgzm: "fv51ejd",
    ibv6hh: ["f1efpmoh", "f130t4y6"]
  },
  borderThickest: {
    B4j52fo: "fwn6jck",
    Bekrc4i: ["figl7jc", "f1g0iy8l"],
    Bn0qgzm: "f1b8shu7",
    ibv6hh: ["f1g0iy8l", "figl7jc"]
  }
}, {
  d: [".ftuwxu6{display:inline-flex;}", ".f10pi13n{position:relative;}", ".fi64zpg{flex-shrink:0;}", ".f4d9j23{justify-content:center;}", ".f122n59{align-items:center;}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".fj3muxo{border-top-color:var(--colorNeutralStroke1);}", ".f1akhkt{border-right-color:var(--colorNeutralStroke1);}", ".f1lxtadh{border-left-color:var(--colorNeutralStroke1);}", ".f1aperda{border-bottom-color:var(--colorNeutralStroke1);}", ".f8fbkgy{border-bottom-right-radius:var(--borderRadiusCircular);}", ".f1nfllo7{border-bottom-left-radius:var(--borderRadiusCircular);}", ".f1djnp8u{border-top-right-radius:var(--borderRadiusCircular);}", ".f1s8kh49{border-top-left-radius:var(--borderRadiusCircular);}", ".fzkkow9{border-top-style:solid;}", ".fcdblym{border-right-style:solid;}", ".fjik90z{border-left-style:solid;}", ".fg706s2{border-bottom-style:solid;}", ".f1g0x7ka{padding-top:0;}", ".fhxju0i{padding-right:0;}", ".f1cnd47f{padding-left:0;}", ".f1qch9an{padding-bottom:0;}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".fghlq4f{border-top-color:var(--colorTransparentStroke);}", ".f1gn591s{border-right-color:var(--colorTransparentStroke);}", ".fjscplz{border-left-color:var(--colorTransparentStroke);}", ".fb073pr{border-bottom-color:var(--colorTransparentStroke);}", ".f44pa96{color:transparent;}", ".fhqs6ru[data-fui-focus-visible]{border-top-width:var(--strokeWidthThick);}", ".f14qhy8p[data-fui-focus-visible]{border-right-width:var(--strokeWidthThick);}", ".f12lscv2[data-fui-focus-visible]{border-left-width:var(--strokeWidthThick);}", ".f1p9w1qi[data-fui-focus-visible]{border-bottom-width:var(--strokeWidthThick);}", ".ff4w5z6[data-fui-focus-visible]{border-top-style:solid;}", ".f1slf1ze[data-fui-focus-visible]{border-right-style:solid;}", ".f33ndkz[data-fui-focus-visible]{border-left-style:solid;}", ".fsap1ud[data-fui-focus-visible]{border-bottom-style:solid;}", ".f17t0x8g[data-fui-focus-visible]{border-top-color:var(--colorStrokeFocus2);}", ".f194v5ow[data-fui-focus-visible]{border-right-color:var(--colorStrokeFocus2);}", ".fk7jm04[data-fui-focus-visible]{border-left-color:var(--colorStrokeFocus2);}", ".f1qgg65p[data-fui-focus-visible]{border-bottom-color:var(--colorStrokeFocus2);}", ".f1nev41a[data-fui-focus-visible]{outline-style:none;}", ".f14nttnl{color:var(--colorNeutralForeground1Selected);}", ".f1nfm20t{background-color:var(--colorNeutralBackground1Selected);}", ".f1ly1fcm{border-top-color:var(--colorNeutralStroke1Selected);}", ".fi8bssc{border-right-color:var(--colorNeutralStroke1Selected);}", ".fj6btzu{border-left-color:var(--colorNeutralStroke1Selected);}", ".f1s9tnsa{border-bottom-color:var(--colorNeutralStroke1Selected);}", ".f1ugzwwg{font-size:12px;}", ".f4ybsrx{font-size:16px;}", ".fe5j1ua{font-size:20px;}", ".f1rt2boy{font-size:24px;}", ".f24l1pt{font-size:28px;}", ".ffl51b{font-size:32px;}", ".f18m8u13{font-size:48px;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".f13mqy1h{font-size:var(--fontSizeBase100);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fcpl73t{line-height:var(--lineHeightBase100);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".f1pp30po{font-size:var(--fontSizeBase500);}", ".f106mvju{line-height:var(--lineHeightBase500);}", ".f1x0m3f5{font-size:var(--fontSizeBase600);}", ".fb86gi6{line-height:var(--lineHeightBase600);}", ".f192inf7{border-top-width:var(--strokeWidthThin);}", ".f5tn483{border-right-width:var(--strokeWidthThin);}", ".f1ojsxk5{border-left-width:var(--strokeWidthThin);}", ".f1vxd6vx{border-bottom-width:var(--strokeWidthThin);}", ".f18zi460{border-top-width:var(--strokeWidthThick);}", ".f1wpluaz{border-right-width:var(--strokeWidthThick);}", ".fsfsuhs{border-left-width:var(--strokeWidthThick);}", ".fmklw6v{border-bottom-width:var(--strokeWidthThick);}", ".fgx37oo{border-top-width:var(--strokeWidthThicker);}", ".f130t4y6{border-right-width:var(--strokeWidthThicker);}", ".f1efpmoh{border-left-width:var(--strokeWidthThicker);}", ".fv51ejd{border-bottom-width:var(--strokeWidthThicker);}", ".fwn6jck{border-top-width:var(--strokeWidthThickest);}", ".figl7jc{border-right-width:var(--strokeWidthThickest);}", ".f1g0iy8l{border-left-width:var(--strokeWidthThickest);}", ".f1b8shu7{border-bottom-width:var(--strokeWidthThickest);}"],
  m: [["@media (forced-colors: active){.fw33nwi{border-top-color:CanvasText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1ptkjjm{border-right-color:CanvasText;}.fmzzjfk{border-left-color:CanvasText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f15j0dln{border-bottom-color:CanvasText;}}", {
    m: "(forced-colors: active)"
  }]],
  h: [".feu1g3u:hover{color:var(--colorNeutralForeground1Hover);}", ".f1knas48:hover{background-color:var(--colorNeutralBackground1Hover);}", ".fvcxoqz:hover{border-top-color:var(--colorNeutralStroke1Hover);}", ".f1ub3y4t:hover{border-right-color:var(--colorNeutralStroke1Hover);}", ".f1m52nbi:hover{border-left-color:var(--colorNeutralStroke1Hover);}", ".f1xlaoq0:hover{border-bottom-color:var(--colorNeutralStroke1Hover);}"],
  a: [".f1g4hkjv:active{color:var(--colorNeutralForeground1Pressed);}", ".fb40n2d:active{background-color:var(--colorNeutralBackground1Pressed);}", ".fvs00aa:active{border-top-color:var(--colorNeutralStroke1Pressed);}", ".f1assf6x:active{border-right-color:var(--colorNeutralStroke1Pressed);}", ".f4ruux4:active{border-left-color:var(--colorNeutralStroke1Pressed);}", ".fumykes:active{border-bottom-color:var(--colorNeutralStroke1Pressed);}"]
});
var useAvatarGroupPopoverStyles_unstable = (state) => {
  const {
    indicator,
    size: size2,
    layout,
    popoverOpen
  } = state;
  const sizeStyles = useSizeStyles();
  const triggerButtonStyles = useTriggerButtonStyles();
  const contentStyles = useContentStyles();
  const popoverSurfaceStyles = usePopoverSurfaceStyles();
  const groupChildClassName = useGroupChildClassName(layout, size2);
  const triggerButtonClasses = [];
  if (size2 < 36) {
    triggerButtonClasses.push(triggerButtonStyles.borderThin);
  } else if (size2 < 56) {
    triggerButtonClasses.push(triggerButtonStyles.borderThick);
  } else if (size2 < 72) {
    triggerButtonClasses.push(triggerButtonStyles.borderThicker);
  } else {
    triggerButtonClasses.push(triggerButtonStyles.borderThickest);
  }
  if (indicator === "count") {
    if (size2 <= 24) {
      triggerButtonClasses.push(triggerButtonStyles.caption2Strong);
    } else if (size2 <= 28) {
      triggerButtonClasses.push(triggerButtonStyles.caption1Strong);
    } else if (size2 <= 40) {
      triggerButtonClasses.push(triggerButtonStyles.body1Strong);
    } else if (size2 <= 56) {
      triggerButtonClasses.push(triggerButtonStyles.subtitle2);
    } else if (size2 <= 96) {
      triggerButtonClasses.push(triggerButtonStyles.subtitle1);
    } else {
      triggerButtonClasses.push(triggerButtonStyles.title3);
    }
  } else {
    if (size2 <= 16) {
      triggerButtonClasses.push(triggerButtonStyles.icon12);
    } else if (size2 <= 24) {
      triggerButtonClasses.push(triggerButtonStyles.icon16);
    } else if (size2 <= 40) {
      triggerButtonClasses.push(triggerButtonStyles.icon20);
    } else if (size2 <= 48) {
      triggerButtonClasses.push(triggerButtonStyles.icon24);
    } else if (size2 <= 56) {
      triggerButtonClasses.push(triggerButtonStyles.icon28);
    } else if (size2 <= 72) {
      triggerButtonClasses.push(triggerButtonStyles.icon32);
    } else {
      triggerButtonClasses.push(triggerButtonStyles.icon48);
    }
  }
  state.triggerButton.className = mergeClasses(avatarGroupPopoverClassNames.triggerButton, groupChildClassName, sizeStyles[size2], triggerButtonStyles.base, layout === "pie" && triggerButtonStyles.pie, triggerButtonStyles.focusIndicator, layout !== "pie" && triggerButtonStyles.states, layout !== "pie" && popoverOpen && triggerButtonStyles.selected, ...triggerButtonClasses, state.triggerButton.className);
  state.content.className = mergeClasses(avatarGroupPopoverClassNames.content, contentStyles.base, state.content.className);
  state.popoverSurface.className = mergeClasses(avatarGroupPopoverClassNames.popoverSurface, popoverSurfaceStyles.base, state.popoverSurface.className);
  return state;
};

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-avatar/lib/components/AvatarGroupPopover/AvatarGroupPopover.js
var AvatarGroupPopover = (props) => {
  const state = useAvatarGroupPopover_unstable(props);
  const contextValues = useAvatarGroupPopoverContextValues(state);
  useAvatarGroupPopoverStyles_unstable(state);
  useCustomStyleHook("useAvatarGroupPopoverStyles_unstable")(state);
  return renderAvatarGroupPopover_unstable(state, contextValues);
};
AvatarGroupPopover.displayName = "AvatarGroupPopover";

// node_modules/@fluentui/react-table/node_modules/@fluentui/react-avatar/lib/components/AvatarGroupPopover/AvatarGroupPopover.types.js
var React145 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableCellLayout/renderTableCellLayout.js
var renderTableCellLayout_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.media && jsx(AvatarContextProvider, {
        value: contextValues.avatar,
        children: jsx(state.media, {})
      }),
      state.content && jsxs(state.content, {
        children: [
          state.main && jsx(state.main, {
            children: state.root.children
          }),
          state.description && jsx(state.description, {})
        ]
      })
    ]
  });
};

// node_modules/@fluentui/react-table/lib/components/TableCellLayout/useTableCellLayoutStyles.styles.js
var tableCellLayoutClassNames = {
  root: "fui-TableCellLayout",
  media: "fui-TableCellLayout__media",
  main: "fui-TableCellLayout__main",
  description: "fui-TableCellLayout__description",
  content: "fui-TableCellLayout__content"
};
var useStyles16 = __styles({
  root: {
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59",
    i8kkvl: "fsnqrgy",
    Belr9w4: "fylz90v",
    Bh6795r: "fqerorx",
    Bnnss6s: "f1neuvcm",
    xawz: "fkjuxzh"
  },
  rootTruncate: {
    B68tc82: "f1p9o1ba"
  },
  content: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1vx9l62"
  },
  contentTruncate: {
    B68tc82: "f1p9o1ba"
  },
  media: {
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59"
  },
  mediaExtraSmall: {
    Be2twd7: "f4ybsrx"
  },
  mediaSmallAndMedium: {
    Be2twd7: "fe5j1ua"
  },
  mediaPrimary: {
    Be2twd7: "f1rt2boy"
  },
  mainPrimary: {
    Bhrd7zp: "fl43uef"
  },
  mainTruncate: {
    B68tc82: "f1p9o1ba",
    Huce71: "fz5stix",
    ygn44y: "f1cmbuwj"
  },
  description: {
    sj55zd: "fkfq4zb",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f122n59{align-items:center;}", ".fsnqrgy{column-gap:var(--spacingHorizontalS);}", ".fylz90v{row-gap:var(--spacingHorizontalS);}", ".fqerorx{flex-grow:1;}", ".f1neuvcm{flex-shrink:1;}", ".fkjuxzh{flex-basis:0px;}", ".f1p9o1ba{overflow-x:hidden;}", ".f1vx9l62{flex-direction:column;}", ".f4ybsrx{font-size:16px;}", ".fe5j1ua{font-size:20px;}", ".f1rt2boy{font-size:24px;}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fz5stix{white-space:nowrap;}", ".f1cmbuwj{text-overflow:ellipsis;}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}"]
});
var useTableCellLayoutStyles_unstable = (state) => {
  const styles = useStyles16();
  const {
    truncate
  } = state;
  state.root.className = mergeClasses(tableCellLayoutClassNames.root, styles.root, truncate && styles.rootTruncate, state.root.className);
  const primary = state.appearance === "primary";
  if (state.media) {
    const mediaSizedStyles = {
      small: styles.mediaSmallAndMedium,
      medium: styles.mediaSmallAndMedium,
      "extra-small": styles.mediaExtraSmall
    };
    state.media.className = mergeClasses(tableCellLayoutClassNames.media, styles.media, mediaSizedStyles[state.size], primary && styles.mediaPrimary, state.media.className);
  }
  if (state.main) {
    state.main.className = mergeClasses(tableCellLayoutClassNames.main, truncate && styles.mainTruncate, primary && styles.mainPrimary, state.main.className);
  }
  if (state.description) {
    state.description.className = mergeClasses(tableCellLayoutClassNames.description, styles.description, state.description.className);
  }
  if (state.content) {
    state.content.className = mergeClasses(tableCellLayoutClassNames.content, styles.content, truncate && styles.contentTruncate, state.content.className);
  }
  return state;
};

// node_modules/@fluentui/react-table/lib/components/TableCellLayout/useTableCellLayoutContextValues.js
var React146 = __toESM(require_react());
function useTableCellLayoutContextValues_unstable(state) {
  const { avatarSize } = state;
  const avatar = React146.useMemo(() => ({
    size: avatarSize
  }), [
    avatarSize
  ]);
  return {
    avatar
  };
}

// node_modules/@fluentui/react-table/lib/components/TableCellLayout/TableCellLayout.js
var TableCellLayout = React147.forwardRef((props, ref) => {
  const state = useTableCellLayout_unstable(props, ref);
  useTableCellLayoutStyles_unstable(state);
  useCustomStyleHook("useTableCellLayoutStyles_unstable")(state);
  return renderTableCellLayout_unstable(state, useTableCellLayoutContextValues_unstable(state));
});
TableCellLayout.displayName = "TableCellLayout";

// node_modules/@fluentui/react-table/lib/components/DataGridCell/DataGridCell.js
var React149 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/DataGridCell/useDataGridCell.js
var React148 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/contexts/dataGridContext.js
var dataGridContext = createContext20(void 0);
var dataGridContextDefaultValue = {
  ...defaultTableState,
  subtleSelection: false,
  selectableRows: false,
  selectionAppearance: "brand",
  focusMode: "none",
  compositeRowTabsterAttribute: {}
};
var DataGridContextProvider = dataGridContext.Provider;
var useDataGridContext_unstable = (selector) => useContextSelector(dataGridContext, (ctx = dataGridContextDefaultValue) => selector(ctx));

// node_modules/@fluentui/react-table/lib/components/DataGridCell/useDataGridCell.js
var useDataGridCell_unstable = (props, ref) => {
  const { focusMode = "cell" } = props;
  const columnId = useColumnIdContext();
  const tabbable = useDataGridContext_unstable((ctx) => (ctx.focusMode === "cell" || ctx.focusMode === "composite") && focusMode !== "none");
  const resizableColumns = useDataGridContext_unstable((ctx) => ctx.resizableColumns);
  const columnSizing = useDataGridContext_unstable((ctx) => ctx.columnSizing_unstable);
  const focusableGroupAttr = useFocusableGroup({
    tabBehavior: "limited-trap-focus"
  });
  return useTableCell_unstable({
    as: "div",
    role: "gridcell",
    ...focusMode === "group" && focusableGroupAttr,
    tabIndex: tabbable ? 0 : void 0,
    ...resizableColumns ? columnSizing.getTableCellProps(columnId) : {},
    ...props
  }, ref);
};

// node_modules/@fluentui/react-table/lib/components/DataGridCell/renderDataGridCell.js
var renderDataGridCell_unstable = (state) => {
  return renderTableCell_unstable(state);
};

// node_modules/@fluentui/react-table/lib/components/DataGridCell/useDataGridCellStyles.styles.js
var dataGridCellClassNames = {
  root: "fui-DataGridCell"
};
var useDataGridCellStyles_unstable = (state) => {
  useTableCellStyles_unstable(state);
  state.root.className = mergeClasses(dataGridCellClassNames.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/DataGridCell/DataGridCell.js
var DataGridCell = React149.forwardRef((props, ref) => {
  const state = useDataGridCell_unstable(props, ref);
  useDataGridCellStyles_unstable(state);
  useCustomStyleHook("useDataGridCellStyles_unstable")(state);
  return renderDataGridCell_unstable(state);
});
DataGridCell.displayName = "DataGridCell";

// node_modules/@fluentui/react-table/lib/components/DataGridRow/DataGridRow.js
var React153 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/DataGridRow/useDataGridRow.js
var React152 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/DataGridSelectionCell/DataGridSelectionCell.js
var React151 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/DataGridSelectionCell/useDataGridSelectionCell.js
var React150 = __toESM(require_react());
var useDataGridSelectionCell_unstable = (props, ref) => {
  const isHeader = useIsInTableHeader();
  const rowId = useTableRowIdContext();
  const subtle = useDataGridContext_unstable((ctx) => ctx.subtleSelection);
  const checked = useDataGridContext_unstable((ctx) => {
    if (isHeader && ctx.selection.selectionMode === "multiselect") {
      return ctx.selection.allRowsSelected ? true : ctx.selection.someRowsSelected ? "mixed" : false;
    }
    return ctx.selection.isRowSelected(rowId);
  });
  const toggleAllRows = useDataGridContext_unstable((ctx) => ctx.selection.toggleAllRows);
  const type = useDataGridContext_unstable((ctx) => ctx.selection.selectionMode === "multiselect" ? "checkbox" : "radio");
  const onClick = useEventCallback((e2) => {
    var _props_onClick;
    if (isHeader) {
      toggleAllRows(e2);
    }
    (_props_onClick = props.onClick) === null || _props_onClick === void 0 ? void 0 : _props_onClick.call(props, e2);
  });
  return useTableSelectionCell_unstable({
    as: "div",
    role: "gridcell",
    checked,
    type,
    hidden: isHeader && type === "radio",
    "aria-checked": isHeader ? checked : void 0,
    "aria-selected": isHeader || checked === "mixed" ? void 0 : checked,
    subtle,
    ...props,
    onClick
  }, ref);
};

// node_modules/@fluentui/react-table/lib/components/DataGridSelectionCell/renderDataGridSelectionCell.js
var renderDataGridSelectionCell_unstable = (state) => {
  return renderTableSelectionCell_unstable(state);
};

// node_modules/@fluentui/react-table/lib/components/DataGridSelectionCell/useDataGridSelectionCellStyles.styles.js
var dataGridSelectionCellClassNames = {
  root: "fui-DataGridSelectionCell",
  checkboxIndicator: "fui-DataGridSelectionCell__checkboxIndicator",
  radioIndicator: "fui-DataGridSelectionCell__radioIndicator"
};
var useDataGridSelectionCellStyles_unstable = (state) => {
  useTableSelectionCellStyles_unstable(state);
  state.root.className = mergeClasses(dataGridSelectionCellClassNames.root, state.root.className);
  if (state.checkboxIndicator) {
    state.checkboxIndicator.className = mergeClasses(dataGridSelectionCellClassNames.checkboxIndicator, state.checkboxIndicator.className);
  }
  if (state.radioIndicator) {
    state.radioIndicator.className = mergeClasses(dataGridSelectionCellClassNames.radioIndicator, state.radioIndicator.className);
  }
  return state;
};

// node_modules/@fluentui/react-table/lib/components/DataGridSelectionCell/DataGridSelectionCell.js
var DataGridSelectionCell = React151.forwardRef((props, ref) => {
  const state = useDataGridSelectionCell_unstable(props, ref);
  useDataGridSelectionCellStyles_unstable(state);
  useCustomStyleHook("useDataGridSelectionCellStyles_unstable")(state);
  return renderDataGridSelectionCell_unstable(state);
});
DataGridSelectionCell.displayName = "DataGridSelectionCell";

// node_modules/@fluentui/react-table/lib/components/DataGridRow/useDataGridRow.js
var useDataGridRow_unstable = (props, ref) => {
  const rowId = useTableRowIdContext();
  const isHeader = useIsInTableHeader();
  const columnDefs = useDataGridContext_unstable((ctx) => ctx.columns);
  const selectable = useDataGridContext_unstable((ctx) => ctx.selectableRows);
  const selected = useDataGridContext_unstable((ctx) => ctx.selection.isRowSelected(rowId));
  const focusMode = useDataGridContext_unstable((ctx) => ctx.focusMode);
  const compositeRowTabsterAttribute = useDataGridContext_unstable((ctx) => ctx.compositeRowTabsterAttribute);
  const tabbable = focusMode === "row_unstable" || focusMode === "composite";
  const appearance = useDataGridContext_unstable((ctx) => {
    if (!isHeader && selectable && ctx.selection.isRowSelected(rowId)) {
      return ctx.selectionAppearance;
    }
    return "none";
  });
  const toggleRow = useDataGridContext_unstable((ctx) => ctx.selection.toggleRow);
  const dataGridContextValue = useDataGridContext_unstable((ctx) => ctx);
  const onClick = useEventCallback((e2) => {
    var _props_onClick;
    if (selectable && !isHeader) {
      toggleRow(e2, rowId);
    }
    (_props_onClick = props.onClick) === null || _props_onClick === void 0 ? void 0 : _props_onClick.call(props, e2);
  });
  const onKeyDown = useEventCallback((e2) => {
    var _props_onKeyDown;
    if (selectable && !isHeader && e2.key === Space2 && !isInteractiveHTMLElement(e2.target)) {
      e2.preventDefault();
      toggleRow(e2, rowId);
    }
    (_props_onKeyDown = props.onKeyDown) === null || _props_onKeyDown === void 0 ? void 0 : _props_onKeyDown.call(props, e2);
  });
  const baseState = useTableRow_unstable({
    appearance,
    "aria-selected": selectable ? selected : void 0,
    tabIndex: tabbable && !isHeader ? 0 : void 0,
    ...focusMode === "composite" && !isHeader && compositeRowTabsterAttribute,
    ...props,
    onClick,
    onKeyDown,
    children: null,
    as: "div"
  }, ref);
  return {
    ...baseState,
    components: {
      ...baseState.components,
      selectionCell: DataGridSelectionCell
    },
    selectionCell: slot_exports.optional(props.selectionCell, {
      renderByDefault: selectable,
      elementType: DataGridSelectionCell
    }),
    renderCell: props.children,
    columnDefs,
    dataGridContextValue
  };
};

// node_modules/@fluentui/react-table/lib/components/DataGridRow/renderDataGridRow.js
var renderDataGridRow_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.selectionCell && jsx(state.selectionCell, {}),
      state.columnDefs.map((columnDef) => jsx(ColumnIdContextProvider, {
        value: columnDef.columnId,
        children: state.renderCell(columnDef, state.dataGridContextValue)
      }, columnDef.columnId))
    ]
  });
};

// node_modules/@fluentui/react-table/lib/components/DataGridRow/useDataGridRowStyles.styles.js
var dataGridRowClassNames = {
  root: "fui-DataGridRow",
  selectionCell: "fui-DataGridRow__selectionCell"
};
var useDataGridRowStyles_unstable = (state) => {
  useTableRowStyles_unstable(state);
  state.root.className = mergeClasses(dataGridRowClassNames.root, state.root.className);
  if (state.selectionCell) {
    state.selectionCell.className = mergeClasses(dataGridRowClassNames.selectionCell, state.selectionCell.className);
  }
  return state;
};

// node_modules/@fluentui/react-table/lib/components/DataGridRow/DataGridRow.js
var DataGridRow = React153.forwardRef((props, ref) => {
  const state = useDataGridRow_unstable(props, ref);
  useDataGridRowStyles_unstable(state);
  useCustomStyleHook("useDataGridRowStyles_unstable")(state);
  return renderDataGridRow_unstable(state);
});
DataGridRow.displayName = "DataGridRow";

// node_modules/@fluentui/react-table/lib/components/DataGridRow/DataGridRow.types.js
var React154 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/DataGridBody/DataGridBody.js
var React156 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/DataGridBody/useDataGridBody.js
var React155 = __toESM(require_react());
var useDataGridBody_unstable = (props, ref) => {
  const { sortable } = useTableContext();
  const getRows = useDataGridContext_unstable((ctx) => ctx.getRows);
  const sort = useDataGridContext_unstable((ctx) => ctx.sort.sort);
  const rows = sortable ? sort(getRows()) : getRows();
  const baseState = useTableBody_unstable({
    ...props,
    children: null,
    as: "div"
  }, ref);
  return {
    ...baseState,
    rows,
    renderRow: props.children
  };
};

// node_modules/@fluentui/react-table/lib/components/DataGridBody/renderDataGridBody.js
var renderDataGridBody_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {
    children: state.rows.map((row) => jsx(TableRowIdContextProvider, {
      value: row.rowId,
      children: state.renderRow(row)
    }, row.rowId))
  });
};

// node_modules/@fluentui/react-table/lib/components/DataGridBody/useDataGridBodyStyles.styles.js
var dataGridBodyClassNames = {
  root: "fui-DataGridBody"
};
var useDataGridBodyStyles_unstable = (state) => {
  useTableBodyStyles_unstable(state);
  state.root.className = mergeClasses(dataGridBodyClassNames.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/DataGridBody/DataGridBody.js
var DataGridBody = React156.forwardRef((props, ref) => {
  const state = useDataGridBody_unstable(props, ref);
  useDataGridBodyStyles_unstable(state);
  useCustomStyleHook("useDataGridBodyStyles_unstable")(state);
  return renderDataGridBody_unstable(state);
});
DataGridBody.displayName = "DataGridBody";

// node_modules/@fluentui/react-table/lib/components/DataGridBody/DataGridBody.types.js
var React157 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/DataGrid/DataGrid.js
var React160 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/DataGrid/useDataGrid.js
var React158 = __toESM(require_react());
var useDataGrid_unstable = (props, ref) => {
  const { items, columns, focusMode = "cell", selectionMode, onSortChange, onSelectionChange, defaultSortState, sortState, selectedItems, defaultSelectedItems, subtleSelection = false, selectionAppearance = "brand", getRowId, resizableColumns, columnSizingOptions, onColumnResize, containerWidthOffset } = props;
  const widthOffset = containerWidthOffset !== null && containerWidthOffset !== void 0 ? containerWidthOffset : selectionMode ? -CELL_WIDTH : 0;
  const gridTabsterAttribute = useArrowNavigationGroup({
    axis: "grid"
  });
  const { onTableKeyDown: onCompositeKeyDown, tableTabsterAttribute: compositeTabsterAttribute, tableRowTabsterAttribute: compositeRowTabsterAttribute } = useTableCompositeNavigation();
  const tableState = useTableFeatures({
    items,
    columns,
    getRowId
  }, [
    useTableSort({
      defaultSortState,
      sortState,
      onSortChange
    }),
    useTableSelection({
      defaultSelectedItems,
      selectedItems,
      onSelectionChange,
      selectionMode: selectionMode !== null && selectionMode !== void 0 ? selectionMode : "multiselect"
    }),
    useTableColumnSizing_unstable({
      onColumnResize,
      columnSizingOptions,
      // The selection cell is not part of the columns, therefore its width needs to be subtracted
      // from the container to make sure the columns don't overflow the table.
      containerWidthOffset: widthOffset
    })
  ]);
  const innerRef = React158.useRef(null);
  const { findFirstFocusable, findLastFocusable } = useFocusFinders();
  const onKeyDown = useEventCallback((e2) => {
    var _props_onKeyDown;
    (_props_onKeyDown = props.onKeyDown) === null || _props_onKeyDown === void 0 ? void 0 : _props_onKeyDown.call(props, e2);
    focusMode === "composite" && onCompositeKeyDown(e2);
    if (!innerRef.current || !e2.ctrlKey || e2.defaultPrevented) {
      return;
    }
    if (e2.key === Home2) {
      const firstRow = innerRef.current.querySelector('[role="row"]');
      if (firstRow) {
        var _findFirstFocusable;
        (_findFirstFocusable = findFirstFocusable(firstRow)) === null || _findFirstFocusable === void 0 ? void 0 : _findFirstFocusable.focus();
      }
    }
    if (e2.key === End2) {
      const rows = innerRef.current.querySelectorAll('[role="row"]');
      if (rows.length) {
        var _findLastFocusable;
        const lastRow = rows.item(rows.length - 1);
        (_findLastFocusable = findLastFocusable(lastRow)) === null || _findLastFocusable === void 0 ? void 0 : _findLastFocusable.focus();
      }
    }
  });
  const baseTableState = useTable_unstable({
    role: "grid",
    as: "div",
    noNativeElements: true,
    ...focusMode === "cell" && gridTabsterAttribute,
    ...focusMode === "composite" && compositeTabsterAttribute,
    ...props,
    onKeyDown,
    ...resizableColumns ? tableState.columnSizing_unstable.getTableProps(props) : {}
  }, useMergedRefs(ref, tableState.tableRef, innerRef));
  return {
    ...baseTableState,
    focusMode,
    tableState,
    selectableRows: !!selectionMode,
    subtleSelection,
    selectionAppearance,
    resizableColumns,
    compositeRowTabsterAttribute
  };
};

// node_modules/@fluentui/react-table/lib/components/DataGrid/renderDataGrid.js
var React159 = __toESM(require_react());
var renderDataGrid_unstable = (state, contextValues) => {
  return React159.createElement(DataGridContextProvider, {
    value: contextValues.dataGrid
  }, renderTable_unstable(state, contextValues));
};

// node_modules/@fluentui/react-table/lib/components/DataGrid/useDataGridStyles.styles.js
var dataGridClassNames = {
  root: "fui-DataGrid"
};
var useDataGridStyles_unstable = (state) => {
  useTableStyles_unstable(state);
  state.root.className = mergeClasses(dataGridClassNames.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/DataGrid/useDataGridContextValues.js
function useDataGridContextValues_unstable(state) {
  const tableContextValues = useTableContextValues_unstable(state);
  const { tableState, focusMode, selectableRows, subtleSelection, selectionAppearance, resizableColumns, compositeRowTabsterAttribute } = state;
  return {
    ...tableContextValues,
    dataGrid: {
      ...tableState,
      focusMode,
      selectableRows,
      subtleSelection,
      selectionAppearance,
      resizableColumns,
      compositeRowTabsterAttribute
    }
  };
}

// node_modules/@fluentui/react-table/lib/components/DataGrid/DataGrid.js
var DataGrid = React160.forwardRef((props, ref) => {
  const state = useDataGrid_unstable(props, ref);
  useDataGridStyles_unstable(state);
  useCustomStyleHook("useDataGridStyles_unstable")(state);
  return renderDataGrid_unstable(state, useDataGridContextValues_unstable(state));
});
DataGrid.displayName = "DataGrid";

// node_modules/@fluentui/react-table/lib/components/DataGrid/DataGrid.types.js
var React161 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/DataGridHeader/DataGridHeader.js
var React163 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/DataGridHeader/useDataGridHeader.js
var React162 = __toESM(require_react());
var useDataGridHeader_unstable = (props, ref) => {
  return useTableHeader_unstable({
    ...props,
    as: "div"
  }, ref);
};

// node_modules/@fluentui/react-table/lib/components/DataGridHeader/renderDataGridHeader.js
var renderDataGridHeader_unstable = (state) => {
  return renderTableHeader_unstable(state);
};

// node_modules/@fluentui/react-table/lib/components/DataGridHeader/useDataGridHeaderStyles.styles.js
var dataGridHeaderClassNames = {
  root: "fui-DataGridHeader"
};
var useDataGridHeaderStyles_unstable = (state) => {
  useTableHeaderStyles_unstable(state);
  state.root.className = mergeClasses(dataGridHeaderClassNames.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/DataGridHeader/DataGridHeader.js
var DataGridHeader = React163.forwardRef((props, ref) => {
  const state = useDataGridHeader_unstable(props, ref);
  useDataGridHeaderStyles_unstable(state);
  useCustomStyleHook("useDataGridHeaderStyles_unstable")(state);
  return renderDataGridHeader_unstable(state);
});
DataGridHeader.displayName = "DataGridHeader";

// node_modules/@fluentui/react-table/lib/components/DataGridHeaderCell/DataGridHeaderCell.js
var React165 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/DataGridHeaderCell/useDataGridHeaderCell.js
var React164 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/utils/isColumnSortable.js
function isColumnSortable(column) {
  return column.compare.length > 0;
}

// node_modules/@fluentui/react-table/lib/components/DataGridHeaderCell/useDataGridHeaderCell.js
var useDataGridHeaderCell_unstable = (props, ref) => {
  const columnId = useColumnIdContext();
  const { sortable: gridSortable } = useTableContext();
  const toggleColumnSort = useDataGridContext_unstable((ctx) => ctx.sort.toggleColumnSort);
  const sortable = useDataGridContext_unstable((ctx) => {
    const columnSortable = !!ctx.columns.find((c3) => c3.columnId === columnId && isColumnSortable(c3));
    if (!gridSortable) {
      return false;
    }
    return columnSortable;
  });
  const sortDirection = useDataGridContext_unstable((ctx) => sortable ? ctx.sort.getSortDirection(columnId) : void 0);
  const resizableColumns = useDataGridContext_unstable((ctx) => ctx.resizableColumns);
  const columnSizing = useDataGridContext_unstable((ctx) => ctx.columnSizing_unstable);
  const onClick = useEventCallback((e2) => {
    var _props_onClick;
    if (sortable) {
      toggleColumnSort(e2, columnId);
    }
    (_props_onClick = props.onClick) === null || _props_onClick === void 0 ? void 0 : _props_onClick.call(props, e2);
  });
  return useTableHeaderCell_unstable({
    sortable,
    sortDirection,
    as: "div",
    tabIndex: sortable ? void 0 : 0,
    ...resizableColumns ? columnSizing.getTableHeaderCellProps(columnId) : {},
    ...props,
    onClick
  }, ref);
};

// node_modules/@fluentui/react-table/lib/components/DataGridHeaderCell/renderDataGridHeaderCell.js
var renderDataGridHeaderCell_unstable = (state) => {
  return renderTableHeaderCell_unstable(state);
};

// node_modules/@fluentui/react-table/lib/components/DataGridHeaderCell/useDataGridHeaderCellStyles.styles.js
var dataGridHeaderCellClassNames = {
  root: "fui-DataGridHeaderCell",
  button: "fui-DataGridHeaderCell__button",
  sortIcon: "fui-DataGridHeaderCell__sortIcon",
  aside: "fui-DataGridHeaderCell__aside"
};
var useDataGridHeaderCellStyles_unstable = (state) => {
  useTableHeaderCellStyles_unstable(state);
  state.root.className = mergeClasses(dataGridHeaderCellClassNames.root, state.root.className);
  if (state.button) {
    state.button.className = mergeClasses(dataGridHeaderCellClassNames.button, state.button.className);
  }
  if (state.sortIcon) {
    state.sortIcon.className = mergeClasses(dataGridHeaderCellClassNames.sortIcon, state.sortIcon.className);
  }
  if (state.aside) {
    state.aside.className = mergeClasses(dataGridHeaderCellClassNames.aside, state.aside.className);
  }
  return state;
};

// node_modules/@fluentui/react-table/lib/components/DataGridHeaderCell/DataGridHeaderCell.js
var DataGridHeaderCell = React165.forwardRef((props, ref) => {
  const state = useDataGridHeaderCell_unstable(props, ref);
  useDataGridHeaderCellStyles_unstable(state);
  useCustomStyleHook("useDataGridHeaderCellStyles_unstable")(state);
  return renderDataGridHeaderCell_unstable(state);
});
DataGridHeaderCell.displayName = "DataGridHeaderCell";

export {
  slot_exports,
  getSlots,
  resolveShorthand2 as resolveShorthand,
  isResolvedShorthand,
  assertSlots,
  getNativeElementProps,
  getPartitionedNativeProps,
  getIntrinsicElementProps,
  canUseDOM,
  useControllableState,
  SSRProvider,
  useIsSSR,
  useIsomorphicLayoutEffect,
  useEventCallback,
  useFirstMount,
  useForceUpdate,
  IdPrefixProvider,
  resetIdsForTests,
  useId2 as useId,
  useMergedRefs,
  useOnClickOutside,
  useOnScrollOutside,
  useScrollbarWidth,
  useTimeout,
  clamp,
  getRTLSafeKey,
  mergeCallbacks,
  isHTMLElement,
  createPriorityQueue,
  applyTriggerPropsToChildren,
  getTriggerChild,
  elementContains,
  jsx,
  jsxs,
  import_react3 as import_react,
  ThemeContext,
  ThemeProvider,
  ThemeClassNameProvider,
  useThemeClassName,
  TooltipVisibilityProvider,
  useTooltipVisibility,
  Provider,
  useFluent,
  OverridesProvider,
  useOverrides,
  CustomStyleHooksContext,
  CustomStyleHooksProvider,
  useCustomStyleHook,
  BackgroundAppearanceProvider,
  useBackgroundAppearance,
  PortalMountNodeProvider,
  usePortalMountNode,
  useAnnounce,
  useTabsterAttributes,
  useArrowNavigationGroup,
  useFocusableGroup,
  useFocusFinders,
  useFocusVisible,
  useFocusWithin,
  useKeyboardNavAttribute,
  useModalAttributes,
  useObservedElement,
  useFocusObserved,
  useRestoreFocusTarget,
  useRestoreFocusSource,
  createCustomFocusIndicatorStyle,
  tokens,
  typographyStyles,
  createLightTheme,
  teamsLightTheme,
  createTeamsDarkTheme,
  teamsDarkTheme,
  createHighContrastTheme,
  teamsHighContrastTheme,
  webLightTheme,
  createDarkTheme,
  webDarkTheme,
  themeToTokensObject,
  createFocusOutlineStyle,
  require_scheduler,
  Enter2 as Enter,
  Space2 as Space,
  Tab2 as Tab,
  ArrowDown2 as ArrowDown,
  ArrowLeft2 as ArrowLeft,
  ArrowRight2 as ArrowRight,
  ArrowUp2 as ArrowUp,
  End2 as End,
  Home2 as Home,
  PageDown2 as PageDown,
  PageUp2 as PageUp,
  Backspace2 as Backspace,
  Delete2 as Delete,
  Escape2 as Escape,
  useARIAButtonProps,
  useARIAButtonShorthand,
  useBadge_unstable,
  badgeClassNames,
  useBadgeStyles_unstable,
  renderBadge_unstable,
  Badge,
  presenceAwayRegular,
  presenceAwayFilled,
  presenceAvailableRegular,
  presenceAvailableFilled,
  presenceBlockedRegular,
  presenceBusyFilled,
  presenceDndFilled,
  presenceDndRegular,
  presenceOofRegular,
  presenceOfflineRegular,
  presenceUnknownRegular,
  usePresenceBadge_unstable,
  presenceBadgeClassNames,
  usePresenceBadgeStyles_unstable,
  PresenceBadge,
  useCounterBadge_unstable,
  counterBadgeClassNames,
  useCounterBadgeStyles_unstable,
  CounterBadge,
  mergeArrowOffset,
  resolvePositioningShorthand,
  usePositioning,
  usePositioningMouseTarget,
  usePortal_unstable,
  renderPortal_unstable,
  Portal,
  useTooltip_unstable,
  renderTooltip_unstable,
  tooltipClassNames,
  useTooltipStyles_unstable,
  Tooltip,
  FieldContextProvider,
  useFieldContext_unstable,
  useFieldContextValues_unstable,
  useFieldControlProps_unstable,
  renderField_unstable,
  useLabel_unstable,
  renderLabel_unstable,
  labelClassNames,
  useLabelStyles_unstable,
  Label,
  useField_unstable,
  fieldClassNames,
  useFieldStyles_unstable,
  Field,
  useCheckbox_unstable,
  renderCheckbox_unstable,
  checkboxClassNames,
  useCheckboxStyles_unstable,
  Checkbox,
  useTableSelection,
  useTableSort,
  useTableResizeHandle_unstable,
  renderTableResizeHandle_unstable,
  tableResizeHandleClassNames,
  useTableResizeHandleStyles_unstable,
  TableResizeHandle,
  useTableColumnSizing_unstable,
  useTableFeatures,
  createTableColumn,
  useTableCompositeNavigation,
  TableContextProvider,
  useTableContext,
  useTableCell_unstable,
  renderTableCell_unstable,
  tableCellClassName,
  tableCellClassNames,
  useTableCellStyles_unstable,
  TableCell,
  TableHeaderContextProvider,
  useIsInTableHeader,
  useTableRow_unstable,
  renderTableRow_unstable,
  tableCellActionsClassNames,
  useTableCellActionsStyles_unstable,
  CELL_WIDTH,
  tableSelectionCellClassNames,
  useTableSelectionCellStyles_unstable,
  tableRowClassName,
  tableRowClassNames,
  useTableRowStyles_unstable,
  TableRow,
  useTableBody_unstable,
  renderTableBody_unstable,
  tableBodyClassName,
  tableBodyClassNames,
  useTableBodyStyles_unstable,
  TableBody,
  useTable_unstable,
  renderTable_unstable,
  tableClassName,
  tableClassNames,
  useTableStyles_unstable,
  Table,
  useTableHeader_unstable,
  renderTableHeader_unstable,
  tableHeaderClassName,
  tableHeaderClassNames,
  useTableHeaderStyles_unstable,
  TableHeader,
  useTableHeaderCell_unstable,
  renderTableHeaderCell_unstable,
  tableHeaderCellClassName,
  tableHeaderCellClassNames,
  useTableHeaderCellStyles_unstable,
  TableHeaderCell,
  useColumnIdContext,
  ColumnIdContextProvider,
  useTableRowIdContext,
  TableRowIdContextProvider,
  useTableSelectionCell_unstable,
  renderTableSelectionCell_unstable,
  TableSelectionCell,
  useTableCellActions_unstable,
  renderTableCellActions_unstable,
  TableCellActions,
  useTableCellLayout_unstable,
  renderTableCellLayout_unstable,
  tableCellLayoutClassNames,
  useTableCellLayoutStyles_unstable,
  TableCellLayout,
  DataGridContextProvider,
  useDataGridContext_unstable,
  useDataGridCell_unstable,
  renderDataGridCell_unstable,
  dataGridCellClassNames,
  useDataGridCellStyles_unstable,
  DataGridCell,
  useDataGridSelectionCell_unstable,
  renderDataGridSelectionCell_unstable,
  dataGridSelectionCellClassNames,
  useDataGridSelectionCellStyles_unstable,
  DataGridSelectionCell,
  useDataGridRow_unstable,
  renderDataGridRow_unstable,
  dataGridRowClassNames,
  useDataGridRowStyles_unstable,
  DataGridRow,
  useDataGridBody_unstable,
  renderDataGridBody_unstable,
  dataGridBodyClassNames,
  useDataGridBodyStyles_unstable,
  DataGridBody,
  useDataGrid_unstable,
  renderDataGrid_unstable,
  dataGridClassNames,
  useDataGridStyles_unstable,
  useDataGridContextValues_unstable,
  DataGrid,
  useDataGridHeader_unstable,
  renderDataGridHeader_unstable,
  dataGridHeaderClassNames,
  useDataGridHeaderStyles_unstable,
  DataGridHeader,
  useDataGridHeaderCell_unstable,
  renderDataGridHeaderCell_unstable,
  dataGridHeaderCellClassNames,
  useDataGridHeaderCellStyles_unstable,
  DataGridHeaderCell
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v17.0.2
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.development.js:
  (** @license React v0.20.2
   * scheduler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

keyborg/dist/keyborg.esm.js:
  (*!
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)

keyborg/dist/keyborg.esm.js:
  (*!
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)

tabster/dist/tabster.esm.js:
  (*!
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)

tabster/dist/tabster.esm.js:
  (*!
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)

tabster/dist/tabster.esm.js:
  (*!
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)

tabster/dist/tabster.esm.js:
  (*!
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)

tabster/dist/tabster.esm.js:
  (*!
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)
*/
//# sourceMappingURL=chunk-73QT74S7.js.map
